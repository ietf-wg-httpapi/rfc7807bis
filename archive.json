{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-04-25T01:27:21.418777+00:00",
  "repo": "ietf-wg-httpapi/rfc7807bis",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "0E8A16"
    },
    {
      "name": "media_type",
      "description": "Issues requiring new media type",
      "color": "FDE9F6"
    },
    {
      "name": "header_field",
      "description": "header field related issues",
      "color": "980BAD"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU3OTY0NTYzNjU=",
      "title": "Update references",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/1",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "... to account for things that have been published since.",
      "createdAt": "2021-01-28T23:32:38Z",
      "updatedAt": "2021-04-26T03:26:59Z",
      "closedAt": "2021-04-26T03:26:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is done - can reopen if we find anything else.",
          "createdAt": "2021-04-26T03:26:59Z",
          "updatedAt": "2021-04-26T03:26:59Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU3OTY0NTY2NjQ=",
      "title": "IANA considerations",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/2",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "editorial"
      ],
      "body": "... can be updated to just tell IANA to point the registrations at this document.",
      "createdAt": "2021-01-28T23:33:20Z",
      "updatedAt": "2021-07-14T05:50:57Z",
      "closedAt": "2021-07-14T05:50:57Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU3OTY0NTY5MjE=",
      "title": "Validate HTTP message examples",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/3",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-01-28T23:33:59Z",
      "updatedAt": "2021-07-14T05:54:31Z",
      "closedAt": "2021-07-14T05:54:31Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU3OTY0NTcxNTg=",
      "title": "Deprecate XML?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/4",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just asking.",
      "createdAt": "2021-01-28T23:34:32Z",
      "updatedAt": "2021-02-10T01:35:26Z",
      "closedAt": "2021-02-10T01:35:26Z",
      "comments": [
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "Is there any real harm in keeping XML in? And in the cases where the happy path of an API is using XML - they do still exist :) - then having the unhappy paths also using XML is hugely convenient, rather than needing to parse success vs failure in different ways.",
          "createdAt": "2021-01-29T17:26:43Z",
          "updatedAt": "2021-01-29T17:26:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like we can close this with no action, then. If anyone wants to fight for it, we can reopen.",
          "createdAt": "2021-02-10T01:35:25Z",
          "updatedAt": "2021-02-10T01:35:25Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU3OTY0NTc2NDI=",
      "title": "Incorporate errata",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/5",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Either by making editorial changes or filing issues.\r\n\r\n[errata](https://www.rfc-editor.org/errata_search.php?rfc=7807)",
      "createdAt": "2021-01-28T23:35:47Z",
      "updatedAt": "2021-04-26T03:34:14Z",
      "closedAt": "2021-04-26T03:34:14Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, as we have two errata currently, addressed by the commit above and #19.",
          "createdAt": "2021-04-26T03:34:14Z",
          "updatedAt": "2021-04-26T03:34:14Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU3OTY0NTk4NzU=",
      "title": "Multiple problems",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/6",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mnot",
        "sdatspun2"
      ],
      "labels": [],
      "body": "Sometimes an API will want to report more than one problem in a response. 7807 explains that this can be done in extensions, but does not natively allow multiple problems to be conveyed, because there was concern that doing so would make it too easy to contradict the semantics of the status code.\r\n\r\nSince publication, developers have still wanted a generic solution to this. A few possible directions we could go on:\r\n\r\n0. Do nothing\r\n1. Improve the documentation regarding how to handle multiple problems in extensions\r\n2. Introduce a way to natively convey multiple problems, as long as they share the same status code semantics\r\n3. Something else?",
      "createdAt": "2021-01-28T23:41:07Z",
      "updatedAt": "2022-03-24T20:47:27Z",
      "closedAt": "2022-03-24T20:47:27Z",
      "comments": [
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "I'm somewhat curious how often multiple *different* problems really happen, as opposed to multiple different facets of the same problem.\r\n\r\nBy \"multiple different facets of the same problem\", I'm meaning things like request validation failures. A request might be invalid because of multiple different fields in the incoming JSON(/whatever content type is being used). But the overall problem is still \"Validation Failed\". It's just that it failed for several reasons.\r\n\r\nThe real multiple problems would, in my mind at least, be something like:\r\n* The incoming request was invalid (So a \"Validation Failed\" problem with a status of 400/422)\r\n* And you don't have permission to do this (So a \"Permission Denied\" problem with a status of 403)\r\n* And the resource doesn't exist (So a \"Not Found\" problem with a status of 404)\r\n\r\nThe \"multiple facets\" case is relatively simple to support. Indeed, I'm sure the wider community have a myriad of different ways to do it already, but obviously a standard way to achieve it would be better.\r\n\r\nThe \"multiple problems\" case is much harder, simply because of the different status codes that can come up. But my (potentially naive) suspicion is that it's also less useful.",
          "createdAt": "2021-01-29T17:25:13Z",
          "updatedAt": "2021-01-29T17:25:13Z"
        },
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "I hope it's useful, here is the scenario of what we currently do (it's a work in progress).\r\n\r\nWe currently retrieve various problem documents from various api calls that are done in a scatter/gather scenario, unbeknownst to the client.\r\nWe aggregate those potential multiple problems:\r\n - if they're all the same type / status, we reuse this and agrgregate the details.\r\n - if they're not of the same type / status, we extract a response status (see below) and set the type to an \"aggregate\", and add a `inner_problems` array of problem documents to provide details of each of the errors encountered during this call\r\n\r\nThe status code in the case of an aggregate is set according to those rules:\r\n - if all status codes are the same, use this status code\r\n - if status codes are not the same but in the same 100th, set it to 400 or 500\r\n - if it's spread across, use a 500\r\n\r\nIt's not ideal but it allows us to communicate to the client why their request failed, with information about each dataset that may have rejected a request.\r\n\r\n",
          "createdAt": "2021-01-30T10:22:09Z",
          "updatedAt": "2021-01-30T10:22:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@serialseb that's an interesting pattern. I could see recommending that in the spec, and advising problem definitions to think carefully about accommodating multiple instances of their details...",
          "createdAt": "2021-02-10T01:41:00Z",
          "updatedAt": "2021-02-10T01:41:00Z"
        },
        {
          "author": "gervaisb",
          "authorAssociation": "NONE",
          "body": "I agree with the _facets_ ideas. And I would go further by asking to provide a format for validation errors.",
          "createdAt": "2021-02-10T13:31:01Z",
          "updatedAt": "2021-02-10T13:31:01Z"
        },
        {
          "author": "gabesullice",
          "authorAssociation": "NONE",
          "body": "> The \"multiple problems\" case is much harder, simply because of the different status codes that can come up. But my (potentially naive) suspicion is that it's also less useful.\r\n\r\nI agree with this. I find it hard to imagine that clients will actually attempt to resolve all problems in a multi-status response before retrying a request because the implementation seems like it would be overly complicated. @serialseb, in practice, do your clients attempt to resolve multiple the problems or are the problems merely logged?\r\n\r\nOption 1 seems most pragmatic to me. I.e. explain that a problem type can use extensions to define an array of subproblems with examples. Then explain that if the problems are not subproblems of a broader category, the server should choose the most critical problem.\r\n\r\nIf the server doesn't choose the most critical problem, then we will likely have to provide a way to order/prioritize problems in the media type to guide the client. For example, if a server responds with both the `insufficient-storage` and `invalid-field` error types, the client will have to understand that it's a waste of time to fix the validation error because the server is out of space. This still permits a client to fix multiple problems iteratively by retrying the request after each problem has been fixed.\r\n",
          "createdAt": "2021-03-12T18:37:33Z",
          "updatedAt": "2021-03-12T18:37:33Z"
        },
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "@gabesullice in practice, when there are multiple problems, it comes to a human to analyse. That analysis can be done iwth raw text, or with structured data. People do structured data all the time, and if you don't have an answer they'll build their own.\r\nNow, the rules we use is to allow a simple automated system to take care of the cases where the most specific issues happen (say, two gateways are timing out, it's a timeout, we merge towards a specific status code, automated clietns take care of it). In the cases where they're not, the lack of standard way of communicating a common scenario leads to one of those less than ideal scenarios: try not to step on the spec's turf, and create your own schema (implementation cost reduction through network effect nullified, no way to generiically notify operators as schema is now per api), not give data (worst outcome), or give text and hope someone reads it.\r\nOperational support scenarios can be automated in the \"let's get a human involved\" pathway, and as long as we have no answer for this, no tool vendor will use this, making everything more complex, more isolated, and in turn, more expensive.\r\n\r\nIf one of the variables is badly written and an invalid URI, and another one does not exist, and i've been teaching people to reuse errors they understand, i now have no standard way to explain that one problem is X and another is Y.\r\n\r\nOperational is part of APIs and automation is as important to DevRelOps as it is to just plain APIs. ",
          "createdAt": "2021-03-12T19:06:57Z",
          "updatedAt": "2021-03-12T19:06:57Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "Thank you @serialseb for the insights into how you're handling this issue. It's an interesting approach to the limitations of the original RFC and reflects what we're also trying to 'fix' with [our I-D](https://datatracker.ietf.org/doc/draft-cedik-http-warning/). Do you also return the `status` attribute within the `inner_problems` array to let the client know the severity of the problem?\r\n\r\n> if a server responds with both the insufficient-storage and invalid-field error types, the client will have to understand that it's a waste of time to fix the validation error because the server is out of space\r\n\r\n@gabesullice it may be a waste of time at the moment, but when you know beforehand that fixing the space problem won't make the other problem(s) go away one could also think about correcting the `invalid-field error` before sending a new request. \r\n\r\n> This still permits a client to fix multiple problems iteratively by retrying the request after each problem has been fixed.\r\n\r\nYes, but isn't that a bad user experience? I'd rather know everything I'm doing wrong right now before making a new request, fixing one problem, making another request, fixing another problem, and so on.",
          "createdAt": "2021-03-30T06:25:24Z",
          "updatedAt": "2021-03-30T06:25:24Z"
        },
        {
          "author": "gabesullice",
          "authorAssociation": "NONE",
          "body": "> Yes, but isn't that a bad user experience?\r\n\r\nIt's certainly a trade off, but fixing one problem at a time is the best way to debug. Whenever I try to make more than one change at a time, I end up in a more chaotic debugging state than before. It's good practice to make isolated changes that you understand rather than throwing things at the wall to see what sticks.\r\n\r\nThe trade off is that the media type is less flexible and certain things will be more difficult to convey.\r\n\r\nHowever, in my experience with the JSON:API spec (which supports multiple error objects), server implementers tend to dump useless stack traces into response bodies and try to abuse them to make non-atomic updates. Multiple errors also encourage client implementers to try the kitchen sink approach to debugging.\r\n\r\nSo it's in the spirit of designing something that makes good practices easy and bad practices difficult that I'm pushing back against supporting multiple problem details.\r\n\r\n---\r\n\r\nMy suggestion is to finalize this document for the single error case. Then mint an error type called `multiple` which defines an extension member named `instances`. The value of `instances` would be an array of problem objects as defined for the single error case. Perhaps it will add additional extension members for those child objects as well.\r\n\r\nTo benefit from network effects, the `multiple` type can be published using the IETF process. By separating that into its own document, you can iterate on that design in a separate document without postponing this one.",
          "createdAt": "2021-03-30T13:54:55Z",
          "updatedAt": "2021-03-30T13:54:55Z"
        },
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "> Do you also return the `status` attribute within the `inner_problems` array to let the client know the severity of the problem?\r\n\r\nYes we do, but this is only used for operators to gain additional insight.\r\n\r\n> To benefit from network effects, the multiple type can be published using the IETF process. By separating that into its own document, you can iterate on that design in a separate document without postponing this one.\r\n\r\nI'd be receptive to such a proposal\r\n\r\n\r\n",
          "createdAt": "2021-04-28T07:19:14Z",
          "updatedAt": "2021-04-28T07:19:14Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "> So it's in the spirit of designing something that makes good practices easy and bad practices difficult that I'm pushing back against supporting multiple problem details.\r\n\r\nI'm with you on making bad practices difficult and good practices easy \ud83d\ude01 \r\n\r\n> My suggestion is to finalize this document for the single error case. Then mint an error type called multiple which defines an extension member named instances. The value of instances would be an array of problem objects as defined for the single error case. Perhaps it will add additional extension members for those child objects as well.\r\n\r\nSounds promising. I'd be willing to support this. ",
          "createdAt": "2021-05-04T05:58:27Z",
          "updatedAt": "2021-05-04T05:58:27Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">However, in my experience with the JSON:API spec (which supports multiple error objects), server implementers tend to dump useless stack traces into response bodies and try to abuse them to make non-atomic updates. \r\n\r\nI am not a proponent of JSON:API spec, but honestly, this has nothing to do with the multiple error objects. It is due to lack of knowledge/discipline/governance on the API developer's side. Someone can dump exception in `detail` even today. A few days ago, I had to explain to a very senior Java developer that you just cannot stream Java exceptions in error response of an HTTP API. \r\n\r\n>My suggestion is to finalize this document for the single error case. Then mint an error type called multiple which defines an extension member named instances. The value of instances would be an array of problem objects as defined for the single error case. Perhaps it will add additional extension members for those child objects as well.\r\n\r\nI disagree. Multiple problems could be added using extension mechanism today as well. One of the main reasons for -bis is to provide support for multiple problems without any extension (in order to increase adoption).",
          "createdAt": "2021-05-04T13:10:02Z",
          "updatedAt": "2021-05-04T13:10:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My .02 - If we define a `multiple` type, some implementations are likely to use it by default, even when a single problem is transferred. That seems suboptimal, because it loses the mapping between the HTTP status code and the actual problem type.\r\n\r\nAlso, a `multiple` problem type would by necessity have to use a generic status code (probably `207`), thereby _reducing_ semantics exposed in HTTP, which isn't something we should be recommending.",
          "createdAt": "2021-07-14T06:52:41Z",
          "updatedAt": "2021-07-14T06:52:41Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like we are back to square one on the issue of support for multiple problems. Imho, having HTTP status code duplicated in the problem details response body was not desirable. Now, that it is in the RFC, its presence creates a real problem in supporting the multiple problems use case which is also a common use case in any HTTP API accepting requests with a slightly complex schema. ",
          "createdAt": "2021-07-19T05:41:55Z",
          "updatedAt": "2021-07-19T05:41:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's not a matter of whether or not the status code is duplicated; it's whether the semantics of the problem are appropriately reflected in the status code.",
          "createdAt": "2021-07-19T05:43:32Z",
          "updatedAt": "2021-07-19T05:43:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we're gravitating towards the (1) direction outlined above - 'Improve the documentation regarding how to handle multiple problems in extensions'\r\n\r\nWe could do that by:\r\n\r\n* Adding examples with multiple instances of the same problem in them\r\n* Adding prose that explains how to handle different scenarios, such as:\r\n  * multiple instances of the same problem type\r\n  * multiple problems of different types\r\n\r\n",
          "createdAt": "2021-07-26T04:08:18Z",
          "updatedAt": "2021-07-26T04:08:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in 111: @mnot to write preliminary PR.",
          "createdAt": "2021-07-27T21:55:09Z",
          "updatedAt": "2021-07-27T21:55:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also, since we now have a registry, we could go ahead and **define** a problem type that handles multiple instances -- for example, 'json input validation error'. That might help tease out some of the issues here.",
          "createdAt": "2021-07-29T07:28:39Z",
          "updatedAt": "2021-07-29T07:28:39Z"
        },
        {
          "author": "FusionFabricUser",
          "authorAssociation": "NONE",
          "body": "here is the model followed @Finastra \r\nhttps://fusionfabric.github.io/open-api-standard/Responses_and_Errors.html#finastra-error-message-standards \r\n\r\nwe are using a fields causes that is defined as an array of object. use case is  that for a given failure like a transaction several causes can be implied (ie first field not correct size, second not a number etc  )\r\n\r\n\r\nkey design decision would be is this a single object so cause , or an array of object \r\n\r\nnotice that the cause has been also introduce by Zalando \r\nhttps://github.com/zalando/problem that has been integrated  with a Spring extension",
          "createdAt": "2021-09-06T20:24:32Z",
          "updatedAt": "2021-09-06T20:24:32Z"
        },
        {
          "author": "thexa4",
          "authorAssociation": "NONE",
          "body": "Wouldn't multipart/related [[RFC2112](https://datatracker.ietf.org/doc/html/rfc2112)] be a good fit for this?",
          "createdAt": "2021-10-13T23:48:14Z",
          "updatedAt": "2021-10-13T23:48:14Z"
        },
        {
          "author": "FusionFabricUser",
          "authorAssociation": "NONE",
          "body": "\r\nMulti part tend to disapears in the API spaces as far as i can see (unfortunate or not) \r\n\r\n@thexa4 , array is a better pattern for API , mutli part is usually  attached to concept of differents payload encoding, that here i don't see the point for 99 % of use cases . if ever you requires a dedicated pdf file for the causes , it should go to a functional pattern or a custom extension of it following a keep it simple approach \r\n",
          "createdAt": "2021-10-14T06:56:55Z",
          "updatedAt": "2021-10-14T06:56:55Z"
        },
        {
          "author": "nnmrts",
          "authorAssociation": "NONE",
          "body": "This comment, as most of my comments on issues in repositories, got a bit out of hand and way too long. I'm sorry for that and my limited english vocabulary to make this a bit more compact.\r\n\r\n---\r\n\r\nAlthough this issue seems to go into the opposite direction, I agree with https://github.com/ietf-wg-httpapi/rfc7807bis/issues/6#issuecomment-810272529 by @gabesullice but don't think there should even be a \"multiple problems\" option. Isn't there always a \"root problem\"? Or at least a \"first problem\" or \"most important problem\"? I don't feel like telling a client about only one problem at a time is bad user experience.\r\n\r\nIt might seem like a bad user experience from the perspective of a human debugging their request by hand, but even then I personally think it's more logical to solve issues iteratively. Yes, one needs to eventually make multiple requests to fix their request, but considering today's average internet speed and the expected small size of problem details responses, I think it's *just fine*.\r\n\r\nBut if we think about a computer program handling a problem details response and trying to \"fix it\", I think it becomes even more clear that only one problem at a time should be in a response. I realize this might be \"opinionated\", but a client app with multiple atomic handlers each able to \"fix\" one type of problem seems more sustainable and logical to me than either one huge handler that \"fixes\" all types of problems or a lot of handlers each fixing every possible combination of problems.\r\n\r\nI think this RFC and APIs should be designed considering that and at the moment it already feels optimal as is in this regard. If an API for some reason still has to respond with \"multiple problems\", it already can, just as described at the end of section 3:\r\n\r\n> The ability to convey problem-specific extensions allows more than one problem to be conveyed.\r\n\r\n@mnot in the first post of this issue states that the current version of the RFC \"does not natively allow multiple problems to be conveyed\", but I feel like it actually does. Even the example given after that quote from the RFC \"conveys\", at least to a human reader, that there are multiple problems, since the value of the `title` field is \"Your request parameter**s** (plural) didn't validate.\" But actually, and I am trying to avoid going full philosophical here, isn't it true that every collection of problems can be seen as one big problem? And every single one problem could theoretically be split up into multiple problems. Let's take a look at the `detail` field of the first example: \"Your current balance is 30, but that costs 50.\" Sure, the problem in this case is called \"out-of-credit\" and the obvious solution proposed is topping up the account with more credits. But this RFC didn't tell us this \"obvious\" solution, **we** came up with it and that's how it should be. The problem of not having enough credits on your account could theoretically be split up in the problem of you being a bit forgetful or the problem that the service is expensive or their pricing system isn't transparent enough. I realize this isn't the best example for what I'm trying to say, but I still hope you understand it.\r\n\r\nIt is and only can be the responsibility of whoever implements the API and whoever implements the client, to write code that knows what problems to expect, how the `detail` field or an extension field is structured, which of them can be fixed and to then provide solutions for them. So I feel it is also their responsibility to write code that \"knows\" when to expect multiple problems, or a single one, or both. Even just the presence of an extension field called `subProblems` or `invalid-params` can indicate that there are multiple problems that each have to be fixed separately.\r\n\r\nI think specifically defining some sort of \"multiple\" type or field is not the optimal strategy here and goes against the spirit of freedom across the rest of this RFC. I realize the purpose of a standard is not to embrace freedom and doing things completely different to anyone else \ud83d\ude06. But defining a specific structure for conveying that there are multiple problems could be dangerous and actually impede adoption, in my opinion. For example, if my API only detected a single validation error, does my server now need to flip the `multiple` boolean value? Is `invalid-params` now still an array with just one object in it, or just one object, so actually a different data structure my client needs to handle specifically? If it's always an array why even use the `multiple` field? My client will iterate over the array anyway and doesn't care how big it is.\r\n\r\nI think keeping this aspect of the RFC as is would be a great opportunity to let the community dynamically decide on a best practice and eventually draft a separate document once there is more consensus and more people worked with this specification in the real world.\r\n\r\nI definitely don't think the current specification doesn't hinder anyone from handling multiple problems. In the case of form validation for example, where you might only want to send one request for the whole validation, sure, feel free to let the API respond with an array of validation errors in a custom extension field. A client submitting a form will already expect a specific structure of response anyway. As I said, abstractly seen, a multitude of validation errors is still only one specific \"big\" problem, namely that there are validation errors. The details of those problems can then be described in either the `detail` field and/or a custom extension field.",
          "createdAt": "2022-02-04T13:15:37Z",
          "updatedAt": "2022-02-04T13:19:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "going back to @mnot's initial comment, i am in favor of option 0, which is to do nothing. if we go down the path of showing speculative extensions, we kind of \"define\" them without really defining them. that in my mind is the real risk of showing hypothetical extensions in examples. people *will* use them, regardless how clearly you say \"this is not actually an extension and just for illustration\".",
          "createdAt": "2022-02-04T14:59:40Z",
          "updatedAt": "2022-02-04T14:59:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, with @sdatspun2's PR merged a while back, we currently:\r\n\r\n1. Describe how to design extensions to accommodate multiple instances of the same type\r\n2. Describe how to use `207 Multi-Status` to convey multiple problems with different types/status codes\r\n3. Do not describe how one might convey multiple problems with different types but the same status code.\r\n\r\nI think (1) is fine and good. \r\n\r\nRight now, (2) seems like it's recommending the pattern, but doesn't define an actual type for use in that situation. That's not great. **If** we're going to show that pattern, we should probably define the type for use in that situation (especially since we have a registry now). However, I have serious doubts about the wisdom of recommending that pattern, and feel like we should either remove that text, or at least heavily contextualise it.\r\n\r\nRegarding (3) -- again, **if** we want to document that, we should define a type. I tend to think we shouldn't, though.\r\n\r\nIf we retract (2) and don't attempt (3), we might want to add some text along the lines of:\r\n\r\n> When an API encounters multiple problems that do not share the same type, it is RECOMMENDED that the most relevant  or urgent problem be represented in the response. While it is possible to create generic \"batch\" problem types that convey multiple, disparate types, they do not map well into HTTP semantics.",
          "createdAt": "2022-02-07T00:56:43Z",
          "updatedAt": "2022-02-07T00:56:43Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-02-07 01:56, Mark Nottingham wrote:\n> Right now, (2) seems like it's recommending the pattern, but doesn't \n> define an actual type for use in that situation. That's not great. *If* \n> we're going to show that pattern, we should probably define the type for \n> use in that situation (especially since we have a registry now). \n\ni agree. showing something without defining it in the end will be a \"bad \ndefinition\" because people will take it as shown and run with it.\n\n> However, I have serious doubts about the wisdom of recommending that \n> pattern, and feel like we should either remove that text, or at least \n> heavily contextualise it.\n\nmy vote goes to removing it.\n\n> Regarding (3) -- again, *if* we want to document that, we should define \n> a type. I tend to think we shouldn't, though.\n\nsame here.\n\n>     When an API encounters multiple problems that do not share the same\n>     type, it is RECOMMENDED that the most relevant or urgent problem be\n>     represented in the response. While it is possible to create generic\n>     \"batch\" problem types that convey multiple, disparate types, they do\n>     not map well into HTTP semantics.\n\ni like it.\n",
          "createdAt": "2022-02-07T07:40:09Z",
          "updatedAt": "2022-02-07T07:40:09Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">If we retract (2) and don't attempt (3), we might want to add some text along the lines of:\r\n\r\n>\"When an API encounters multiple problems that do not share the same type, it is RECOMMENDED that the most relevant or urgent problem be represented in the response. While it is possible to create generic \"batch\" problem types that convey multiple, disparate types, they do not map well into HTTP semantics.\"\r\n\r\n+1",
          "createdAt": "2022-02-07T14:25:14Z",
          "updatedAt": "2022-02-07T14:25:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. It seems like we agree here -- I'll ping the mailing list and make sure everyone is aware / on board.",
          "createdAt": "2022-02-07T23:37:28Z",
          "updatedAt": "2022-02-07T23:37:28Z"
        },
        {
          "author": "LasneF",
          "authorAssociation": "NONE",
          "body": "\r\n\r\nmy 2 cents ,\r\nwhen you do a REST request you expect to have a single status , this is the HTTP status , here a 4XX or 5XX,  for sure not a 207 that is part of 2XX section so a success \r\n\r\nHTTP requires it fails or it succeed\r\n\r\n what problem RFC provides is a more standard way to return feedback about this status ... this is where 'problem' is used\r\nRFC problem describes the http status of error with standardized information (title , details, type) \r\n\r\nThis status can have multiple root cause this is why having as an array is a good pattern . it is not an array of problem  (it wont make sense according to the definition of http problems) \r\nbut an array of cause. you can have a single explanation of a return that can be explained due to various cause \r\n\r\ncause could be ... either free form (easiest) \ud83d\udc4d   , \r\n\r\nhere is a use case about Form filling that is failing . Cause can be the list of fieldName and Value in default \r\nbut this does not fit all use cases\r\n\r\n{\r\n  \"type\": \"https://api.zz.com/validation-error\",\r\n  \"title\": \"The request is invalid\",\r\n  \"status\": 400,\r\n  \"detail\": \"Customer Creation Failure\",\r\n  \"causes\": [\r\n    {\r\n      \"title\": \"The name is too Long\",\r\n      \"field\": \"name\",\r\n      \"fieldValue\": \"AsuperExtraLongName\"\r\n    },\r\n     {\r\n      \"title\": \"Date of Birth is in the future\",\r\n      \"field\": \"dateOfBirth\",\r\n      \"fieldValue\": \"20/20/2200\"\r\n    }\r\n  ]\r\n}\r\n\r\nanother pattern can be to have recursive causes definition ... but this is too munch prescriptive \ud83d\udc4e   \r\n{\r\n  \"type\": \"https://api.zz.com/validation-error\",\r\n  \"title\": \"The request is invalid\",\r\n  \"status\": 400,\r\n  \"detail\": \"Cannot create Order\",\r\n  \"causes\": [ \r\n      {\r\n           \"type\": \"https://api.zz.com/validation-error\",\r\n            \"title\": \"Order Management ; one of the item cannot be fulfilled \",\r\n            \"status\": 404,\r\n            \"detail\": \"Item management , item XXX cannot be found \",\r\n            causes [\r\n                  type\": \"https://api.zz.com/validation-error\",\r\n                  \"title\": \"Storage\",\r\n                  \"status\": 400,\r\n                  \"detail\": \"Item XXX is out of stock\",\r\n            }\r\n        }]\r\n }\r\n  \r\n  ",
          "createdAt": "2022-02-09T14:46:41Z",
          "updatedAt": "2022-02-09T14:46:41Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU3OTY3MDkzNjQ=",
      "title": "Repository of common Problem types",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/7",
      "state": "CLOSED",
      "author": "sazzer",
      "authorAssociation": "NONE",
      "assignees": [
        "mnot"
      ],
      "labels": [],
      "body": "(I'm not sure if this is the correct place to propose this, so apologies if not!)\r\n\r\nAs RFC-7807 gains wider-spread adoption, it is becoming the case that more and more APIs are returning effectively the same problems with different values for the fields. This makes it difficult to work across different APIs, because you need to understand that different problems from those APIs actually mean the same thing.\r\n\r\nCommon examples that you might expect to see include:\r\n* Resource not found\r\n* Authentication failure\r\n* Optimistic lock failure (e.g. the `If-Match` header on a `PUT` request has the wrong value)\r\n* Request validation failure\r\n\r\nIt seems that it would be useful to have a repository of these common problem types that can then be reused across APIs, so that ideally these common situations can be handled in the exact same way on the client.\r\n\r\nEffectively the same idea as the standard list of [Link Relations](https://www.iana.org/assignments/link-relations/link-relations.xhtml), whereby all clients that see a link relation of, for example, `self` or `item` know what they mean regardless of the API that produced them.",
      "createdAt": "2021-01-29T09:08:21Z",
      "updatedAt": "2021-07-29T07:26:56Z",
      "closedAt": "2021-07-29T07:26:56Z",
      "comments": [
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Unlike relation type name (`self` or `item), problem `type` is a URI in 7807. Is there any other example of a repository of entities where each entity is uniquely addressable? \r\n\r\nAlso, I am working on API for such a repository https://github.com/sdatspun2/error-catalog-service (When you read, replace \"Error Type\" with \"Problem Type\" and \"Error Catalog\" with \"Problem Type Repository\"). I would like to submit it here to evolve it if there is interest.",
          "createdAt": "2021-01-31T17:20:14Z",
          "updatedAt": "2021-01-31T17:20:14Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "My concern here, and why I raised this ticket, is less to do with APIs\nusing the same value for different meanings, and instead to do with APIs\nusing different values for the same meaning. Mostly it makes API design\nthat bit easier if there is a well known value to use for what you're\ntrying to indicate.\n\nOn Sun, 31 Jan 2021, 17:20 Sanjay Dalal, <notifications@github.com> wrote:\n\n> Unlike relation type name (self or item), problem type` is a URI in 7807.\n> Is there any other example of a repository of entities where each entity is\n> uniquely addressable?\n>\n> Also, I am working on API for such a repository\n> https://github.com/sdatspun2/error-catalog-service (When you read,\n> replace \"Error Type\" with \"Problem Type\" and \"Error Catalog\" with \"Problem\n> Type Repository\"). I would like to submit it here to evolve it if there is\n> interest.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/7#issuecomment-770416575>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGB7BDO32QVU2OTYXDTS4WGNVANCNFSM4WYQPZJA>\n> .\n>\n",
          "createdAt": "2021-01-31T18:03:18Z",
          "updatedAt": "2021-01-31T18:03:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "There are a couple of ways to go here:\r\n\r\n1. Create an IANA registry of problem types, much as for link relations.\r\n2. Create a publicly-coordinated informal repository (eg, in a wiki).\r\n\r\nBecause types are required to be URIs, avoiding conflicts (one of the main reasons to use a registry) isn't relevant; it would be more to aid discovery. If we wanted some sort of quality filter on it, we'd probably use an IANA registry, and would need a process around that (e.g., expert review, IETF review; see [RFC8126 Section 4](https://tools.ietf.org/html/rfc8126#section-4)). \r\n\r\nNote that 7087 allows relative URIs in the `type` field, we couldn't use bare tokens like link relations do. However, if folks wanted \"neutral\" URIs that didn't reflect a particular vendor, we could easily mint URIs in a common name space like `urn:ietf:params:http-problems:foo` or `https://httpwg.org/http-problems/foo` or something else.\r\n\r\nP.S. Resource Not Found and Authentication Failure are already HTTP status codes -- 404 and 401, respectively (unless you mean non-HTTP auth in the latter case). ",
          "createdAt": "2021-02-01T04:20:45Z",
          "updatedAt": "2021-02-01T04:20:45Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> P.S. Resource Not Found and Authentication Failure are already HTTP status codes -- 404 and 401, respectively (unless you mean non-HTTP auth in the latter case).\r\n\r\nThese are already HTTP status codes, but it's not unreasonable for APIs to want to *always* return a Problem response for any error. Sometimes it's easier to develop the server code that way (e.g. in Rust it's very verbose to have many different response types.) Sometimes it's easier to allow clients to always assume an `application/problem+json` response. Sometimes it's just that people like consistency. And actually the only real downside seems to be that the response payload is non-zero in size\r\n\r\nGiven that though, it means that people start to mint URIs for problem types that directly correspond to HTTP status codes. And, odds are, different people do it differently. That's a key example where some standard values would just make that a little bit easier. For example, I've started using values like `https://httpstatuses.com/404` in these cases - it doesn't actually tell you anything more than the HTTP status code, but it means that the response body is always in a consistent format which just makes life that little bit easier in some cases. (I did consider a link to the appropriate section of RFC-7232, but that seemed a bit more awkward given that it would need a fragment in the URI)",
          "createdAt": "2021-02-04T09:35:00Z",
          "updatedAt": "2021-02-04T09:35:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "The RFC recommends that `about:blank` be used in this situation. We intentionally did not have per-status-code values, because that would encourage developers to ignore the real status code, and because duplicating values at different layers is a vector for bugs and security issues.",
          "createdAt": "2021-02-04T23:32:27Z",
          "updatedAt": "2021-02-04T23:32:27Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "Ah - I'd totally missed that paragraph! That does make a lot of sense,\nespecially when coupled with the absence of the \"type\" parameter mapping on\nto \"about:blank\". :)\n\nOn Thu, 4 Feb 2021 at 23:32, Mark Nottingham <notifications@github.com>\nwrote:\n\n> The RFC recommends that about:blank be used in this situation. We\n> intentionally did not have per-status-code values, because that would\n> encourage developers to ignore the real status code, and because\n> duplicating values at different layers is a vector for bugs and security\n> issues.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/7#issuecomment-773672594>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGAO2P4YQSS3XB73MOLS5MVBVANCNFSM4WYQPZJA>\n> .\n>\n",
          "createdAt": "2021-02-04T23:41:46Z",
          "updatedAt": "2021-02-04T23:41:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "For \"standard\" problem types, would folks be willing to stomach the `urn:ietf:params:http-problems:foo` form? That's likely the most permanent, easy way to do it.\r\n\r\nUsing `httpwg.org` is also possible, as would be `ietf.org`. Some might complain that they (especially the former) are rooted in DNS, and therefore might not be stable over a long time scale.\r\n\r\nAnother option would be minting our own URI scheme, to make something like `http-problem:foo`. That might make some of the URN folks unhappy, though; would have to try to find out.",
          "createdAt": "2021-02-10T01:38:34Z",
          "updatedAt": "2021-02-10T01:38:34Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we need to resolve #11 before we can decide on the format.",
          "createdAt": "2021-02-10T01:41:23Z",
          "updatedAt": "2021-02-10T01:41:23Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "I guess the form we go for depends on some other things. If we decide (per #11 as @asbjornu says) that the value should be a URI, and that it should resolve to documentation, then something like `https://httpwg.org/problems/foo` might be better. But then, as you say, that means that URL has to remain stable for the foreseeable future.\r\n\r\nPersonally speaking, I'm fine with the `urn:ietf:params:http-problems:foo` idea - I currently always use `tag:xxx,2021:foo` for mine anyway - but it does mean that they are definitely not resolvable.\r\n\r\nI'm less keen on the idea of a new scheme. It is obvious what's happening, but it does start to look like *all* problems must be in that scheme, which then potentially defeats the point of #11 in the first place. Also, (and I might be missing things here) it seems that the only real benefit of `http-problem:foo` over `urn:ietf:params:http-problems:foo` is in the length of the string, which isn't a huge deal - it's a saving of 17 characters.",
          "createdAt": "2021-02-10T09:57:25Z",
          "updatedAt": "2021-02-10T09:57:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "In the meeting, folks seemed to pretty strongly lean towards an IANA registry with some bar to entry (TBD).",
          "createdAt": "2021-03-15T06:48:36Z",
          "updatedAt": "2021-03-15T06:48:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "See #24 for a proposal.",
          "createdAt": "2021-07-14T05:48:31Z",
          "updatedAt": "2021-07-14T05:48:31Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "thanks for #24 , @mnot! i like it, but my concern is a bit that if we have a registry, wouldn't it make more sense to suggest using a URN scheme or a URN pattern (`urn:ietf:params:http-problems` was proposed above) for registered type? the registry specifically is there for discovery, so we don't have to use HTTP URIs which create the risk of tooling accessing those URIs and creating unnecessary load.\r\nmy personal preference would be to go the URN way (scheme or pattern) and maybe add a section on discovery, which would then point out these alternatives: if you use custom types, you have to think about discovery. if you think about registering types, then discovery is taken care of by the registry, so using a non-dereferencable URI may be the better option to choose.",
          "createdAt": "2021-07-16T10:44:18Z",
          "updatedAt": "2021-07-16T10:44:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "@dret see discussion in #15.",
          "createdAt": "2021-07-19T05:26:25Z",
          "updatedAt": "2021-07-19T05:26:25Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "\nOn Jul 19, 2021, at 07:27, Mark Nottingham ***@***.***> wrote:\n> @dret see discussion in #15.\n> \n\nthanks for the pointer, i forgot about that one... i still think that using a URN is cleaner and more google friendly (seeing that automated dereferencing is not the goal here), but of course both options technically work. maybe this would be something useful to present as a choice to be made in the next meeting.",
          "createdAt": "2021-07-20T11:39:35Z",
          "updatedAt": "2021-07-20T11:39:35Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "just in case anybody is interested in a general discussion of why and how to use registries, here's something i wrote a while ago that discusses various aspects of the general pattern: https://datatracker.ietf.org/doc/html/draft-wilde-registries-03",
          "createdAt": "2021-07-21T08:30:53Z",
          "updatedAt": "2021-07-21T08:30:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 111: no strong feelings about URI scheme; a bit of preference for urn.",
          "createdAt": "2021-07-27T22:01:02Z",
          "updatedAt": "2021-07-29T07:25:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to go ahead and merge as is; we can address the URI scheme part as our thinking on that develops.",
          "createdAt": "2021-07-29T07:26:50Z",
          "updatedAt": "2021-07-29T07:26:50Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU3OTc3NTUzODQ=",
      "title": "Should JSON schema be used to describe Problem Details Object?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/8",
      "state": "CLOSED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "sdatspun2"
      ],
      "labels": [],
      "body": "Should JSON schema (https://json-schema.org/specification.html) be used to describe Problem Details Object?",
      "createdAt": "2021-01-31T16:48:56Z",
      "updatedAt": "2021-07-14T06:18:16Z",
      "closedAt": "2021-07-14T06:18:16Z",
      "comments": [
        {
          "author": "simonplend",
          "authorAssociation": "NONE",
          "body": "I think it would be very beneficial for an official JSON schema to be created for Problem Details objects. A couple of use cases immediately come to mind:\r\n\r\n- As documentation of the required shape of a Problem Details object\r\n- As something which APIs could validate their responses against before they are sent back to the client e.g. https://www.fastify.io/docs/latest/Validation-and-Serialization/#serialization",
          "createdAt": "2021-02-01T19:24:39Z",
          "updatedAt": "2021-02-01T19:24:39Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "The thing that makes this awkward is twofold:\n* All of the defined fields are optional\n* Arbitrary other fields can be added as needed\n\nSo the best that a schema can achieve is to define the types of the 5\ndefined fields - depending on other issues being discussed - but the client\nstill can't rely on the shape because of the above.\n\nOn Mon, 1 Feb 2021, 19:24 Simon Plenderleith, <notifications@github.com>\nwrote:\n\n> I think it would be very beneficial for an official JSON schema to be\n> created for Problem Details objects. A couple of use cases immediately come\n> to mind:\n>\n>    - As documentation of the required shape of a Problem Details object\n>    - As something which APIs could validate their responses against\n>    before they are sent back to the client e.g.\n>    https://www.fastify.io/docs/latest/Validation-and-Serialization/#serialization\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/8#issuecomment-771097841>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGGVPNIP3CU2RG5XX6DS435YPANCNFSM4W3QNADA>\n> .\n>\n",
          "createdAt": "2021-02-01T21:05:54Z",
          "updatedAt": "2021-02-01T21:05:54Z"
        },
        {
          "author": "simonplend",
          "authorAssociation": "NONE",
          "body": "> * All of the defined fields are optional\r\n\r\nThis is true, but what awkwardness do you feel this introduces?\r\n\r\n> * Arbitrary other fields can be added as needed\r\n\r\nJSON Schema allows you to effectively extend schemas (through use of the `allOf` and `$ref` keywords). This would allow users to define a schema which extends a base Problem Details JSON schema. User defined schemas would then be free to define any \"extension\" fields e.g.\r\n\r\n```json\r\n{\r\n  \"allOf\": [{ \"$ref\": \"https://example.com/schemas/problem-details-object.json\" }],\r\n  \"properties\": {\r\n    \"extension_field\": { \"type\": \"string\" }\r\n  }\r\n}\r\n```",
          "createdAt": "2021-02-01T21:47:08Z",
          "updatedAt": "2021-02-01T21:47:08Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "The \"awkwardness\" - and it was a bad choice of words :( - is that a generic\nJSON Schema for Problem Details will validate almost any object, whether\nit's actually a Problem Details or not. The *only* thing it would catch is\nif there are fields present matching the 5 standard names but with\nincompatible types. E.g. a response with a *status* field that was a string.\n\nThe ability to define your own schema for specific problem responses would\nbe a huge win, but then there needs to be some way for the client to know\nwhich schema to use. Presumably that would be the *Link* header with a rel\nof *described-by*, though having clients able to determine the correct\nschema based on the *type* field would also be fantastically useful - and\nwould then mean you can define that certain values for *type* automatically\nhave certain other required structure in the payload.\n",
          "createdAt": "2021-02-01T21:58:25Z",
          "updatedAt": "2021-02-01T21:58:25Z"
        },
        {
          "author": "simonplend",
          "authorAssociation": "NONE",
          "body": "> The \"awkwardness\" - and it was a bad choice of words :( - is that a generic JSON Schema for Problem Details will validate almost any object, whether it's actually a Problem Details or not. The *only* thing it would catch is if there are fields present matching the 5 standard names but with incompatible types. E.g. a response with a *status* field that was a string.\r\n\r\nThanks for clarifying - I understand what you mean now. Specifying `\"additionalProperties\": false` on the base schema wouldn't be possible as it would prevent any extension fields being added by a user defined schema which extends it. It would be down to the user defined schema to specify `\"additionalProperties\": false` - certainly not ideal.\r\n\r\n> The ability to define your own schema for specific problem responses would be a huge win, but then there needs to be some way for the client to know which schema to use. Presumably that would be the *Link* header with a rel of *described-by*, though having clients able to determine the correct schema based on the *type* field would also be fantastically useful - and would then mean you can define that certain values for *type* automatically have certain other required structure in the payload.\r\n\r\nThis is a really interesting use case. How are you imagining the client might use the schema for a specific problem response once it has retrieved it?",
          "createdAt": "2021-02-02T13:13:36Z",
          "updatedAt": "2021-02-02T13:13:36Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> This is a really interesting use case. How are you imagining the client might use the schema for a specific problem response once it has retrieved it?\r\n\r\nI'd not thought that far ahead :)\r\n\r\nHowever - to make up some potential uses :)\r\n\r\nAt the very least you could use it to ensure that the response payload was valid. If the schema says that a particular field is mandatory, you can expect it to always be there. Things like that. Potentially that can be used by languages like TypeScript to give better access to the payload values in a typesafe manner.\r\n\r\nPotentially though, it could also make use of things like `default` to reduce the payload size. The schema is likely incredibly cacheable, and any values that are unlikely to change can then be omitted from the actual Problem payload, the schema gives them default values, and the client still sees all of the correct values with less network traffic. Very useful if clients are on low bandwidth connections.",
          "createdAt": "2021-02-02T13:21:30Z",
          "updatedAt": "2021-02-02T13:21:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "WRT using schemas for (effectively) compression -- that feels like premature optimisation, and implies a _requirement_ to process the schema, which is going to orphan clients that don't want that burden.\r\n\r\nThat aside, I think adding a schema in an appendix makes sense. We should defer this until we discuss all the other changes, though.",
          "createdAt": "2021-02-10T01:31:53Z",
          "updatedAt": "2021-02-10T01:31:53Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "I don't see any problem at all with specifying a JSON Schema. It would be a simple, but useful, one. And being able to specify a profile for a Problem document also seems like a potentially useful feature. For example, it would allow servers to describe what each of the custom properties in the problem document means.\r\n\r\nWith respect to using defaults to omit keywords: The semantics of \"properties\" doesn't actually let you use \"default\" to fill in missing values. This is a [known issue](https://github.com/json-schema-org/json-schema-spec/issues/867).",
          "createdAt": "2021-02-18T05:46:05Z",
          "updatedAt": "2021-02-18T05:46:05Z"
        },
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "How would you handle the non-normative nature of the schema? Or are we talking about adding in appendices normative schemas? If yes, shoudl this apply to hydra/ld, rdfs over xml, xsd, json schema, where do we find that repository and what is the process of updating them if they are normative?",
          "createdAt": "2021-03-12T19:20:45Z",
          "updatedAt": "2021-03-12T19:20:45Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A JSON Schema, just like A JSON-LD Conext (see #10), must be non-normative, imho. They would be provided as a convenience to implementers to help adoption of the format and to avoid fragmentation.",
          "createdAt": "2021-03-15T11:07:23Z",
          "updatedAt": "2021-03-15T11:07:23Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Pl review https://github.com/ietf-wg-httpapi/rfc7807bis/pull/18.",
          "createdAt": "2021-04-23T14:13:28Z",
          "updatedAt": "2021-04-23T14:13:28Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU3OTc3NTY5NDY=",
      "title": "Should `instance` be deprecated? ",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/9",
      "state": "CLOSED",
      "author": "sdatspun2",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In order to solve the multiple problems use case #6, potential schema change for the Problem Details Object would include an array of problems. In cases where there is singular problem, one can respond with having a single entry in the array. In that case, should we deprecate `instance` member?\r\n\r\nIf we do deprecate, how should we handle the deprecation? Should we use the `Deprecation` response header field?",
      "createdAt": "2021-01-31T16:55:53Z",
      "updatedAt": "2021-02-10T02:43:22Z",
      "closedAt": "2021-02-10T02:43:22Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Most problems will still be single-instance, so the top-level `instance` alongside the other defined properties should be kept as is, imho. Since all properties are optional, they can be omitted if the default single-instance problem scenario doesn't fit the specific error situation.",
          "createdAt": "2021-02-01T08:12:46Z",
          "updatedAt": "2021-02-01T08:12:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed with @asbjornu. I think this issue is premature; let's figure out how to handle multiple problems first. @sdatspun2 do you mind if we close it, reopening if necessary later?",
          "createdAt": "2021-02-10T01:41:59Z",
          "updatedAt": "2021-02-10T01:41:59Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "NONE",
          "body": "@mnot I am ok to close now.",
          "createdAt": "2021-02-10T02:43:22Z",
          "updatedAt": "2021-02-10T02:43:22Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3OTgyMDkwMDg=",
      "title": "JSON-LD Context",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/10",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In HydraCG/Specifications#178 we have been working on making the response in the case of an API error compatible with RFC 7807. Since Hydra is based on JSON-LD, and RFC 7807 does not provide an official JSON-LD Context, we have had to define the term (property) `status` of RFC 7807 in the scope and namespace of Hydra.\r\n\r\nI believe the use of RFC 7807 and JSON-LD in combination is a Venn diagram with a larger overlap than the one provided by Hydra and thus believe the community would be best served if RFC 7807bis provided its own JSON-LD Context. [Hydra's JSON-LD Context for RFC 7807](https://github.com/HydraCG/Specifications/blob/master/spec/latest/core/error.jsonld) looks like the following:\r\n\r\n```json\r\n{\r\n  \"@context\": {\r\n    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\r\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\r\n    \"hydra\": \"http://www.w3.org/ns/hydra/core#\",\r\n    \"type\": { \"@id\": \"rdf:type\", \"@type\": \"@id\" },\r\n    \"title\": \"rdfs:label\",\r\n    \"detail\": \"rdfs:comment\",\r\n    \"status\": \"hydra:statusCode\",\r\n    \"instance\": { \"@id\": \"rdfs:seeAlso\", \"@type\": \"@id\" }\r\n  }\r\n}\r\n```",
      "createdAt": "2021-02-01T10:27:59Z",
      "updatedAt": "2022-07-17T00:07:10Z",
      "closedAt": "2022-06-16T01:40:25Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey @asbjornu,\r\n\r\nI'm not familiar with Hydra, but am usually pretty skeptical about LD.\r\n\r\nWhat would this require -- is this an on-the-wire change, or just an appendix to the spec?",
          "createdAt": "2021-02-02T00:18:33Z",
          "updatedAt": "2021-02-02T00:18:33Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An appendix would be fine. It just needs to be described somewhere and the `status` field needs to be mapped to a URI provided by RFC 7807bis. It would also be great if the JSON-LD Context document itself (i.e. `rfc7808bis.jsonld`) was made available somewhere publicly.",
          "createdAt": "2021-02-02T00:36:09Z",
          "updatedAt": "2021-02-02T00:37:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ack. I think we should leave this towards the end of the process, after any other changes are incorporated. ",
          "createdAt": "2021-02-10T01:42:32Z",
          "updatedAt": "2021-02-10T01:42:32Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "for the \"the status field needs to be mapped to a URI provided by RFC 7807bis\" part, @asbjornu, would `urn:ietf:rfc:xxxx` according to https://datatracker.ietf.org/doc/html/rfc2648 work?",
          "createdAt": "2021-05-31T14:30:57Z",
          "updatedAt": "2021-05-31T14:30:57Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It could, @dret. But I think it would give a better developer experience if the URI was dereferenceable, and when dereferenced, provided information about what it represented with relevant pointer(s) to RFC 7808bis. Something similar to the [Atom namespace URI](https://www.w3.org/2005/Atom).",
          "createdAt": "2021-05-31T14:41:04Z",
          "updatedAt": "2021-05-31T14:41:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That may be tricky - is it important?",
          "createdAt": "2021-07-14T06:21:18Z",
          "updatedAt": "2021-07-14T06:21:18Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The dereferenceability?",
          "createdAt": "2021-07-14T07:07:58Z",
          "updatedAt": "2021-07-14T07:07:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes. We might be able to get on on ietf.org, but there's no process for doing so AIUI.",
          "createdAt": "2021-07-14T07:24:56Z",
          "updatedAt": "2021-07-14T07:24:56Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not crucial, but I do think dereferenceability provides a measurable improvement in the developer experience.",
          "createdAt": "2021-07-14T08:25:14Z",
          "updatedAt": "2021-07-14T08:25:14Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "just for reference, for linkset we had the same request of providing an \nJSON-LD context. we decided to keep the spec a JSON spec and not go out \non a limb and mandate an RDF model. but we did listen to the input \nregarding the JSON design (we have no options for this here) and decided \nto create an appendix with an informational context:\n\nhttps://datatracker.ietf.org/doc/html/draft-ietf-httpapi-linkset#appendix-A\n",
          "createdAt": "2021-07-15T19:23:55Z",
          "updatedAt": "2021-07-15T19:23:55Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "This topic has just come up on httpapis.slack.com.\r\n\r\nOne other benefit of adding a JSON-LD context - which may or may not have already been mentioned, apologies if it has! - is that it means that all non-core properties can be defined in their own namespace and never clash with the core ones. That means adding new core properties is suddenly *not* a breaking change.\r\n\r\nFor example:\r\n```\r\n{\r\n\t\"@context\": [\r\n\t\t\"http://www.w3.org/ns/hydra/error\",\r\n\t\t{\r\n\t\t\t\"balance\": \"http://example.com/problem/balance\",\r\n\t\t\t\"accounts\": \"http://example.com/problem/accounts\"\r\n\t\t}\r\n\t],\r\n\t\"type\": \"https://example.com/probs/out-of-credit\",\r\n\t\"title\": \"You do not have enough credit.\",\r\n\t\"detail\": \"Your current balance is 30, but that costs 50.\",\r\n\t\"instance\": \"/account/12345/msgs/abc\",\r\n\t\"balance\": 30,\r\n\t\"accounts\": [\"/account/12345\",\r\n\t\t\"/account/67890\"\r\n\t]\r\n}\r\n```\r\n\r\nMeans that the `balance` and `accounts` keys are defined in a different namespace to the others. Accordingly, if the core spec ever added `accounts` as a key (for some reason) then it's *different* to the one in this document and thus doesn't collide.\r\n\r\nIt also means that the core names are able to be used in a non-core namespace without collision. Eg I might want a `status` property that is *not* the RFC7807 status property.",
          "createdAt": "2021-09-28T15:59:13Z",
          "updatedAt": "2021-09-28T15:59:13Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-09-28 17:59, Graham Cox wrote:\n> One other benefit of adding a JSON-LD context - which may or may not \n> have already been mentioned, apologies if it has! - is that it means \n> that all non-core properties can be defined in their own namespace and \n> never clash with the core ones. That means adding new core properties is \n> suddenly /not/ a breaking change.\n> It also means that the core names are able to be used in a non-core \n> namespace without collision. Eg I might want a |status| property that is \n> /not/ the RFC7807 status property.\n\nthat's only true for the mapped model, but it's not true for the JSON \nmodel defined by RFC 7807. this means we will have to stick with the way \nhow it works.\n",
          "createdAt": "2021-09-28T16:06:22Z",
          "updatedAt": "2021-09-28T16:06:22Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we rewrite @sazzer's example a bit, it should be more compatible with non-JSON-LD-capable clients by explicitly adding a namespace prefix:\r\n\r\n```json\r\n{\r\n    \"@context\": [\r\n        \"http://www.w3.org/ns/hydra/error\",\r\n        { \"ex\": \"http://example.com/problem#\" }\r\n    ],\r\n    \"type\": \"https://example.com/probs/out-of-credit\",\r\n    \"title\": \"You do not have enough credit.\",\r\n    \"detail\": \"Your current balance is 30, but that costs 50.\",\r\n    \"instance\": \"/account/12345/msgs/abc\",\r\n    \"ex:balance\": 30,\r\n    \"ex:accounts\": [\r\n        \"/account/12345\",\r\n        \"/account/67890\"\r\n    ],\r\n    \"ex:status\": \"Married, with children\"\r\n}\r\n```",
          "createdAt": "2021-09-28T21:05:10Z",
          "updatedAt": "2021-09-28T21:06:12Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "I wonder if it's just some wording like: (but written by someone better at this than me!)\r\n\r\n> Any additional properties may conflict with properties added in future versions of the specification. This can be avoided by using globally unique property names such as URIs, or by using a JSON-LD context to ensure mapped properties are unique.",
          "createdAt": "2021-09-29T13:57:42Z",
          "updatedAt": "2021-09-29T13:57:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Any additional properties may conflict with properties added in future versions of the specification. This can be avoided by using globally unique property names such as URIs, or by using a JSON-LD context to ensure mapped properties are unique.\r\n\r\nThat's a pretty big change from the current approach of the spec, which is that additional properties are 'owned' by the type in question, not future versions of the spec. It would require significant changes in already deployed uses, to assure they don't conflict with future extensions.\r\n\r\nAt most, I think we could add a statement that future type-specific properties SHOULD follow some particular pattern to avoid clashes with potential future standard-added properties -- e.g., they should contain a ':', which standard properties presumably never will.\r\n\r\nIf we go down that path, we should still have a transition period (likely a few years) before we actually define any new standard properties, IMO.",
          "createdAt": "2021-10-11T00:08:32Z",
          "updatedAt": "2021-10-11T00:08:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also, @asbjornu your example makes me think I don't understand the proposal yet, because it **looks** like an on-the-wire change is required -- the addition of a `@context` member. Is that the case?",
          "createdAt": "2021-10-11T00:16:38Z",
          "updatedAt": "2021-10-11T00:16:38Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-11 02:16, Mark Nottingham wrote:\n> Also, @asbjornu <https://github.com/asbjornu> your example makes me \n> think I don't understand the proposal yet, because it *looks* like an \n> on-the-wire change is required -- the addition of a ***@***.***| member. \n> Is that the case?\n\ni am curious about this one as well. it used to be the case that JSON-LD \ndid not support \"implicit\" contexts, i.e. you always needed to \nexplicitly reference the context within the JSON structure.\n\ni think i can vaguely remember that there were ideas or plans to change \nthat, but i don't know what happened since then.\n",
          "createdAt": "2021-10-11T07:00:55Z",
          "updatedAt": "2021-10-11T07:00:55Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "JSON-LD has had this from early days that a context can be referenced using [LINK header](https://www.w3.org/TR/json-ld/#interpreting-json-as-json-ld)\r\n\r\nA published using the `ex:` extension would have to link to their own context resource",
          "createdAt": "2021-10-11T07:57:37Z",
          "updatedAt": "2021-10-11T07:57:37Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, as @tpluscode writes, `@context` can be removed from the body and smashed into a `Link` header instead. As long as the linked JSON-LD context provides a mapping for the [compact IRI prefixes](https://www.w3.org/TR/json-ld/#dfn-compact-iri) used in the JSON body (in the example being `ex:`), it should be processable as JSON-LD (and by extension, RDF).",
          "createdAt": "2021-10-11T16:28:29Z",
          "updatedAt": "2021-10-11T16:28:29Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-11 02:08, Mark Nottingham wrote:\n> At most, I think we could add a statement that future type-specific \n> properties SHOULD follow some particular pattern to avoid clashes with \n> potential future standard-added properties -- e.g., they should contain \n> a ':', which standard properties presumably never will.\n\noh look, \"x-\" is back in business again! ;-)\n",
          "createdAt": "2021-10-12T14:37:37Z",
          "updatedAt": "2021-10-12T14:37:37Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While a jsonld context can be useful, I think that the payload should not be impacted  (eg avoid stuff like `ex:balance` ...).\r\nFor example `@vocab` could be used to reference an URL where retrieving all the definitions, including the `problem` ones.\r\n\r\n",
          "createdAt": "2022-02-14T17:40:03Z",
          "updatedAt": "2022-02-14T17:40:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@asbjornu what exactly do you want to see in the spec -- could you do a PR by any chance?",
          "createdAt": "2022-03-24T03:23:03Z",
          "updatedAt": "2022-03-24T03:23:03Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot, what I would like to see in the spec depends on whether we are able to host the `problem.jsonld` document containing the JSON-LD Context somewhere dereferenceable. Are we? If we are, what would its full URI be?",
          "createdAt": "2022-03-27T20:11:50Z",
          "updatedAt": "2022-03-27T20:11:50Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-03-27 22:12, Asbj\u00f8rn Ulsberg wrote:\n> @mnot <https://github.com/mnot>, what I would like to see in the spec \n> depends on whether we are able to host the |problem.jsonld| document \n> containing the JSON-LD Context somewhere dereferenceable. Are we? If we \n> are, what would its full URI be?\n\nthat sounds like another \"HTML DTD\" drama in the making. is there any \nprecedent where IETF hosts files that will be accessed at runtime by all \napplications using the spec?\n",
          "createdAt": "2022-03-27T20:30:41Z",
          "updatedAt": "2022-03-27T20:30:41Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "I think I agree with @dret's sentiment here. Would probably show how such a document should look like and suggest that API publishers could reuse an existing context, or publish it themselves, if they so choose. The latter would be required if defining any additional mappings would be required\r\n\r\nFor example, hydra now has one dereferencable from http://www.w3.org/ns/hydra/error",
          "createdAt": "2022-03-27T20:35:44Z",
          "updatedAt": "2022-03-27T20:35:44Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": " I'm not a hydra expert by any means, but if different APIs host their own\ncopy of the .jsonld file then it will have a different absolute URL. Does\nthat mean that identical documents served from different APIs will parse\ndifferently because of those different URLs?\n\nCheers\n-- \nGraham Cox\n\nOn Sun, 27 Mar 2022, 21:35 Tomasz Pluskiewicz, ***@***.***>\nwrote:\n\n> I think I agree with @dret <https://github.com/dret>'s sentiment here.\n> Would probably show how such a document should look like and suggest that\n> API publishers could reuse an existing context, or publish it themselves,\n> if they so choose. The latter would be required if defining any additional\n> mappings would be required\n>\n> For example, hydra now has one dereferencable from\n> http://www.w3.org/ns/hydra/error\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/10#issuecomment-1080014154>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGC6SQ3CCW64ZUBIXLDVCDIDVANCNFSM4W4RALRA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2022-03-27T22:14:45Z",
          "updatedAt": "2022-03-27T22:14:45Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "It would be true if the JSON-LD would have a `@base`. Clearly not what one should do in the case of a shared context.\r\n\r\nOtherwise no, the sole fact that a context is delivered from a remote location does not have bearing on resolving relative URIs",
          "createdAt": "2022-03-28T07:56:30Z",
          "updatedAt": "2022-03-28T07:57:36Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's two different URIs being discussed here.\r\n\r\n### Vocabulary URI\r\nThe Vocabulary URI is the base URI for the shared vocabulary containing the terms defined in rfc7807bis, sort of like an XML namespace URI. There's a clear benefit from all RDF consumers of `problem+json` to use the same base URI for the terms defined within the JSON-LD context, binding them all to the same, shared vocabulary. The most common such shared vocabulary base URI is [`http://schema.org/`](https://schema.org/).\r\n\r\nThe Vocabulary URI can be dereferenceable, but doesn't have to be. If this URI is made dereferenceable, it should serve human-readable documentation such as that of the [Atom namespace URI](https://www.w3.org/2005/Atom). The dereferenceability of namespace URIs are not problematic or comparable to the HTML DTD debacle, afaik. They just provide better developer experience than a non-dereferenceable URI.\r\n\r\nIf we are able to mint this URI like we were able to mint the Atom namespace URI, it could be something like `https://www.w3.org/ns/Problem#`. This in turn gives the `status` term the absolute URI `https://www.w3.org/ns/Problem#status`, which is what makes it sharable across different RDF implementations.\r\n\r\n### Context URI\r\nThe Context URI is the URI pointing to a JSON-LD Context document containing the definition for each of the terms defined in rfc7808bis. If made available, this URI must be dereferenceable, but should bear no meaning on the processing of the `problem+json` document as the terms should be resolved to the Vocabulary URI. If a Context URI is made available (and dereferenceable), it should respond with something like this:\r\n\r\n```http\r\n200 OK\r\nContent-Type: application/ld+json\r\nContent-Length: 373\r\n\r\n{\r\n  \"@context\": {\r\n    \"@vocab\": \"https://www.w3.org/ns/Problem#\",\r\n    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\r\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\r\n    \"type\": { \"@id\": \"rdf:type\", \"@type\": \"@id\" },\r\n    \"title\": \"rdfs:label\",\r\n    \"detail\": \"rdfs:comment\",\r\n    \"status\": \"status\",\r\n    \"instance\": { \"@id\": \"rdfs:seeAlso\", \"@type\": \"@id\" }\r\n  }\r\n}\r\n```\r\n\r\nIf we are able to host this document, it could be something like `https://www.w3.org/ns/Problem/context.jsonld`. This URI can indeed lead to the same issues as the HTML DTD described by @dret, although I doubt this URI gaining the same popularity and widespread usage as that of the HTML DTD. This URI can then be used with `problem+json` responses as such:\r\n\r\n```http\r\n200 OK\r\nContent-Type: application/problem+json\r\nContent-Length: 273\r\nLink: <https://www.w3.org/ns/Problem/context.jsonld>; rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\r\n\r\n{\r\n  \"type\": \"https://example.com/probs/out-of-credit\",\r\n  \"title\": \"You do not have enough credit.\",\r\n  \"detail\": \"Your current balance is 30, but that costs 50.\",\r\n  \"instance\": \"/account/12345/msgs/abc\",\r\n  \"balance\": 30,\r\n  \"accounts\": [\"/account/12345\", \"/account/67890\"]\r\n}\r\n```\r\n\r\n> For example, hydra now has one dereferencable from http://www.w3.org/ns/hydra/error\r\n\r\n@tpluscode, do you mean that this will become dereferenceable once Hydra reaches W3-REC status? Because it doesn't resolve to anything useful currently.",
          "createdAt": "2022-03-28T13:52:08Z",
          "updatedAt": "2022-03-28T15:00:48Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "@asbjornu no, it should totally work and it did not long ago indeed. Will fix asap",
          "createdAt": "2022-03-28T14:45:11Z",
          "updatedAt": "2022-03-28T14:45:11Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "Here's the source which should be served: https://github.com/HydraCG/Specifications/blob/master/spec/latest/core/error.jsonld",
          "createdAt": "2022-03-28T14:46:01Z",
          "updatedAt": "2022-03-28T14:46:01Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we are already able to serve the JSON-LD Context document from W3C under the Hydra namespace, minting a non-Hydra namespace to serve the same document should be no problem, should it?",
          "createdAt": "2022-03-28T14:58:07Z",
          "updatedAt": "2022-03-28T14:58:07Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "Ok, it's live again. And should stay that way :)",
          "createdAt": "2022-03-30T08:06:24Z",
          "updatedAt": "2022-03-30T08:06:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think we're going to be able to publish an RFC with a URL pointing to GitHub; while that's OK for things like a registry entry, the RFC Editor will balk at doing this.\r\n\r\nPopping up a level -- what's the reason this needs to be in the RFC?",
          "createdAt": "2022-05-11T01:21:22Z",
          "updatedAt": "2022-05-11T01:21:22Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think we're going to be able to publish an RFC with a URL pointing to GitHub; while that's OK for things like a registry entry, the RFC Editor will balk at doing this.\r\n\r\nYeah, that makes sense.\r\n\r\n> Popping up a level -- what's the reason this needs to be in the RFC?\r\n\r\nWhich \"this\" are you referring to? \ud83d\ude04 The vocabulary or the context?\r\n\r\nIf we are able to pull some strings in W3C to have them host a vocabulary URI such as `https://www.w3.org/ns/Problem`, it would be great to have that in the RFC so we have a shared and canonical vocabulary URI that every JSON-LD consumer of rfc7807bis can refer to.\r\n\r\nWhen it comes to the context URI, I'm not sure what we should do, but we may perhaps just provide a sample context in a non-normative section of the RFC and leave it up to consumers to host it themselves. The most important bit is to not cause fragmentation of the vocabulary URI by having every consumer mint their own.",
          "createdAt": "2022-05-12T21:26:31Z",
          "updatedAt": "2022-05-12T21:26:31Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": "You talk of the error context document?\n\nFWIW it is http://www.w3.org/ns/hydra/error and not GitHub. It's not even a redirect but a rewrite.\n\nI mentioned it because the real one was down",
          "createdAt": "2022-05-13T04:32:34Z",
          "updatedAt": "2022-05-13T04:32:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Trying again. What is the actual text that you'd like to see in the RFC?\r\n\r\nIs it enough to add a short, non-normative appendix that looks like this?\r\n\r\n## JSON-LD \r\n\r\nThe JSON LD [ref] context for Problem Details can be found at <http://www.w3.org/ns/hydra/error>.",
          "createdAt": "2022-05-15T07:15:30Z",
          "updatedAt": "2022-05-15T07:15:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This issue is now the last open issue on this specification -- if there aren't any concrete proposals for text, I'm inclined to close it with no action.",
          "createdAt": "2022-05-25T07:09:33Z",
          "updatedAt": "2022-05-25T07:09:33Z"
        },
        {
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "body": ":pensive:",
          "createdAt": "2022-06-16T04:44:56Z",
          "updatedAt": "2022-06-16T04:44:56Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for being awol, but I\u2019m on parental leave with a daughter that barely sleeps so I don\u2019t have much time on my hands until August. I would be happy to review a PR trying to solve this or I will try to find time during the next days to write something myself. Can you please reopen, @mnot?",
          "createdAt": "2022-06-16T08:49:49Z",
          "updatedAt": "2022-06-16T08:49:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The document is in Working Group Last Call, which is a two-week window. Write up a PR?",
          "createdAt": "2022-06-18T02:46:40Z",
          "updatedAt": "2022-06-18T02:46:40Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hope to be able to dedicate some time to write a PR for this next week.",
          "createdAt": "2022-07-01T17:03:42Z",
          "updatedAt": "2022-07-01T17:03:42Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sorry time hasn't allowed me to spend any time on this or any other spare time projects lately. I suppose it's now too late to do anything about this, @mnot?",
          "createdAt": "2022-07-14T22:24:05Z",
          "updatedAt": "2022-07-14T22:24:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "\"Too late\" might be a _bit_ too strong, but it's going to be increasingly hard to make a change as the document progresses. I you want to make a proposal you should probably clear it with the chairs first.",
          "createdAt": "2022-07-17T00:07:10Z",
          "updatedAt": "2022-07-17T00:07:10Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3OTkyMjY0Mjk=",
      "title": "Should 'type' definitely be required to be a URI?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/11",
      "state": "CLOSED",
      "author": "pimterry",
      "authorAssociation": "NONE",
      "assignees": [
        "dret"
      ],
      "labels": [],
      "body": "In @dret's Twitter [feedback thread](https://twitter.com/dret/status/1355075053088608258), this was the only and much-repeated comment. I'll copy some of the posts from there in here:\r\n\r\nhttps://twitter.com/vasilakisfil/status/1355083598777511937:\r\n> the type should not required to be a URI reference, this is a killer for most ordinary developers\r\n> ...\r\n> Having worked closed with such developers I understand why. Not everyone is so API savvy. It isn't very intuitive for devs not working on hateoas and APIs, so they drop the whole spec completely making things worse. Making it a requirement, has the opposite effects.\r\n\r\nhttps://twitter.com/pimterry/status/1355112881646399491 (me):\r\n> +1, I've seen confusion here, it's counter-intuitive.\r\n> Seems odd to use the id as the implicit link to the docs too: what if I want two errors to be distinguishable but both reference the same docs?\r\n> An arbitrary string with a _suggestion_ that it be a URI would be better imo.\r\n> Oh, and what if I want to change the URLs for my error docs? If 'type' links to them, as encouraged, I either have to change the type identifiers for all my errors or have point them at the old URLs forever.\r\n\r\nhttps://twitter.com/Riussi/status/1355091136868737024:\r\n> I concur. We've just started using RFC 7807 and defining those would be easier if it is not mandated as a URI\r\n\r\nhttps://twitter.com/simonplend/status/1355087138497282048:\r\n> I've also found that folks find this really confusing. \"What is this URL for?\"\r\n\r\nThis confusion is also repeated frequently elsewhere, e.g. it's the top complaint in unrelated [reddit discussion](https://www.reddit.com/r/api/comments/hze1i2/do_you_folks_use_rfc_7807_problem_details_in_http/) of the standard. Meanwhile https://jonathancrozier.com/blog/base-your-api-error-response-model-on-a-solid-standard-with-the-problem-details-rfc (on the first page of results for \"problem details standard\") says:\r\n\r\n> For example, let\u2019s consider the type property. For most of the projects I am working on, it isn\u2019t practical to have a webpage dedicated to each type of possible error. Given that the standard specifically states that the value is assumed to be \"about:blank\" if it is not present, I usually leave this member out.\r\n\r\nArguably `type` is the most useful field in the standard, so this is not a good result.\r\n\r\nI think it'd be useful to discuss this, at least to document the reasoning here more clearly, and to consider alternative approaches and/or alternative ways to make type URIs easier for devs.",
      "createdAt": "2021-02-02T12:13:16Z",
      "updatedAt": "2021-05-25T06:56:46Z",
      "closedAt": "2021-05-25T06:56:46Z",
      "comments": [
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "I'll add a separate comment, from my personal point of view:\r\n\r\n* As far as I understand, the goal is to encourage namespacing of error types, is that right? Are there other benefits that the URI provides?\r\n* Imo, it's quite unusual as a web API response - it reminds me of a more rigorous XML-style API design with careful namespacing of all identifiers, rather than the less rigorous JSON formats that are now more common. It feels inconsistent with other HTTP standards too, e.g. link relation types do not use URIs as type identifiers.\r\n* Similarly, while API developers will be familiar with HTTP URLs, a great many (I believe) are not familiar with the URIs more generally and the other formats available (e.g. Erik [mentioned](https://twitter.com/dret/status/1355114738796138497) tag URIs - I'd like to think I'm reasonably interested in the standards and tools available, and I'd never even heard of these!).\r\n* Recommending that unique id for an error type to be a documentation URL is problematic, because documentation URLs may well change and unique ids must not (yes, old documentation URLs _should_ redirect to new ones, but there's not always a 1-1 mapping of URLs, it's messy to keep using the incorrect URL/domains in this field, and we all know this isn't always true/possible anyway).\r\n* Having a separate optional documentation URL instead would be more useful imo. Right now, it's not guaranteed that a type URL is dereferenceable, so applications must effectively treat it as never dereferenceable. A separate field (or indeed link relation) would be defined as such, making it usable in many more cases.\r\n* Making it an opaque string instead would still allow for the use of URIs for namespacing if desired, and we could still _recommend_ that users do that without necessarily requiring that.",
          "createdAt": "2021-02-02T12:25:33Z",
          "updatedAt": "2021-02-02T12:25:33Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are there other benefits that the URI provides?\r\n\r\nURIs can be dereferenceable. That's a pretty significant feature.\r\n\r\n> Recommending that unique id for an error type to be a documentation URL is problematic, because documentation URLs may well change and unique ids must not\r\n\r\nPerhaps the RFC can mention the possibility to use HTTP's features to make URIs stable, such as using stable API URLs in `type` that perform HTTP redirects towards the (ever changing) documentation.\r\n\r\n> Having a separate optional documentation URL instead would be more useful imo. \r\n\r\nI think that's a horrible suggestion. Big \ud83d\udc4e\ud83c\udffc .\r\n\r\n> Making it an opaque string instead would still allow for the use of URIs for namespacing if desired\r\n\r\nOpaque strings are already allowed. I don't really understand the problem here. The last paragraph of [RFC 7807 section 3.1](https://tools.ietf.org/html/rfc7807#section-3.1) states the following:\r\n\r\n>  Note that both \"type\" and \"instance\" accept relative URIs; this means that they must be resolved relative to the document's base URI, as per [[RFC3986], Section 5](https://tools.ietf.org/html/rfc3986#section-5).\r\n\r\nThis means `\"type\": \"i-hate-uris\"` is perfectly valid.",
          "createdAt": "2021-02-02T12:38:30Z",
          "updatedAt": "2021-02-02T12:38:30Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "The type field currently has to be a URI Reference. This means it can either be a URI or a relative-ref. This in turn means that you can use almost any bare string in there and still be following the letter of the RFC, even if not the intention.\r\n\r\nI've seen examples of exactly that - with values for `type` that are actually just error codes because, strictly speaking, they are legal relative URIs that just don't happen to resolve to anything.\r\n\r\nPersonally, I've no major problem with that, except that it makes it much more likely to get collisions across APIs - with two different APIs using the same type \"URI\" to mean different things.\r\n\r\nI can imagine there are some big benefits to be obtained if the URI *is* dereferenceable though. Things like getting human-readable documentation from it, or a JSON Schema that describes the shape of the problem details. Dereferencing an `instance` URI might take you directly to the log messages for what went wrong (for internal APIs only!)\r\n\r\nBut equally, saying that these *must* be dereferenceable is potentially quite a big hurdle for many smaller developers that would potentially either stop them using this or else just have them ignore the difficult bits.",
          "createdAt": "2021-02-02T12:48:12Z",
          "updatedAt": "2021-02-02T12:48:12Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> URIs can be dereferenceable. That's a pretty significant feature.\r\n\r\nCurrently, `type` is _not_ dereferenceable though, explicitly. The RFC says \"Consumers SHOULD NOT automatically dereference the type URI\", and has no mechanism to know when it could be dereferenceable. In effect, it's manually dereferenceable only.\r\n\r\nImo it would be more useful there was such a mechanism, or indeed a separate always-dereferenceable URL elsewhere.\r\n\r\n> I think that's a horrible suggestion. Big \ud83d\udc4e\ud83c\udffc .\r\n\r\nCould you be more specific about why?\r\n\r\n> This means \"type\": \"i-hate-uris\" is perfectly valid.\r\n\r\nI see - that's not communicated at all right now! If that's intended, I think it would be useful to communicate that better in the spec. Currently every single example in the spec is an absolute HTTP URL, all discussion of the standard elsewhere does the same, and I think the comments above clearly show that other options aren't widely recognized.\r\n\r\nIllustrating that a classic error code string is allowed but a full URL is encouraged would resolve quite a few of the concerns there I think.",
          "createdAt": "2021-02-02T12:48:46Z",
          "updatedAt": "2021-02-02T12:48:46Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "Race condition posting there, sorry - to reply to @sazzer:\r\n\r\n> I've seen examples of exactly that - with values for type that are actually just error codes because, strictly speaking, they are legal relative URIs that just don't happen to resolve to anything.\r\n\r\nOk, I think this agrees with @asbjornu's point, and this is likely a communication issue rather than a change to the format itself them.\r\n\r\n> I can imagine there are some big benefits to be obtained if the URI is dereferenceable though. \r\n\r\n> saying that these must be dereferenceable is potentially quite a big hurdle for many smaller developers\r\n\r\nAgree, I'd love to have a documented way to know when that's possible. Making it possible to include a dereferenceable URL explicitly but optionally would be a big help.",
          "createdAt": "2021-02-02T12:53:00Z",
          "updatedAt": "2021-02-02T12:53:00Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": ">     This means \"type\": \"i-hate-uris\" is perfectly valid.\n> \n> I see - that's not communicated at all right now! If that's intended, I \n> think it would be useful to communicate that better in the spec. \n> Currently every single example in the spec is an absolute HTTP URL, all \n> discussion of the standard elsewhere does the same, and I think the \n> comments above clearly show that other options aren't widely recognized.\n\nthat wouldn't be great as a pattern to recommend. the actual error URI \nin this case is the relative URI resolved against the URI of the context \n(in this case, the resource that returned the error). so while this is \ntechnically legal, it's pretty bad in terms of utility when it comes to \nimplementations properly handling the type values as URIs.\n\n-- \nerik wilde | mailto:erik.wilde@dret.net |\n            | http://dret.net/netdret    |\n            | http://twitter.com/dret    |\n",
          "createdAt": "2021-02-02T12:58:12Z",
          "updatedAt": "2021-02-02T12:58:12Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> Race condition posting there, sorry - to reply to @sazzer:\r\n\r\nYeah, we both posted the same thing at the same time :) And yes, I think we are both saying the exact same thing.\r\n\r\nEdit - looking at timestamps it wasn't the exact same time. Just my window hadn't updated at the time!\r\n\r\n> Currently, `type` is _not_ dereferenceable though, explicitly. The RFC says \"Consumers SHOULD NOT automatically dereference the type URI\", and has no mechanism to know when it could be dereferenceable. In effect, it's manually dereferenceable only.\r\n\r\nMaybe I'm wrong, but I've always read that with the emphasis on \"automatically\". As in - dereference only when needed and not always. And I've read it like that because some scenarios that would cause errors to be returned would also mean that the URI that is the problem type would also fail to resolve, and potentially cause more problems for the service (DoS attack or similar.) Equally, especially for `type`, it could be that the intention is for *humans* to dereference it and not computers. For example, I've started using type values similar to `https://httpstatuses.com/404` for cases where the status code alone tells you everything, but I still want to include a Problem response.\r\n\r\nThere's also a problem that not all clients are capable of dereferencing all URIs. For example, if it's an \"http\" scheme then you need to be able to make HTTP requests to the target server. Not all clients can do that, especially if they are on a closed network.",
          "createdAt": "2021-02-02T12:58:51Z",
          "updatedAt": "2021-02-02T12:59:44Z"
        },
        {
          "author": "simonplend",
          "authorAssociation": "NONE",
          "body": ">>> This means \"type\": \"i-hate-uris\" is perfectly valid.\r\n>>>\r\n>> I see - that's not communicated at all right now! If that's intended, I think it would be useful to communicate that better in the spec. Currently every single example in the spec is an absolute HTTP URL, all discussion of the standard elsewhere does the same, and I think the comments above clearly show that other options aren't widely recognized.\r\n>>\r\n> that wouldn't be great as a pattern to recommend. the actual error URI\r\n> in this case is the relative URI resolved against the URI of the context\r\n> (in this case, the resource that returned the error). so while this is\r\n> technically legal, it's pretty bad in terms of utility when it comes to\r\nimplementations properly handling the type values as URIs.\r\n\r\n@dret Would it be reasonable then to also include examples of `type` URIs which are not URLs? e.g. [tag URIs](https://tools.ietf.org/html/rfc4151) as you suggested on Twitter.",
          "createdAt": "2021-02-02T13:07:04Z",
          "updatedAt": "2021-02-02T13:07:04Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-02-02 14:07, Simon Plenderleith wrote:\n> @dret <https://github.com/dret> Would it be reasonable then to also \n> include examples of |type| URIs which are not URLs? e.g. tag URIs \n> <https://tools.ietf.org/html/rfc4151> as you suggested on Twitter.\n\ni think what we have clearly established is that if 'type' remains to be \ndefined as a URI, better guidance would be a good idea.\n",
          "createdAt": "2021-02-02T13:22:05Z",
          "updatedAt": "2021-02-02T13:22:05Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Currently, `type` is _not_ dereferenceable though, explicitly. The RFC says \"Consumers SHOULD NOT automatically dereference the type URI\", and has no mechanism to know when it could be dereferenceable. In effect, it's manually dereferenceable only.\r\n\r\n`SHOULD NOT automatically` just means there should not be **automatic** dereferencing. Non-automatic dereferencing such as making the URI a user-clickable link, or a developer copying and pasting it into a browser, is perfectly valid, though. That should perhaps be made more explicit.\r\n\r\n> > I think that's a horrible suggestion. Big \ud83d\udc4e\ud83c\udffc .\r\n> \r\n> Could you be more specific about why?\r\n\r\n`type` works perfectly well for documentation. Decoupling the problem type from the problem type's documentation when the former can redirect to the latter just adds confusion, possible inconsistencies, and errors, imho.\r\n\r\n> > This means \"type\": \"i-hate-uris\" is perfectly valid.\r\n> \r\n> I see - that's not communicated at all right now!\r\n\r\nBut it is. As I wrote above, the last paragraph of [RFC 7807 section 3.1](https://tools.ietf.org/html/rfc7807#section-3.1) states the following:\r\n\r\n> Note that both \"type\" and \"instance\" accept relative URIs; this means that they must be resolved relative to the document's base URI, as per [[RFC3986], Section 5](https://tools.ietf.org/html/rfc3986#section-5).\r\n\r\n\u2026\r\n\r\n> If that's intended, I think it would be useful to communicate that better in the spec.\r\n\r\nI agree that can be emphasized closer to the definition of `type` and not just as a seemingly unrelated paragraph. A way to accomplish this would be to promote each member in section 3.1 to its own section so the spec can use more than one paragraph to describe each member.\r\n\r\n> Currently every single example in the spec is an absolute HTTP URL.\r\n\r\nExamples are non-normative. To understand the spec, you have to read the normative text. An example containing `type` with a relative URI would be a good addition, though.\r\n\r\n> all discussion of the standard elsewhere does the same, and I think the comments above clearly show that other options aren't widely recognized.\r\n\r\nAgreed.\r\n\r\n> Would it be reasonable then to also include examples of `type` URIs which are not URLs? e.g. [tag URIs](https://tools.ietf.org/html/rfc4151) as you suggested on Twitter.\r\n\r\nI think `tag` URIs sounds like a bad fit for `type` as they are more of a human readable alternative to UUID.",
          "createdAt": "2021-02-02T13:23:08Z",
          "updatedAt": "2021-02-02T13:23:08Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> the actual error URI in this case is the relative URI resolved against the URI of the context (in this case, the resource that returned the error).\r\n\r\nHmm, yes, so `\"type\": \"my-custom-error\"` is actually quite very bad. Doing so is most likely a mistake: if a developer returns `\"type\": \"my-custom-error\"` as an error type from two different resources, clients must treat those as distinct types, relative to different base URLs. That's quite surprising! This is probably not what the dev intended, and code that does treat them as equivalent automatically is not following the spec.\r\n\r\nIt looks like this is a real problem: even the most popular [problem details implementation](https://github.com/zalando/problem) makes this mistake. It matches problem detail classes automatically by comparing the `type` value, and never uses a base URL or relative resolution for type values anywhere. I suspect that it's not alone in this, and that using bare strings as global error types will work in many places, incorrectly.\r\n\r\n> Would it be reasonable then to also include examples of type URIs which are not URLs? e.g. tag URIs\r\n\r\nImo, tag URIs are a good improvement, but they're still not great. The most convenient equivalent tag we'd be suggesting is probably `tag:example.com,2021:my-error`. It's obvious that it isn't dereferenceable, which is good, but it's still an unusual error code format.\r\n\r\nThere's clearly friction with URIs error codes right now, and widespread patterns of _not_ using URIs for error identifiers in every existing API I can find (e.g. [Stripe](https://stripe.com/docs/error-codes), [AWS](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html#ErrorCodeList), [Azure](https://docs.microsoft.com/en-us/rest/api/storageservices/common-rest-api-error-codes)). Instead, they all use opaque string identifiers decoupled from documentation URLs.\r\n\r\nFrom my perspective and I think from the feedback above, it would be useful to have a standard that supported existing common error API patterns. This doesn't preclude namespacing where that's useful, it just doesn't enforce it.\r\n\r\n> I've always read that with the emphasis on \"automatically\". As in - dereference only when needed and not always.\r\n\r\n> `SHOULD NOT automatically` just means there should not be automatic dereferencing.\r\n\r\nOk, I see how this sentence is referring to fully automated dereferencing concerns, thanks! That's useful.\r\n\r\nThe spec still supports what I'm saying though, right? Even if the type is an HTTP URL, there is no requirement or guarantee that it leads to a real resource. The spec says that it's _encouraged_ to do so, and no more, and @sazzer's comment that \"saying that these must be dereferenceable is potentially quite a big hurdle\" seems to agree. Is that not correct?\r\n\r\nAssuming that's right then tooling can't use the URI as a helpful documentation link for devs, or anything similar. That's not valid because `type` is not specified to be a URL of a resource at all. It's not designed for human or machine consumption, it's only guaranteed to be usable as a type id.\r\n\r\nI think being able to use these URIs would be great. There's good use cases, from generic HTTP clients that helpfully link to error documentation in exceptions to [my own HTTP debugger](https://httptoolkit.tech), where I would _love_ to pull in error docs alongside error responses.\r\n\r\nTo build these tools we need a URL that's guaranteed to go to docs, if present. If the documentation URL were instead in a link header with an HTML media type, similar to other standards (e.g. the documentation link for the [deprecation header](https://tools.ietf.org/html/draft-ietf-httpapi-deprecation-header-01#section-3.1)) then that would be possible. Using a link header would also better fit with HATEOAS, and would make error docs immediately visible to existing tooling that isn't aware of problem details.\r\n\r\n> Decoupling the problem type from the problem type's documentation when the former can redirect to the latter just adds confusion, possible inconsistencies, and errors, imho.\r\n\r\nImho, as a developer I would find this spec more useful if they were indeed decoupled, and the type wasn't necessarily a URI at all (meaning no duplication & possible inconsistency).\r\n\r\nDoing so would resolve all the feedback above, would make this standard would be easier to get started with, it'd support more cases like error types that share the same documentation URLs and support changing doc URLs, it'd avoid semantics like relative URIs that are not being implemented correctly, it would support more dereferencing use cases, and it would better match existing patterns in other specifications and in existing real-world APIs.\r\n\r\nI do see how this is subjective and debatable, but there's many benefits, and imho requiring type URIs like limits some valuable use cases.\r\n\r\n---\r\n\r\nGoing to leave this here for now, since I need to get some other work done! This is really interesting though, hope these points are helpful.",
          "createdAt": "2021-02-02T16:20:14Z",
          "updatedAt": "2021-02-02T16:20:14Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@pimterry:\r\n\r\n> It looks like this is a real problem: even the most popular [problem details implementation](https://github.com/zalando/problem) makes this mistake.\r\n\r\nThe examples look good to me:\r\n\r\n> ```java\r\n> Problem.builder()\r\n>     .withType(URI.create(\"https://example.org/out-of-stock\"))\r\n>     .withTitle(\"Out of Stock\")\r\n>     .withStatus(BAD_REQUEST)\r\n>     .withDetail(\"Item B00027Y5QG is no longer available\")\r\n>     .build();\r\n> ```\r\n> \r\n> Will produce this:\r\n> \r\n> ```json\r\n> {\r\n>   \"type\": \"https://example.org/out-of-stock\",\r\n>   \"title\": \"Out of Stock\",\r\n>   \"status\": 400,\r\n>   \"detail\": \"Item B00027Y5QG is no longer available\"\r\n> }\r\n> ```\r\n\r\n\u2026\r\n\r\n> There's clearly friction with URIs error codes right now, and widespread patterns of _not_ using URIs for error identifiers in every existing API I can find (e.g. [Stripe](https://stripe.com/docs/error-codes), [AWS](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html#ErrorCodeList), [Azure](https://docs.microsoft.com/en-us/rest/api/storageservices/common-rest-api-error-codes)). Instead, they all use opaque string identifiers decoupled from documentation URLs.\r\n\r\nBut afaict, none of those APIs implement RFC 7807 and thus aren't very relevant in this discussion.\r\n\r\n> From my perspective and I think from the feedback above, it would be useful to have a standard that supported existing common error API patterns.\r\n\r\nWhat's considered \"common\" is relative and up to the eye of the beholder. Using Universal Resource **Identifiers** as **identifiers** shouldn't be the esoteric, impenetrable mystery it's being described as, imho.\r\n\r\n> The spec still supports what I'm saying though, right? Even if the type is an HTTP URL, there is no requirement or guarantee that it leads to a real resource.\r\n\r\nCorrect.\r\n\r\n> Assuming that's right then tooling can't use the URI as a helpful documentation link for devs, or anything similar.\r\n\r\nWhy not?\r\n\r\n> That's not valid because `type` is not specified to be a URL of a resource at all. It's not designed for human or machine consumption, it's only guaranteed to be usable as a type id.\r\n\r\nI disagree. [The specification states](https://tools.ietf.org/html/rfc7807#section-3.1) this design goal very clearly (emphasis mine):\r\n\r\n> \"type\" (string) - A URI reference [[RFC3986](https://tools.ietf.org/html/rfc3986)] that identifies the problem type.  This specification encourages that, *when dereferenced, it provide human-readable documentation for the problem type* (e.g., using HTML [[W3C.REC-html5-20141028](https://tools.ietf.org/html/rfc7807#ref-W3C.REC-html5-20141028)]).\r\n\r\n\u2026\r\n\r\n> I think being able to use these URIs would be great. There's good use cases, from generic HTTP clients that helpfully link to error documentation in exceptions to [my own HTTP debugger](https://httptoolkit.tech), where I would _love_ to pull in error docs alongside error responses.\r\n\r\nWhat do you mean with \"pull in\"?\r\n\r\n> To build these tools we need a URL that's guaranteed to go to docs, if present.\r\n\r\nWhy not change it to \"guaranteed to go to docs, if dereferenceable\"?\r\n\r\n> If the documentation URL were instead in a link header with an HTML media type, similar to other standards (e.g. the documentation link for the [deprecation header](https://tools.ietf.org/html/draft-ietf-httpapi-deprecation-header-01#section-3.1)) then that would be possible. Using a link header would also better fit with HATEOAS, and would make error docs immediately visible to existing tooling that isn't aware of problem details.\r\n\r\nThere's no one stopping anyone from doing exactly that.\r\n\r\n> Imho, as a developer I would find this spec more useful if they were indeed decoupled, and the type wasn't necessarily a URI at all (meaning no duplication & possible inconsistency).\r\n\r\nYou avoid the duplication of resolved `type` URIs if you use absolute URIs as your problem `type`.\r\n\r\n> Doing so would resolve all the feedback above, would make this standard would be easier to get started with, it'd support more cases like error types that share the same documentation URLs and support changing doc URLs, it'd avoid semantics like relative URIs that are not being implemented correctly, it would support more dereferencing use cases, and it would better match existing patterns in other specifications and in existing real-world APIs.\r\n\r\nIt would also be a breaking change with existing software that actually implements the specification according to how it is written.",
          "createdAt": "2021-02-03T08:33:43Z",
          "updatedAt": "2021-02-03T08:33:43Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> > It looks like this is a real problem: even the most popular [problem details implementation](https://github.com/zalando/problem) makes this mistake.\r\n> \r\n> The examples look good to me:\r\n> \r\n> > ```java\r\n> > Problem.builder()\r\n> >     .withType(URI.create(\"https://example.org/out-of-stock\"))\r\n> >     .withTitle(\"Out of Stock\")\r\n> >     .withStatus(BAD_REQUEST)\r\n> >     .withDetail(\"Item B00027Y5QG is no longer available\")\r\n> >     .build();\r\n> > ```\r\n> > \r\n> > \r\n> > Will produce this:\r\n> > ```json\r\n> > {\r\n> >   \"type\": \"https://example.org/out-of-stock\",\r\n> >   \"title\": \"Out of Stock\",\r\n> >   \"status\": 400,\r\n> >   \"detail\": \"Item B00027Y5QG is no longer available\"\r\n> > }\r\n> > ```\r\n\r\nI think the problem is more with *relative* URIs. If I've been following the discussion correctly then this:\r\n```\r\nGET /some/bad/uri HTTP/1.1\r\nHost: www.example.com\r\n\r\n-----\r\nHTTP/1.1 400 Bad Request\r\nContent-Type: application/problem+json\r\n\r\n{\r\n    \"type\": \"some-bad-request\"\r\n}\r\n```\r\n\r\nShould be parsed as if the `type` field was actually `http://www.example.com/some/bad/some-bad-request`, because it's relative to the URL that actually requested the resource in the first place. And (almost) nobody actually does that - they all treat it as if the `type` field was just `some-bad-request` instead.\r\n\r\n> Using Universal Resource Identifiers as identifiers shouldn't be the esoteric, impenetrable mystery it's being described as, imho.\r\n\r\nThey're not, really. XML has been doing it for 20+ years with namespace URIs. There are probably examples that go back further too.\r\n\r\n> Why not change it to \"guaranteed to go to docs, if dereferenceable\"?\r\n\r\nAs soon as you say \"guaranteed\" then you're putting a burden on developers. Especially when they plan to support dereferencing them at some future time, but not just yet. They will either ignore it, and thus not follow the spec correctly, or else it'll force them to use a different pattern for their URIs. ",
          "createdAt": "2021-02-03T09:17:19Z",
          "updatedAt": "2021-02-03T09:17:19Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> I think the problem is more with relative URIs.\r\n\r\nExactly :+1:. Nowhere do any libraries I've seen even look at the resource URL, so they can never handle relative types correctly.\r\n\r\n> > That's not valid because type is not specified to be a URL of a resource at all. It's not designed for human or machine consumption, it's only guaranteed to be usable as a type id.\r\n>\r\n> I disagree. The specification states this design goal very clearly\r\n\r\nThe specification there states the goal of linking to a useful document and encourages that, but explicitly does not guarantee or mandate it. I think we agree it shouldn't, and that not all URIs will be links to usable documentation. AFAICT, it's totally valid to intentionally use an HTTP `type` URI that leads to a 404.\r\n\r\nMeanwhile, no developer wants to be given a link to documentation and then hit a 404. If tools want to present `type` URIs to developers as helpful links to human-readable documentation, they first need to know whether it is actually a link to a resource.\r\n\r\n> Why not change it to \"guaranteed to go to docs, if dereferenceable\"?\r\n\r\nThe problem with \"guaranteed to go to docs, if dereferenceable\" as opposed to \"if present\" is that the former requires automatically dereferencing every `type` to know if it's dereferenceable. The spec specifically discourages that, for the good reasons you've pointed out above, so we shouldn't design for that. An explicit link doesn't have this problem at all.\r\n\r\n> Using Universal Resource Identifiers as identifiers shouldn't be the esoteric, impenetrable mystery it's being described as, imho.\r\n\r\nSorry, I don't mean to portray URIs as completely impenetrable, that's not fair. It seems true that the huge majority of existing APIs have existing error formats that don't use URIs for error codes though, and that many developers aren't very familiar with the nuances of URIs, e.g. URNs, tag URIs, etc.\r\n\r\nURIs are also clearly more complicated than plain strings, and all else being equal it would be good to make implementing this standard (and all standards!) as simple as possible.\r\n\r\n> none of those APIs implement RFC 7807 and thus aren't very relevant in this discussion.\r\n\r\nI really think existing widely used APIs are relevant to this standard (and all API standards!).\r\n\r\nThose APIs don't use this RFC today, but the standard only becomes useful if it's widely used by real clients and APIs. Popular APIs like Stripe/AWS/et al eventually supporting this is part of that, and adoption is easier for them if it fits their existing patterns (for example, they wouldn't need to change their existing error code documentation, or change logic that checks those codes).\r\n\r\nAdoption is similarly easier for clients and APIs responses are easier to immediately understand if the format fits their expectations, which are largely based on the common patterns they see in existing APIs.\r\n\r\nIf we want the standard to be widely adopted, we have to care about existing API patterns (and I really want this standard to be widely adopted!)\r\n\r\n---\r\n\r\nOk, so as discussed, using URIs for `type` does have some downsides, but we do have two concrete benefits that we've mentioned so far:\r\n\r\n* It strongly encourages namespacing.\r\n* It potentially links the type to a resource.\r\n\r\nAre there others I've missed?\r\n\r\nI think my position is that the first benefit is good, but IMHO outweighed by the downsides (and would still be an option for those who want it without _requiring_ URIs) whilst the 2nd benefit isn't fully realized in the current draft (you can't automatically know whether it's a usable link or just an id) and would be better realized with link headers (more explicit, more standard, less coupled).\r\n\r\n> It would also be a breaking change with existing software that actually implements the specification according to how it is written.\r\n\r\nYep, even if we agree that this would be beneficial, there is definitely a question of compatibility with existing implementations. I think there's some good routes through here with minimal impact, and this is still a draft anyway. I don't think it makes much sense to do detailed analysis & planning for that though until there's some consensus on the kind of changes we'd like to make.",
          "createdAt": "2021-02-03T20:19:54Z",
          "updatedAt": "2021-02-03T20:19:54Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@pimterry:\r\n\r\n> Meanwhile, no developer wants to be given a link to documentation and then hit a 404. If tools want to present `type` URIs to developers as helpful links to human-readable documentation, they first need to know whether it is actually a link to a resource.\r\n\r\nThere's absolutely no guarantee that can be given by anyone, anywhere, at any time, that any URI will resolve to anything at all. All URIs can lead to 404, no matter what their context and semantics are and no matter how many different avenues to provide links you give. Given enough time, most URIs end up pointing to a domain squatted by a shark. Is this of concern to RFC 7807bis? I believe it isn't.\r\n\r\n> The problem with \"guaranteed to go to docs, if dereferenceable\" as opposed to \"if present\" is that the former requires automatically dereferencing every `type` to know if it's dereferenceable.\r\n\r\nScratch \"guarantee\" altogether. No guarantees can be given. Let's work from that premise and see where we go.\r\n\r\n> Sorry, I don't mean to portray URIs as completely impenetrable, that's not fair. It seems true that the huge majority of existing APIs have existing error formats that don't use URIs for error codes though, and that many developers aren't very familiar with the nuances of URIs, e.g. URNs, tag URIs, etc.\r\n\r\nThe perception of impenetrable mystique built around URIs affects both how RFC 7807's `type` is perceived as well as how hypermedia is approached (or rather, isn't) in the realm of APIs. Unlike you, though, I think that's ample reason to **not** give in to the perception, but instead, evangelize for more use of URIs both as identifiers as well as the target of hypermedia controls in an API.\r\n\r\nThe fact that most HTTP APIs aren't RESTful by any stretch of the imagination doesn't make it right for a standardization organization such as IETF to cave in and succumb to the million flies doctrine. I'd say the right thing to do is the direct opposite and continue to normalize the use of URIs as well as hypermedia so APIs can become more, not less, RESTful over time.\r\n\r\n> URIs are also clearly more complicated than plain strings, and all else being equal it would be good to make implementing this standard (and all standards!) as simple as possible.\r\n\r\nI think that's just a matter of familiarity. Use URIs enough and they become the opaque identifiers they are meant to be. A simple solution to this may perhaps be to override the base URI. Since [`Content-Base`](https://webconcepts.info/concepts/http-header/Content-Base) isn't an option and afaik no `base` link relation exists, we need another way to establish a base URI, perhaps by registering the `base` link relation.\r\n\r\nAnother alternative is to add a slash to make the URI absolute: `\"type\": \"/out-of-credit\"`. Now you have a `type` that will be considered equal no matter how you compare it against a `type` given in a response from the same authority.\r\n\r\n> I really think existing widely used APIs are relevant to this standard (and all API standards!).\r\n\r\nAs a reminder of how bad sad the status quo is, perhaps.\r\n\r\n> Those APIs don't use this RFC today, but the standard only becomes useful if it's widely used by real clients and APIs. \r\n\r\nTrue.\r\n\r\n> Ok, so as discussed, using URIs for `type` does have some downsides, but we do have two concrete benefits that we've mentioned so far:\r\n> \r\n> * It strongly encourages namespacing.\r\n> * It potentially links the type to a resource.\r\n> \r\n> Are there others I've missed?\r\n\r\nAs discussed in #7, there's an existing desire to reuse `type` URIs across different APIs, something which is impossible with opaque strings since you have no idea whether `invalid-draft` coming from three different APIs means:\r\n\r\n1. It is currently impossible to let a current of air into the enclosed space specified in the request.\r\n2. The document specified does not exist in draft form and may be published or deleted.\r\n3. Military enrolment is currently not possible.\r\n\r\nSemantical ambiguities like these aren't insignificant and URIs solve them elegantly and efficiently. [schema.org](https://schema.org/)  is a testament to how successful the use of URIs to identify things in an unambiguous, unique, and reusable way, really is.\r\n\r\n> I think there's some good routes through here with minimal impact\r\n\r\nPlease elaborate.\r\n\r\n> and this is still a draft anyway.\r\n\r\nRFC 7807bis is a draft, RFC 7807 isn't.\r\n",
          "createdAt": "2021-02-03T22:56:31Z",
          "updatedAt": "2021-02-03T22:56:31Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> > Meanwhile, no developer wants to be given a link to documentation and then hit a 404. If tools want to present `type` URIs to developers as helpful links to human-readable documentation, they first need to know whether it is actually a link to a resource.\r\n> \r\n> There's absolutely no guarantee that can be given by anyone, anywhere, at any time, that any URI will resolve to anything at all. All URIs can lead to 404, no matter what their context and semantics are and no matter how many different avenues to provide links you give. Given enough time, most URIs end up pointing to a domain squatted by a shark. Is this of concern to RFC 7807bis? I believe it isn't.\r\n\r\nThere's also the fact that not all URIs are resolvable for all clients. It's entirely possible that the URI resolves correctly for the server developer, but some client is behind some firewall that doesn't allow access to it.\r\n\r\nOr it might be temporarily down. Or a myriad of other reasons why a reasonable URI can't be resolved *right now*.\r\n\r\n> Another alternative is to add a slash to make the URI absolute: \"type\": \"/out-of-credit\". Now you have a type that will be considered equal no matter how you compare it against a type given in a response from the same authority.\r\n\r\nThat's still relative. If I understand things correctly, the path segment is now absolute but the schema/host/port/etc isn't specified so become relative to the original request. If you got that type from different APIs *on different hosts* then the resolved absolute URI is still different.\r\n\r\n> As discussed in #7, there's an existing desire to reuse type URIs across different APIs, something which is impossible with opaque strings since you have no idea whether invalid-draft coming from three different APIs means:\r\n\r\nIt's perfectly possible with opaque strings. It's not possible with relative URIs iff the resulting value is first expanded to be an absolute URI - and thus might have a different value based on the scheme/hostname/port of the API being called. If the value was always an absolute URI or a relative URI that didn't get expanded then this problem goes away. Though at that point you've just got opaque strings that might or might not bear some resemblance to a URI.",
          "createdAt": "2021-02-04T09:28:35Z",
          "updatedAt": "2021-02-04T09:28:35Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Another alternative is to add a slash to make the URI absolute: \"type\": \"/out-of-credit\". Now you have a type that will be considered equal no matter how you compare it against a type given in a response from the same authority.\r\n> \r\n> That's still relative. If I understand things correctly, the path segment is now absolute but the schema/host/port/etc isn't specified so become relative to the original request. If you got that type from different APIs _on different hosts_ then the resolved absolute URI is still different.\r\n\r\nYes, that's why I wrote \"from the same **[authority](https://tools.ietf.org/html/rfc3986#section-3.2)**\".\r\n\r\n> > As discussed in #7, there's an existing desire to reuse type URIs across different APIs, something which is impossible with opaque strings since you have no idea whether invalid-draft coming from three different APIs means:\r\n> \r\n> It's perfectly possible with opaque strings.\r\n\r\nNot unless these strings are registered and clearly defined in a global registry.\r\n\r\n> It's not possible with relative URIs iff the resulting value is first expanded to be an absolute URI - and thus might have a different value based on the scheme/hostname/port of the API being called.\r\n\r\nI agree that's just as useless as opaque, non-URI strings.",
          "createdAt": "2021-02-04T10:45:58Z",
          "updatedAt": "2021-02-04T10:45:58Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> There's absolutely no guarantee that can be given by anyone, anywhere, at any time, that any URI will resolve to anything at all.\r\n\r\n> It's entirely possible that the URI resolves correctly for the server developer, but some client is behind some firewall that doesn't allow access to it.\r\n\r\nOk, granted, you can't get a perfect guarantee. There is both a semantic and practical difference though between \"here is a link that I intend you to dereference to find more information\" and \"here is a URI that is not intended to be dereferenced, it's just a type id\".\r\n\r\nWe currently allow both, intentionally, with no distinguishable difference until you dereference it. When looking for usable links to more information, any tooling is interested only in the former, where the URL is _very likely_ to be useful (granted, not guaranteed). Meanwhile if you ever accidentally use the latter it's extremely likely to provide a bad user experience.\r\n\r\nIt's very easy to differentiate these cases, and it would be useful, so we should.\r\n\r\n> > If you got that type from different APIs on different hosts then the resolved absolute URI is still different.\r\n>\r\n> Yes, that's why I wrote \"from the same authority\".\r\n\r\nUnfortunately that's the same problem: client implementations do not take the authority into account either, they never use the base URL. I agree that they should, but right now it looks like most implementations of this specification handle both relative & absolute paths incorrectly, and only correctly use fully specified absolute URIs.\r\n\r\n> Semantical ambiguities like these aren't insignificant and URIs solve them elegantly and efficiently.\r\n\r\nI agree that URIs are excellent! I don't object to the use of URIs, I object to _requiring_ that all APIs errors use URIs in all cases, as we do right now. There's lots of feedback (see above) that others feel similarly, and would like to use this spec without URIs.\r\n\r\nAs an interesting supporting point: the WHATWG URL specification [specifically removed](https://url.spec.whatwg.org/#goals) all references to URIs because \"URI and IRI are just confusing\". URIs are not well understood by many developers, and that will limit adoption of this spec.\r\n\r\nRight now, as in the blog post above, some users avoid using `type` entirely because it's confusing and they don't want to create pages for every error type. This creates more semantic ambiguity than the status quo!\r\n\r\n> > I think there's some good routes through here with minimal impact [on backward compat]\r\n>\r\n> Please elaborate.\r\n\r\nOk, one option would be:\r\n\r\n* Make `type` a freeform string where every response from the same API with that code represents the same type of error. Unspecified still defaults to `about:blank`. Just one constraint: if `type` is an absolute URI, it must either be a URI already reserved for that purpose or a URI under the control of the API using it (e.g. HTTP/tag on your domain).\r\n    * This has no compatibility impact for existing APIs using absolute type URIs. Types in their existing responses are still valid and retain extremely similar rules for error type matching (technically there _could_ be differences, e.g. # fragments in URL shouldn't be considered in URL comparisons, but I would be astonished if that is in use and working correctly for error handling in any API today).\r\n\t* No compatibility impact for clients receiving existing responses that are absolute URIs or absolute paths, for similar reasons.\r\n\t* Semantics change slightly for clients & APIs using path-relative URI types. Today these should be assumed to be distinct types per endpoint, and they would instead be treated as API-global.\r\n  \t  * Helpfully, it appears that most implementations match this proposed behaviour today already, rather than the specified behaviour.\r\n  \t  * In addition, impact of incompatibility is low: clients would incorrectly treat error types as distinct unrecognized errors, and would fail in slightly less granular ways.\r\n\t* Clients who parse `type` as a URI have potential compatibility issues parsing non-URI responses. This risk is low because:\r\n  \t  * This doesn't affect or invalidate any existing client & API exchange that works today. It only affects clients newly making requests to APIs who start using some new URI-unparseable error type.\r\n  \t  * URI syntax is _very_ permissive, so most plain strings that would be used are also valid relative URIs, e.g `invalid-draft` works just fine (though, as mentioned, its semantics change slightly as it's currently a relative URI). It's very difficult to come up with examples of plausible error codes that would fail to parse as URIs. We could tighten the allowed characters if this is a concern.\r\n* If a type is an absolute URI defined in a URI registry of common types or otherwise recognized by the client, the error SHOULD be treated as an instance of the globally registered error types (i.e. #7)\r\n\t* Fully compatible, and we retain the ability to share types across different services\r\n\t* By putting `about:blank` into this URI registry, we retain the same semantics for that\r\n* APIs are encouraged to use absolute URIs as types, for namespacing and type-sharing benefits, but this becomes optional.\r\n* APIs who have documentation relevant to the error response should include a link header.\r\n    * I'd suggest we mint a new relation `problem-doc`. This would pair very nicely with the existing [`service-doc` relation](https://tools.ietf.org/html/rfc8631#section-4.1). Service-doc provides general documentation for the resource, problem-doc provides documentation for the type of error returned.\r\n\r\nThat resolves all the points above, with minimal backward compatibility impact. It still supports all the benefits that absolute URIs give us for those who want that, but also supports other cases too.\r\n\r\nWould that work for you? Are there specific compatibility concerns in here that would need further mitigation?",
          "createdAt": "2021-02-05T15:13:52Z",
          "updatedAt": "2021-02-05T15:41:56Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> Ok, granted, you can't get a perfect guarantee. There is both a semantic and practical difference though between \"here is a link that I intend you to dereference to find more information\" and \"here is a URI that is not intended to be dereferenced, it's just a type id\".\r\n> \r\n> We currently allow both, intentionally, with no distinguishable difference until you dereference it. When looking for usable links to more information, any tooling is interested only in the former, where the URL is _very likely_ to be useful (granted, not guaranteed). Meanwhile if you ever accidentally use the latter it's extremely likely to provide a bad user experience.\r\n\r\nI've been working with XML for many years, where XML namespaces are URIs that almost never dereference to anything. In fact, there are normally specific mechanisms in XML tooling to know where the XSD for a given namespace is simply because the namespace URI doesn't dereference.\r\n\r\nAnd it works fine. People use it, and all is good. So tooling only being interested in dereferenceable links isn't strictly accurate.\r\n\r\n> Ok, one option would be:\r\n> [....]\r\n\r\nIn terms of your proposal. My one concern with it is that I suspect many developers will opt for the choice of just using error codes instead of URIs, because they find it easier. That then means that you lose namespacing, you lose the ability for different APIs to share the same error types, and probably other things.\r\n\r\nThere's also the minor concern that strictly speaking you can't distinguish a URI from an arbitrary string that happens to have the same format. Somebody might write a string that just happens to contain `://` in the middle of it. Is that a URI? Or is it a coincidence? That's very much an edge case though and almost certainly can be ignored :)\r\n\r\nThe impact on existing clients is also a concern, if it means that suddenly they can't understand errors that they could before. That's only an issue for clients that are correctly handling relative URIs though, and I don't know how many of those there are - if any.",
          "createdAt": "2021-02-05T15:47:56Z",
          "updatedAt": "2021-02-05T15:47:56Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> So tooling only being interested in dereferenceable links isn't strictly accurate.\r\n\r\nTrue. I'm really talking about a specific subset of tooling, I should be more specific. I'm thinking about tooling that might format an error response for human consumption, like debuggers, manual clients like Postman & curl, loggers, and other error reporting tools.\r\n\r\nI think those are tools that could get a lot of value from this spec, and in many of these cases it's useful to know if the URL is documentation intended for human consumption.\r\n\r\n> There's also the minor concern that strictly speaking you can't distinguish a URI from an arbitrary string that happens to have the same format. Somebody might write a string that just happens to contain :// in the middle of it. Is that a URI? Or is it a coincidence? That's very much an edge case though and almost certainly can be ignored :)\r\n\r\nIt's slightly more general unfortunately, since some absolute URIs only contain `:` e.g. `tag:example.com,2021:my-error`.\r\n\r\nIf that's a concern, I think saying \"error types must not contain : unless they're an absolute URI\" would be a reasonable constraint, and would support most error codes you see in the real world. Explicitly specifying that would help parsers to quickly differentiate the two cases too.\r\n\r\n> My one concern with it is that I suspect many developers will opt for the choice of just using error codes instead of URIs, because they find it easier.\r\n\r\nThat is quite possible. It appears that there's also a group of people who currently avoid the spec altogether though, or use it suboptimally, because of the URI requirement. Standard formatting of error messages seems very valuable even without URIs.\r\n\r\nPersonally I'm OK with this. Error types intended to be reused elsewhere can use URIs, and error types not intended for global reuse don't need URIs. The challenging case is when you want to reuse a URI defined by somebody else who didn't explicitly make it reusable. I'm OK with not supporting that, but I see how others might find this useful.\r\n\r\n> The impact on existing clients is also a concern, if it means that suddenly they can't understand errors that they could before. That's only an issue for clients that are correctly handling relative URIs though, and I don't know how many of those there are - if any.\r\n\r\nYep. I doubt it's used much though, and I suspect this change would actually _increase_ the number of implementations that matched the spec when using relative URIs. I'd be really interested to know if anybody can find an example of a relative `type` URI in production anywhere though.",
          "createdAt": "2021-02-05T16:13:26Z",
          "updatedAt": "2021-02-05T16:13:26Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is both a semantic and practical difference though between \"here is a link that I intend you to dereference to find more information\" and \"here is a URI that is not intended to be dereferenced, it's just a type id\".\r\n\r\nBut RFC 7807 does not state \"here is a URI that is not intended to be dereferenced, it's just a type id\". It states that `type` should not be **automatically** dereferenced. Dereferencing `type` based on a user's action, perhaps by clicking \"view documentation\" in a UI is perfectly fine and should probably be encouraged for documentation purposes in the specification. rfc7808bis should seek to clarify that.\r\n\r\nIf the link doesn't resolve, the UI would have to recover from that failure somehow regardless of the semantics and guarantees that were given regarding the link that was dereferenced. \"Sorry, no documentation for `example.com/out-of-credit` is available\" is a fine error message for `type` just as it is described by the specification as well as for a new `documentation` URI that as such don't provide anything valuable `type` doesn't already provide.\r\n\r\n> We currently allow both, intentionally, with no distinguishable difference until you dereference it. When looking for usable links to more information, any tooling is interested only in the former, where the URL is _very likely_ to be useful (granted, not guaranteed). Meanwhile if you ever accidentally use the latter it's extremely likely to provide a bad user experience.\r\n\r\nWhy would the user experience be bad? Please elaborate.\r\n\r\n> Unfortunately that's the same problem: client implementations do not take the authority into account either, they never use the base URL.\r\n\r\nThen they don't have the problem described, since they will just compare `/out-of-credit` with `/out-of-credit` across all responses, regardless of the context (base) URI.\r\n\r\n> I agree that they should, but right now it looks like most implementations of this specification handle both relative & absolute paths incorrectly, and only correctly use fully specified absolute URIs.\r\n\r\nFor clients that don't treat `type` as a URI, `/out-of-credit` in response A is just an opaque string, indiscernible from `/out-of-credit` in response B, even though A and B may be from entirely different authorities altogether (although within the same API, I assume).\r\n\r\n> As an interesting supporting point: the WHATWG URL specification [specifically removed](https://url.spec.whatwg.org/#goals) all references to URIs because \"URI and IRI are just confusing\".\r\n\r\nI think you meant \"URL\" and not \"URI\" here, but regardless I agree with WHATWG in that both \"URI\" and \"IRI\" are confusing and don't add much to the more prevalent \"URL\". I'm not sure IETF is ready to replace its usage of \"URI\" to \"URL\" yet, though. That would probably require rfc3986bis of some sort.\r\n\r\n> URIs are not well understood by many developers, and that will limit adoption of this spec.\r\n\r\nI agree URIs are not well understood. But I think that is a problem and believe the solution is not to cave in and stop using URIs, but to use **even more** URIs.\r\n\r\n![URI ALL THE THINGS](https://user-images.githubusercontent.com/12283/107090318-51682300-6800-11eb-94ba-c2d947489403.png)\r\n\r\n> Right now, as in the blog post above, some users avoid using `type` entirely because it's confusing\r\n\r\nThen let's invest in making it less confusing in rfc7807bis! \ud83d\ude03 \r\n\r\n> and they don't want to create pages for every error type.\r\n\r\nThey don't have to. Let's be more explicit about that. More examples could perhaps help.\r\n\r\n> Ok, one option would be: [\u2026] Would that work for you?\r\n\r\nSorry, no. I'll just +1 @sazzer's criticism here. I don't think this is going to work. In hindsight, it may have been better if non-URI values were interpreted not as relative URIs, but as implicit URNs or something similar. But that train sailed with a boat on water under the bridge more than 5 years ago.\r\n\r\n>  Are there specific compatibility concerns in here that would need further mitigation?\r\n\r\nYes, your suggestion is going to break clients with the following expectations:\r\n\r\n* `type` URIs that point to external documentation.\r\n* Non-absolute `type` URIs are relative to the context.\r\n\r\n\r\n>> So tooling only being interested in dereferenceable links isn't strictly accurate.\r\n> \r\n> True. I'm really talking about a specific subset of tooling, I should be more specific. I'm thinking about tooling that might format an error response for human consumption, like debuggers, manual clients like Postman & curl, loggers, and other error reporting tools.\r\n\r\nIsn't it possible for these tools to only present documentation upon a user's explicit action?\r\n\r\n> I think those are tools that could get a lot of value from this spec, and in many of these cases it's useful to know if the URL is documentation intended for human consumption.\r\n\r\nIf `type` is dereferenceable, the content is intended for human consumption.\r\n\r\n> It appears that there's also a group of people who currently avoid the spec altogether though, or use it suboptimally, because of the URI requirement. Standard formatting of error messages seems very valuable even without URIs.\r\n\r\nPerhaps we could survey these people on the reason they're not using RFC 7807 instead of just speculating?\r\n\r\n> Yep. I doubt it's used much though, and I suspect this change would actually _increase_ the number of implementations that matched the spec when using relative URIs. I'd be really interested to know if anybody can find an example of a relative `type` URI in production anywhere though.\r\n\r\nI believe your suspicion may be correct. I would love to see the result of a survey of existing implementations before concluding, but I'm currently +0 to make the compromise of making non-URI `type` implicit URNs or some other similar solution that doesn't convert them into context-relative HTTP(S) URIs.",
          "createdAt": "2021-02-05T21:54:20Z",
          "updatedAt": "2021-02-05T21:54:20Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To expand on the \"making non-URI `type` implicit URNs\", this sort of implicit expansion has precedent in [RFC 4287 section 4.2.7.2](https://tools.ietf.org/html/rfc4287#section-4.2.7.2)'s definition of `rel`:\r\n\r\n>The value of \"rel\" MUST be a string that is non-empty and matches either the \"isegment-nz-nc\" or the \"IRI\" production in [[RFC3987](https://tools.ietf.org/html/rfc3987)]. Note that use of a relative reference other than a simple name is not allowed.  If a name is given, implementations MUST consider the link relation type equivalent to the same name registered within the IANA Registry of Link Relations ([Section 7](https://tools.ietf.org/html/rfc4287#section-7)), and thus to the IRI that would be obtained by appending the value of the rel attribute to the string \"[http://www.iana.org/assignments/relation/](http://www.iana.org/assignments/relation/)\".\r\n\r\nIn [RFC 5988 section 4.1](https://tools.ietf.org/html/rfc5988#section-4.1), `rel`values are either required to be registered in IANA's Link Relation Registry, or in the case of Extension Relation Types, full URIs. RFC 7807's deviation from these two mechanisms in making `type` relative to the context is perhaps the source of the greatest issue here.\r\n\r\nI've come to agree that `\"type\": \"out-of-funds\"` should be comparable across problem documents disregard of their request context.",
          "createdAt": "2021-02-10T01:58:43Z",
          "updatedAt": "2021-02-10T01:58:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @asbjornu - that's interesting, but it's backwards-incompatible, so we'd need to use a new media type. Is that worth it (considering the resulting confusion, etc.)?",
          "createdAt": "2021-02-10T02:04:21Z",
          "updatedAt": "2021-02-10T02:04:21Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for being imprecise. What I meant was that I agree with (part of) the problem description. I'm +0 on actually doing anything about it. If enough weight is put behind a new media type to break with the current implementations of `type`, then I would not oppose it.",
          "createdAt": "2021-02-10T02:17:42Z",
          "updatedAt": "2021-02-10T02:17:42Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "The obvious concern with a new media type is that implementers will either need to migrate completely over to it, or else end up supporting two different ways of representing problems. That feels at odds with what - to me - is one of the major benefits of RFC-7807 in the first place, that there is one standard way to do this and you'd need a good reason to do something different.",
          "createdAt": "2021-02-10T09:52:21Z",
          "updatedAt": "2021-02-10T09:52:21Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-02-10 10:52, Graham Cox wrote:\n> The obvious concern with a new media type is that implementers will \n> either need to migrate completely over to it, or else end up supporting \n> two different ways of representing problems. That feels at odds with \n> what - to me - is one of the major benefits of RFC-7807 in the first \n> place, that there is one standard way to do this and you'd need a good \n> reason to do something different.\n\nthe discussion around using URIs as identifiers has been had what feels \nlike a million times. everybody knows the implications. it's a design \ntrade-off.\n\ngiven that there is no clear \"winner\" i think not breaking the existing \nmedia type should make it a big preference to stick with what we have.\n\ni am more than willing to make proposals how to improve the language so \nthat people reading the spec get a bit more context and assistance. but \nas we all know, specs are not read as much as one might wish, so we'll \nstill see broken implementations out there. that's just life.\n\n-- \nerik wilde | mailto:erik.wilde@dret.net |\n            | http://dret.net/netdret    |\n            | http://twitter.com/dret    |\n",
          "createdAt": "2021-02-10T10:10:07Z",
          "updatedAt": "2021-02-10T10:10:07Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "Whilst it would still be technically incompatible, I think the practical outcome from [my proposed changes](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/11#issuecomment-774093348) would be that:\r\n\r\n* The incompatibility only affects fully relative URIs (e.g. `out-of-funds`). Both absolute URIs and absolute paths would retain effectively identical semantics to the current spec.\r\n* That incompatible case is not used or discussed in the wild anywhere that I've ever seen (counter examples very welcome!)\r\n* In generic implementations, the incompatible case appears to be incorrectly implemented everywhere, with every implementation I've seen already matching the proposed rather than specified behaviour for this case. It seems likely that this breaking change would dramatically _increase_ the number of implementations correctly implementing the specification today.\r\n\r\nDoes that affect the calculus on breaking changes here?\r\n\r\n(I do agree that @asbjornu's proposal to make relative error types global by default has much larger compatibility implications, unfortunately, and that minting a new media type has repercussions that make this unlikely to be worthwhile in either case)",
          "createdAt": "2021-02-10T10:24:51Z",
          "updatedAt": "2021-02-10T10:24:51Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> Both absolute URIs and absolute paths would retain effectively identical semantics to the current spec.\r\n\r\nNot quite. Absolute URIs retain identical semantics. Absolute paths only retain identical semantics if they are from the same scheme and authority. If they come from different authorities then the resolved URI from those absolute paths is different, and thus the value to use under the current spec is different.\r\n\r\nHowever, as you say, nobody does that. At least, nobody that I've ever seen. I don't know how we'd find out if introducing a breaking change is actually going to break things in any real code, but it seems to me that this proposed change is the cleanest route and that the risk of breaking things is mitigated by the fact that (almost) everybody does it wrong now anyway.\r\n\r\nThe other option would be to introduce not a new media type, but a new parameter to the existing media type. So it becomes `application/problem+json; v=2`. Anyone who doesn't specify a value for `v` would then be assumed to be using the most recent version of the spec, which is what we're discussing here. If they explicitly want to retain the old behaviour then they would specify `v=1`. (That would also open the door for further future changes that introduce a `v=3` as well.)\r\n\r\nI will say, I'm not hugely thrilled by that idea. I prefer trying to keep things simple and not need to do any versioning like that. But it is an option.",
          "createdAt": "2021-02-10T11:48:28Z",
          "updatedAt": "2021-02-10T11:48:28Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> Absolute paths only retain identical semantics if they are from the same scheme and authority. If they come from different authorities then the resolved URI from those absolute paths is different, and thus the value to use under the current spec is different.\r\n\r\nIn the proposed version, both relative & absolute paths would be considered as scoped to the API (i.e. the scheme & authority). So `out-of-funds` should be treated as same type of error everywhere in the API (unlike today) and as distinct types if returned from different APIs (same as today).\r\n\r\n`/problem/out-of-funds` doesn't change though: it should be treated as the same type everywhere in the same API (the same as today) and as distinct types if returned by different APIs (the same as today).\r\n\r\nDoes that not match today's semantics? Maybe I'm missing something, do you have an example where the  behaviour changes?",
          "createdAt": "2021-02-10T12:08:06Z",
          "updatedAt": "2021-02-10T12:08:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "So it seems like we have some agreement that we don't want to introduce a new mime type, and as a result we shouldn't change the nature of `type` in a backwards-incompatible fashion.\r\n\r\n**Proposal:** we should resolve this issue by focusing on making the spec communicate more clearly about how to use URIs successfully in `type`, possibly adding new fields, etc. in separate issues. Once we do that, we should close this issue, but label it `revisit-on-breaking-change` so that if for some reason we find a compelling enough reason to mint a new mime type, we remember to reconsider.\r\n",
          "createdAt": "2021-02-10T23:45:42Z",
          "updatedAt": "2021-02-10T23:45:42Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "Personally I'd still prefer the technically-incompatible-but-_probably_-more-compatible proposal with no mime type change at all, but I can understand if that's not an acceptable risk.\r\n\r\nIf we're talking about guaranteed-safe changes we can make, the things I'd personally find useful are:\r\n\r\n* Making a clear & simple recommendation in the spec for users who have a simple error code and who don't want to link the error type to a documentation page. E.g. they should use tags, or URNs, or absolute paths, or something else.\r\n* Discouraging fully relative paths, since they're very counter-intuitive, most/all implementations handle them wrong, and we may want to change their semantics in a future breaking change.\r\n* Providing some way for clients to know if a type URL is designed to be dereferenced as a link to documentation, or if it's simply acting as an identifier.\r\n\r\nI'll file new issues for those, and we can continue discussion on them independently there. Happy for this issue to be tagged and left for a future breaking change in the meantime if that's all we can do for now.",
          "createdAt": "2021-02-11T15:31:18Z",
          "updatedAt": "2021-02-11T15:31:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "See PR #20. Thoughts?",
          "createdAt": "2021-04-26T03:52:33Z",
          "updatedAt": "2021-04-26T03:52:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Am merging #20, which will close this. If anyone has further input, please open a new issue or comment.",
          "createdAt": "2021-05-25T06:56:39Z",
          "updatedAt": "2021-05-25T06:56:39Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU4MDM2NTI3MjI=",
      "title": "Problem Details Object for Warning",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/12",
      "state": "CLOSED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Capturing @ioggstream's response from email thread with follow up questions. Should Problem Details JSON Object schema have any member indicating that the problem(s) is an error(s) or warning(s)? If yes, which status code(s) could be used in case of warning.\r\n\r\nOn Tue, Jan 19, 2021 at 12:30 AM Roberto Polli <roberto@> wrote:\r\nI would like to find a convergent solution for both Problem and\r\nContent-Warning, eg. see\r\nhttps://github.com/dret/I-D/blob/master/http-warning/draft-cedik-http-warning-02.txt#L295\r\nwhich proposes the use of a list of Problem.json which - imho -\r\nprovide redundant information (eg. `status` should always be the\r\nsame).\r\n\r\nKind regards,\r\nR.\r\n--\r\nRoberto Polli\r\nAPI Expert",
      "createdAt": "2021-02-08T15:11:08Z",
      "updatedAt": "2021-11-12T11:35:17Z",
      "closedAt": "2021-11-12T11:35:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "My initial thought is that the problem type itself should indicate this (e.g., in its documentation). The term 'problem' was used very deliberately, to cover both (and perhaps more).\r\n\r\nIs there a use case for software generically sifting things considered \"warnings\" from \"problems\" without knowing anything specific about the type? If so, more details about it would help drive the design here.\r\n\r\nAlso, if we go down this road, should we be considering a 'level' parameter?",
          "createdAt": "2021-02-10T01:46:27Z",
          "updatedAt": "2021-02-10T01:46:27Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "I've contacted Erik to see if it would be best to put our ideas and efforts into rfc7807bis instead of the I-D. Haven't heard from him back though. \r\n\r\nI have to agree with Mark when he's saying: \r\n> The term 'problem' was used very deliberately, to cover both (and perhaps more).\r\n\r\nFrom my point of view: I'd rather see a solution in rfc7807bis than trying to recreate the wheel since errors and warnings both are conveying information an API client might need to function properly or communicate to the end user. Having two separate ways of handling these situations makes API design more complicated. \r\n\r\n> Also, if we go down this road, should we be considering a 'level' parameter?\r\n\r\nWhat do you have in mind @mnot? Something like a log level (error, warn, info, debug)?",
          "createdAt": "2021-02-11T07:42:12Z",
          "updatedAt": "2021-02-11T07:42:12Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "NONE",
          "body": "> if it would be best to put our ideas and efforts into rfc7807bis instead of the I-D\r\n\r\n@andrecedik I think that disentangling the ~Warning I-D  from the content will still be useful and could move further, though.",
          "createdAt": "2021-02-11T08:30:03Z",
          "updatedAt": "2021-02-11T08:30:03Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "Yes @ioggstream, that could be the (only) reason for keeping the I-D alive. Throw out the proposed format for the body and just introduce the warning header field.",
          "createdAt": "2021-02-11T08:43:38Z",
          "updatedAt": "2021-02-11T08:43:38Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">If yes, which status code(s) could be used in case of warning.\r\n\r\nhttps://tools.ietf.org/html/draft-cedik-http-warning-02#section-6 suggests using 2xx\r\n\r\n`Since warnings do not have an effect on the returned HTTP status code, the response status code SHOULD be in the 2xx range, indicating that the intent of the client was successful.`\r\n\r\nhttps://tools.ietf.org/html/rfc7807#section-1\r\n`Thus, API clients can be informed of both the high-level error class (using the status code) and the finer-grained details of the problem (using one of these formats).`\r\n\r\nhigh-level error class means 4xx and 5xx (https://www.iana.org/assignments/http-status-codes/http-status-codes.xml)\r\n\r\nAs a consumer of an API, I would not imagine scenarios having a response with HTTP status as `400` and having `200` in the response body (top level or in the proposed contained problem(s)) with the proposed `level` as `warning`. Having a `status` in the response body already creates a situation that needs explanation in https://tools.ietf.org/html/rfc7807#section-5. Adding the warning scenario in the mix will make it even more complex to explain imo and most importantly for no practical use case perhaps.\r\n\r\n>My initial thought is that the problem type itself should indicate this (e.g., in its documentation). The term 'problem' was used very deliberately, to cover both (and perhaps more).\r\n\r\nI agree that this differentiation should be left to the documentation.\r\n\r\n",
          "createdAt": "2021-02-11T15:40:10Z",
          "updatedAt": "2021-02-11T15:40:10Z"
        },
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "The scenario i envision is one where problem documents are persisted, and then shared across other systems, or visualised in a log viewer, all of which tend to have a minimum amount of standard behaviours. One would be displaying a \u26a0 or \u26d4\ufe0f or what not for operators, another would be alerting differently based on the severity of a problem document.",
          "createdAt": "2021-04-28T07:16:01Z",
          "updatedAt": "2021-04-28T07:16:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "> The scenario i envision is one where problem documents are persisted, and then shared across other systems, or visualised in a log viewer, all of which tend to have a minimum amount of standard behaviours. One would be displaying a \u26a0 or \u26d4\ufe0f or what not for operators, another would be alerting differently based on the severity of a problem document.\r\n\r\nIs that information associated with the problem _instance_ or the problem _type_?\r\n\r\nIt strikes me that it might be useful to start thinking about a problem type description document format that can be fetched from the type URI; that would be able to convey this information, documentation in a machine-readable format that can be used by tooling, etc. \r\n\r\nIt would also avoid the extension problem noted in https://github.com/ietf-wg-httpapi/rfc7807bis/issues/15#issuecomment-886360909\r\n\r\nDoing so would give type definitions an incentive to make their URIs resolvable, rather than just 404.",
          "createdAt": "2021-07-26T04:24:59Z",
          "updatedAt": "2021-07-26T04:25:49Z"
        },
        {
          "author": "SleeplessByte",
          "authorAssociation": "NONE",
          "body": "Nothing prevents us from `Accept: x/y` for a machine readable format on those _type_ urls, right? We currently serve `text/html`, but looking at our systems, we could actually serve some machine readable format after content-neg.",
          "createdAt": "2021-07-27T22:16:13Z",
          "updatedAt": "2021-07-27T22:16:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "@SleeplessByte nope :)",
          "createdAt": "2021-07-27T22:17:57Z",
          "updatedAt": "2021-07-27T22:17:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we define such a format in an appendix of this spec, or punt it down the road? Thoughts?",
          "createdAt": "2021-10-11T00:14:52Z",
          "updatedAt": "2021-10-11T00:14:52Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-11 02:15, Mark Nottingham wrote:\n> Should we define such a format in an appendix of this spec, or punt it \n> down the road? Thoughts?\n\nhaving worked on a draft for this, there is some work we could use, but \nthen again i'd prefer to see that being part of a spec. but maybe having \nit as an appendix is better than not having anything at all, so i am \nslightly in favor of such an appendix.\n",
          "createdAt": "2021-10-11T07:26:47Z",
          "updatedAt": "2021-10-11T07:26:47Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">Should we define such a format in an appendix of this spec, or punt it down the road? Thoughts?\r\n\r\nSince warnings are sent with `200` which is never used to respond with error(s), I am not sure how warnings could be accommodated here. Having said that, I am open to reviewing the text in appendix.\r\n",
          "createdAt": "2021-10-11T13:40:11Z",
          "updatedAt": "2021-10-11T13:40:11Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "You could combine the warnings with the `Content-Warning` field proposed in the [draft](https://datatracker.ietf.org/doc/draft-cedik-http-warning/) @dret mentioned, thus making it possible to react to its presence although the HTTP status code is 200.",
          "createdAt": "2021-10-11T18:29:27Z",
          "updatedAt": "2021-10-11T18:29:27Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "can you provide a sample that includes both warnings and errors in the same response? sample would help. looked at the draft which only shows example of warning. thanks.",
          "createdAt": "2021-10-11T18:38:06Z",
          "updatedAt": "2021-10-11T18:38:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "@sdatspun2 see above - the thinking is that we can define a format that you retrieve from the problem type URI to get more information about that problem type -- including things like warning levels.",
          "createdAt": "2021-10-11T22:34:39Z",
          "updatedAt": "2021-10-11T22:34:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-12 00:34, Mark Nottingham wrote:\n> @sdatspun2 <https://github.com/sdatspun2> see above - the thinking is \n> that we can define a format that you retrieve from the problem type URI \n> to get more information about that problem type -- including things like \n> warning levels.\n\nthat's not quite what the warning draft/effort was all about. that one \nwas all about communicating warnings at runtime in a way similar to what \nRFC 7807 does, but without being a critical error.\n\nif we're looking at other aspects such as representing a problem type \ndescription, then maybe we can call it something different than \"warning \ninformation\"? maybe it's just me getting confused because of the work on \nthe warning message draft, but maybe others find it confusing as well.\n",
          "createdAt": "2021-10-12T07:08:12Z",
          "updatedAt": "2021-10-12T07:08:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "@dret do you have concrete proposals for changes in *this* draft? Looking at the issue above, I don't think we've gone off track here...",
          "createdAt": "2021-10-13T00:33:40Z",
          "updatedAt": "2021-10-13T00:33:40Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "i think we're mixing two things here, and the issue title of \"Problem Details Object for Warning\" doesn't help.\r\n\r\n- there is [a (expired) draft that defines a `Content-Warning` header field and a suggested format to be used as a building block in JSON formats.](https://datatracker.ietf.org/doc/html/draft-cedik-http-warning-02) feedback regarding that draft let @andrecedik and myself to believe that maybe the JSON format is not needed, which would leave just the `Content-Warning` header field. this is mostly about allowing servers to say that they served a request, but that there are some issues that a client might want to look at. we could add [the section defining the header field](https://datatracker.ietf.org/doc/html/draft-cedik-http-warning-02#section-3) to 7807bis, but that would slightly change the scope of the spec because it now also would talk about things to be done when a problem is just a warning and not an error.\r\n- most of the discussions in this issue here seem to center around either a format for representing problem report instances or problem report types. both of these may be useful things to have, but in my mind are fairly different from the scenario that i initially thought this issue is about. but i may have misunderstood the title from the very beginning.\r\n\r\nto answer your question, @mnot: i think adding the `Content-Warning` field could be useful as a way to provide mechanism for a slightly wider range of problems, but that proposal doesn't seem to be what most people are discussing here.\r\nthe downside of doing this could be that it might require quite a bit of reworking of the draft to make sure that it covers the scenario of requests being served with success status codes, but with some warning information included. the upside would be that the handling of types could be unified across the `Content-Warning` field's `type` (which currently uses a mechanism with a registry but that of course can be changed) and the `type` member of the problem report format.",
          "createdAt": "2021-10-13T08:37:07Z",
          "updatedAt": "2021-10-13T08:38:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "OK. If we want to finish this quickly and avoid scope creep, we should probably punt both the header and the format to separate drafts. What do folks think - is this something that needs to ship with rfc7807bis?",
          "createdAt": "2021-10-19T03:07:09Z",
          "updatedAt": "2021-10-19T03:07:09Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-19 05:07, Mark Nottingham wrote:\n> OK. If we want to finish this quickly and avoid scope creep, we should \n> probably punt both the header and the format to separate drafts. What do \n> folks think - is this something that needs to ship with rfc7807bis?\n\nimho it's not something that needs to be part of the draft. it \ndefinitely would extend the scope (but in a good way, i think).\n\n",
          "createdAt": "2021-10-19T07:15:12Z",
          "updatedAt": "2021-10-19T07:15:12Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\n>If we want to finish this quickly and avoid scope creep, we should probably punt both the header and the format to separate drafts",
          "createdAt": "2021-10-19T16:41:42Z",
          "updatedAt": "2021-10-19T16:41:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Based upon the above, closing - please say so if you disagree / have more info.",
          "createdAt": "2021-11-12T11:35:17Z",
          "updatedAt": "2021-11-12T11:35:17Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU4MDY1MDAwODE=",
      "title": "Make a clear recommendation for the 'type' to use when not linking to a documentation URL",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/13",
      "state": "CLOSED",
      "author": "pimterry",
      "authorAssociation": "NONE",
      "assignees": [
        "mnot"
      ],
      "labels": [],
      "body": "_Pulling this conversation out of #11:_\r\n\r\nIt's clear that there's demand for error codes scoped to the API, without creating documentation pages for each code and linking to them in the `type` field. There are many ways that implementers could do this, from linking to non-existent URLs to URNs to tags URIs, etc.\r\n\r\nIt would be useful if the specification included examples of this, and made a clear recommendation for this case.",
      "createdAt": "2021-02-11T15:32:05Z",
      "updatedAt": "2021-09-23T23:43:51Z",
      "closedAt": "2021-09-23T23:43:51Z",
      "comments": [
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "We (well, mostly @mnot) have made some good progress on the other issues raised out of #11 but we haven't looked at this one yet.\r\n\r\nAs strawman to get this moving, how about: we register a `problem` URN namespace id, and we recommend that non-dereferenceable URIs should be URNs using that, namespaced with an appropriate domain and raw type id, for example: `urn:problem:example.com:out-of-credit`.\r\n\r\nWould that work? It would give us a clear solution to recommend, which is explicit but easy to read, with minimal extra complexity or overhead for implementers (imo).\r\n\r\nI don't have examples, but I suspect there are other standards elsewhere that would appreciate having a problem id namespace for URNs as well.\r\n\r\nI don't love using a domain for namespacing a non-locator, but I _think_ some namespacing is preferable, and I'm not sure what other namespaces would be suitable. Alternatives very welcome :smile:",
          "createdAt": "2021-08-30T14:48:11Z",
          "updatedAt": "2021-08-30T14:48:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "We penciled in the URI prefix for registered types as \"https://iana.org/assignments/http-problem-types#\" in #7, but that was not finalised.\r\n\r\nI think registering one or more problems as exemplars is a good path forward for this and other issues (e.g., as discussed in #6). We need to be very careful to set a good example in them, which means we need good candidates; I'm thinking 'JSON Validation Error' and 'XML Validation Error' might be appropriate (perhaps along with corresponding wellformedness errors).\r\n\r\nIf we choose a urn, I suspect there will be considerable pressure to use `urn:ietf:params:http:problem:` or something similar, as per [RFC3553](https://www.rfc-editor.org/rfc/rfc3553.html).",
          "createdAt": "2021-08-31T02:40:42Z",
          "updatedAt": "2021-08-31T02:40:42Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-08-31 04:40, Mark Nottingham wrote:\n> If we choose a urn, I suspect there will be considerable pressure to use \n> |urn:ietf:params:http:problem:| or something similar, as per RFC3553 \n> <https://www.rfc-editor.org/rfc/rfc3553.html>.\n\nmy understanding of the \"urn:ietf:params\" namespace is that it is meant \nto be used for parameters managed/defined by IETF specs.\n\ni think the original's suggestion intent was to have a \"safe prefix\" for \na namespace which then would be \"unmanaged\" with some conventions around \nthat, such as using domains names.\n\ni think the idea of giving examples (and even a suggested namespace \nalong with conventions for using it) is a good one. that way we can \nclearly support both scenarios:\n\n- if you're planning on making documentation available, use a resolvable \nURI but keep in mind that this best should be managed in a way so that \nit works for a good number of years.\n\n- if you're planning on just identifying problem types, use a \nnon-resolvable URI, and here's a recipe for doing it.\n",
          "createdAt": "2021-08-31T07:48:45Z",
          "updatedAt": "2021-08-31T07:48:45Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> i think the original's suggestion intent was to have a \"safe prefix\" for a namespace which then would be \"unmanaged\" with some conventions around that, such as using domains names.\r\n\r\n> - if you're planning on making documentation available, use a resolvable URI but keep in mind that this best should be managed in a way so that it works for a good number of years.\r\n> - if you're planning on just identifying problem types, use a non-resolvable URI, and here's a recipe for doing it.\r\n\r\n:+1: exactly\r\n\r\nI think #7 is relevant in that it would be helpful to everybody if we can follow our own recommendations in our own problem id registry, but it's otherwise independent.",
          "createdAt": "2021-08-31T07:52:07Z",
          "updatedAt": "2021-08-31T07:52:07Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-08-31 09:52, Tim Perry wrote:\n> I think #7 <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/7> is \n> relevant in that it would be helpful to everybody if we can follow our \n> own recommendations in our own problem id registry, but it's otherwise \n> independent.\n\nthe difficulty may be that IETF *has* an institutional approach for \nmanaging parameters (urn:ietf:params:http-problems mentioned by @mnot \nabove), whereas most orgs minting problem types probably won't have one \nand won't create one. which may lead to us to saying three things about \nwhat kind of URI to use:\n\n- check out common problem types registered under \nurn:ietf:params:http-problems and consider reusing one if it fits.\n- use URIs when creating dereferencable problem type identifiers.\n- when using non-dereferencable problem type identifiers be clear about \nthat by using non-dereferencable URIs, and here's an URN-based recipe \nhow to do that.\n",
          "createdAt": "2021-08-31T08:20:43Z",
          "updatedAt": "2021-08-31T08:20:43Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> the difficulty may be that IETF *has* an institutional approach for managing parameters (urn:ietf:params:http-problems mentioned by @mnot above), whereas most orgs minting problem types probably won't have one and won't create one. which may lead to us to saying three things about what kind of URI to use:\r\n>  - check out common problem types registered under urn:ietf:params:http-problems and consider reusing one if it fits.\r\n> - use URIs when creating dereferencable problem type identifiers.\r\n> - when using non-dereferencable problem type identifiers be clear about that by using non-dereferencable URIs, and here's an URN-based recipe how to do that.\r\n\r\nAh, I see, ok. Yes, that makes sense, and given that the 3 part recommendation seems reasonable to me. ",
          "createdAt": "2021-08-31T10:43:18Z",
          "updatedAt": "2021-08-31T10:43:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "> my understanding of the \"urn:ietf:params\" namespace is that it is meant\r\nto be used for parameters managed/defined by IETF specs.\r\n\r\nNo, it's for parameter name spaces managed by IETF documents -- which this would be.\r\n\r\nWe could also give an example that uses a `tag` URI.",
          "createdAt": "2021-09-01T01:36:56Z",
          "updatedAt": "2021-09-01T01:36:56Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-09-01 03:37, Mark Nottingham wrote:\n>     my understanding of the \"urn:ietf:params\" namespace is that it is meant\n>     to be used for parameters managed/defined by IETF specs.\n> \n> No, it's for parameter name spaces managed by IETF documents -- which \n> this would be.\n\nthat's what i wanted to say. so these URIs/examples would just cover the \ncommon problem types that would be managed by the spec.\n\n> We could also give an example that uses a |tag| URI.\n\nwhich then would be for those other types that people/orgs are minting \nand where they say these are not resolvable, right? i think for those \nterry proposed a URN namespace instead of tag URIs, but either way it \nsimply would help to state the use case (\"your own types, not intended \nto be resolvable\") and provide a recipe (\"here's one way to do it\").\n\nthe main point seems to be: the spec should mention both \"common types\" \nwhich may even get a registry, and \"private types\" which probably are \nusing a different namespace, and we could suggest one pattern for doing \nthat.\n",
          "createdAt": "2021-09-01T07:11:55Z",
          "updatedAt": "2021-09-01T07:11:55Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU4MDY1MDE2OTU=",
      "title": "Consider discouraging relative path URLs in the 'type' field",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/14",
      "state": "CLOSED",
      "author": "pimterry",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "_Pulling this conversation out of #11:_\r\n\r\nRelative path URLs like `out-of-funds` act counter-intuitively. At first glance, they are some kind of api-global identifier, but in fact they should be considered as a path relative to the current resource, so an `out-of-funds` response from `example.com/buy/123` is a totally distinct error type to an `out-of-funds` response from `example.com/buy/456`.\r\n\r\nThat is likely not what anybody intended. In addition, it appears that almost all implementations of this spec do not take that into account, parsing and comparing type URIs directly, and never using the resource URI that returned it at all.\r\n\r\nThis is a likely footgun for users implementing this spec, and there are easy better alternatives (see #13), so we should highlight that.",
      "createdAt": "2021-02-11T15:33:53Z",
      "updatedAt": "2021-05-25T10:28:37Z",
      "closedAt": "2021-05-25T10:28:37Z",
      "comments": [
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> so an out-of-funds response from example.com/buy/123 is a totally distinct error type to an out-of-funds response from example.com/buy/456\r\n\r\nMinor but important nitpick - sorry! Those two examples are actually the same - the resolved value is `example.com/buy/out-of-funds`. The relative path in this case would replace the final path segment, not append to it.\r\n\r\nA better example could be `example.com/buy/123` vs `example.com/lease/456`.\r\n\r\nThis does fantastically highlight why relative URLs are difficult to use though :)",
          "createdAt": "2021-02-11T16:48:03Z",
          "updatedAt": "2021-02-11T16:48:03Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "Haha, good catch! The same would apply if I'd included a trailing slash too I think: `example.com/buy/123/`. Glad I've successfully illustrated my point though :facepalm:",
          "createdAt": "2021-02-11T17:24:38Z",
          "updatedAt": "2021-02-11T17:24:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this was addressed by #20 - can we close?",
          "createdAt": "2021-05-25T06:59:12Z",
          "updatedAt": "2021-05-25T06:59:12Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "Yes, I think so! :+1:",
          "createdAt": "2021-05-25T10:28:37Z",
          "updatedAt": "2021-05-25T10:28:37Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU4MDY1MDcyNDk=",
      "title": "Provide an indication of whether a type URL is designed to be dereferenced for documentation",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/15",
      "state": "CLOSED",
      "author": "pimterry",
      "authorAssociation": "NONE",
      "assignees": [
        "dret"
      ],
      "labels": [],
      "body": "_Pulling this conversation out of #11:_\r\n\r\n* The current spec allows any type URLs to be used, and there's no strong requirement that they link to documentation, it's just encouraged.\r\n* As an API client, it can be useful to be able to automatically find human-readable documentation relevant to an error response.\r\n* Right now, the only way to do that is to dereference every type URL to see if it goes to a documentation resource, but a) that's discouraged by the spec (type URIs should not be dereferenced automatically) and b) it's not very efficient for anybody involved.\r\n\r\nAs an example, Zolando's [API design guidelines](https://opensource.zalando.com/restful-api-guidelines/#176) specify that:\r\n\r\n> Problem type and instance identifiers in our APIs are not meant to be resolved. RFC 7807 encourages that custom problem types are URI references that point to human-readable documentation, but we deliberately decided against that, as all important parts of the API must be documented using OpenAPI anyway. In addition, URLs tend to be fragile and not very stable over longer periods because of organizational and documentation changes and descriptions might easily get out of sync.\r\n\r\nAll their API responses use absolute path types to deal with this, like `\"type\": \"/problems/out-of-stock\"`, which intentionally go nowhere. This is allowed by our current spec, but makes life difficult for those of us who want to automatically find documentation from arbitrary problem detail responses.\r\n\r\nIt would be useful to provide an explicit way to link to documentation in these cases, or to make it clear that no documentation is available.",
      "createdAt": "2021-02-11T15:40:24Z",
      "updatedAt": "2021-09-08T05:06:48Z",
      "closedAt": "2021-09-08T05:06:48Z",
      "comments": [
        {
          "author": "serialseb",
          "authorAssociation": "NONE",
          "body": "With identification using URIs, you never quite know if it is a document or just a reference to a concept. Any person that followed httpRange-14 back in the days knows that this is hard.\r\nThat said, the scenarios are multiple:\r\n1. Identification only relies on expanding a uri to its full form (from a basue uri for any uri), and checking it against a known value\r\n2. can i learn anything from it, which is a \"follow your nose\" first principle: click on it, see if anything comes out\r\n\r\nIf you were to add a \"documentation\" uri, i have no more guarantee that anything usefull will come out of it rather than following my nose to the original type, so I'm not sure Im gaining a lot from a predictability perspective.\r\n\r\nIf the main operator is human, then a documentation URI would only make sense because it overrides the main URI, which would only be done if said URI is not in control of the operator that published said URI. This seems unlikely to me, but I could see a scenario where you want, on your own API, to provide your own documentation for that `type` above and beyond from the one that would be provided by the provider of that error. \r\nI'm not sure what i think about that capacity, to say that \"in our realm, we don't do things the way they said, we got our own\". It's an open question for me.\r\n\r\nIf the main operator is a machine, then just a URI seems insufficient, especially as the override i mentioned above would be needed per type of automate-able documentation one could retrieve.",
          "createdAt": "2021-03-12T19:30:03Z",
          "updatedAt": "2021-03-12T19:30:03Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "> If the main operator is human, then a documentation URI would only make sense because it overrides the main URI, which would only be done if said URI is not in control of the operator that published said URI\r\n\r\nIn that case, I wonder if a Link header - with `rel=\"help\"` maybe? - would be a better way of achieving that? That way the actual problem payload doesn't change just because some server wants to indicate that human-readable documentation about the problem exists somewhere different to the provided URI.",
          "createdAt": "2021-03-12T19:42:02Z",
          "updatedAt": "2021-03-12T19:42:13Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "jumping in to hopefully make some progress with this:\r\n- \"automatically\" following type links (as mentioned by @pimterry) isn't a great idea, since this may cause the well-known problem of overwhelming the server of the type URI. that's why RFC 7807 says that \"Consumers SHOULD NOT automatically dereference the type URI.\"\r\n- instead of adding a specific \"hint\", we could add language saying that if you want your type URIs not to be dereferencable, just create them that way, for example by using URNs (or similar URI schemes).\r\nthat way, we could one the one had provide guidance for those who want to create dereferencable URIs (make them absolute) and for those not wanting dereferencable URIs (do not use relative URIs but instead use URI schemes that have no associated dereferencing mechanism, such as URN URIs).",
          "createdAt": "2021-05-31T13:10:21Z",
          "updatedAt": "2021-05-31T13:10:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "> we could add language saying that if you want your type URIs not to be dereferencable, just create them that way, for example by using URNs (or similar URI schemes).\r\nthat way, we could one the one had provide guidance for those who want to create dereferencable URIs (make them absolute) and for those not wanting dereferencable URIs (do not use relative URIs but instead use URI schemes that have no associated dereferencing mechanism, such as URN URIs).\r\n\r\nSo, what if I create a problem type that I originally intend not to be deref'd, but down the road I need it to be?\r\n\r\nIt seems to me that the harm in always using dereferenceable URLs is pretty minimal/manageable --\r\n\r\n1. People who try will get 404's (for HTTP URLs)\r\n2. Domain name ownership is a thing (for schemes based on DNS)\r\n\r\nSo an alternative would be to recommend using HTTPS URLs in most cases, with a proviso that sometimes they won't be resolvable (something a person can discover at their convenience), and that for standard / widely-used codes, a HTTP URL that's stable (possibly provided by IANA, as per #7) is wise.\r\n\r\nRelated to #13.",
          "createdAt": "2021-07-14T05:27:25Z",
          "updatedAt": "2021-07-14T05:27:25Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> So an alternative would be to recommend using HTTPS URLs in most cases, with a proviso that sometimes they won't be resolvable (something a person can discover at their convenience)\r\n\r\nWe can recommend this, but it seems likely that most problem types will still intentionally not be resolvable, unless it's a hard requirement. The Zalando style guide specifically encourages that it should do so, and discussion elsewhere - it seems that API developers (for some good reasons, e.g. uncoupling type ids from doc URLs) want to use unresolveable type URLs, independent of their documentation URLs.\r\n\r\nAs a tool author, that means I'm going to have to automatically dereference every problem details type URL every time I receive such a response. That's not great for anybody.\r\n\r\nI want to _automatically_ find a working URL for problem documentation, every time a problem is received. In my case, I'm working on an HTTP debugger where that's especially relevant, but you can imagine many other use cases, e.g. in low-level libraries or clients, perhaps an HTTP library that throws clear friendly exceptions to help with debugging every time it receives a problem details response, something like:\r\n\r\n> Request to https://example.com/your-url failed unexpected with status 403:\r\n> \r\n> You do not have enough credit.\r\n> Your current balance is 30, but that costs 50.\r\n> \r\n> For more information, see the https://example.com/probs/out-of-credit\r\n\r\nThe problem is in the last line. If that goes to a 404 (likely to happen in many cases) it's a very poor user experience for the end developer looking at their error logs, who's just been told that it's working documentation. Tools/libraries will reasonably want to avoid that experience as much as possible - the only current way to do so is to dereference every problem URL when it's received, or to never try to link to documentation at all.\r\n\r\nIf this is a use case we just don't want to support in this RFC then that's not totally unreasonable, and we could just close this. It seems like we're very close to machine-discoverable problem documentation here though, and personally I'd find that very useful.\r\n\r\n> what if I create a problem type that I originally intend not to be deref'd, but down the road I need it to be?\r\n\r\nThis is another separate good reason why imo it'd be useful to have a explicit and independent way to link to problem details documentation from a response (e.g. a link header, a separate field, etc etc)",
          "createdAt": "2021-07-23T17:21:53Z",
          "updatedAt": "2021-07-23T17:21:53Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "Here's an interesting detail. If there was some way to determine that a problem URI was resolvable, *and it resolves to a redirect* then what does that mean?\r\n\r\nI ask this because the comment I was originally going to make was about dead documentation links. I could make a problem URI today that is resolvable, but there's no guarantee that it will still be resolvable in the future. Or, worse, it might just resolve to the wrong thing.\r\n\r\nAnd that then got me thinking about other ways that URIs can resolve to the wrong things, and redirects seems a particularly awkward one.\r\n\r\nI would *assume* that it doesn't mean anything, and that the URI as written in the payload is the one to use. But equally, I can see an argument that two different URIs that both resolve as redirects to the same thing could be considered as the same problem, and that just makes life awkward.",
          "createdAt": "2021-07-23T17:28:38Z",
          "updatedAt": "2021-07-23T17:28:38Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Performing HTTP redirection from the `type` URI to documentation is actually [what I recommend](https://youtu.be/ZWIUn5BHDBc?t=587), since what's used in `problem+json` is supposed to be a stable identifier, while the URI of a documentation site may be generated by a CMS and thus probably can't be considered stable.\r\n\r\nI've never even **considered** that a URI comparison implementation could perform an HTTP request against the two URIs and see whether they, after HTTP redirection and whatnot, resolve to the same URI. \r\n\r\nUsing resolvable URIs that perform HTTP redirection as identifiers is common. The whole of [Dublin Core](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/#http://purl.org/dc/terms/abstract) does it, for instance: [`http://purl.org/dc/terms/abstract` ](http://purl.org/dc/terms/abstract) redirects to [`https://dublincore.org/specifications/dublin-core/dcmi-terms/#abstract` ](https://dublincore.org/specifications/dublin-core/dcmi-terms/#abstract). The former is the canonical identifier, the latter is the documentation about the identifier.",
          "createdAt": "2021-07-23T20:32:32Z",
          "updatedAt": "2021-07-23T20:36:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Whether or not it resolves to a redirect doesn't change the problem identified by the type URI. If folks believe otherwise, please open a separate issue.\r\n\r\n@pimterry I see what you're saying regarding tool user experience. I'm not against this, I could see us adding a member with a boolean value whose semantic is 'here's a hint that the type URI is resolvable'; I could also see us adding a member with a separate URI for documentation. \r\n\r\nHowever, two things come to mind:\r\n\r\n1. Even if the problem says that the URL is resolvable, it still might not be (e.g., network failure, server-side issue, etc.).\r\n2. Some problems are going to omit this signal even when the URL is resolvable -- either because they don't know about the signal, or they don't care.\r\n\r\nBoth of these reduce the quality of the information that the signal conveys. What I think we need to establish is whether it still conveys enough information to be worth the extra effort and complication.*\r\n\r\nIf we don't have this sort of signal, I think a tool such as the one you're talking about will need to present it as something like:\r\n\r\n~~~\r\nRequest to https://example.com/your-url failed unexpected with status 403:\r\n\r\nYou do not have enough credit.\r\nYour current balance is 30, but that costs 50.\r\n\r\nMore documentation might be available at: https://example.com/probs/out-of-credit\r\n~~~\r\n\r\nAlternatively, you could attempt to resolve the URI and then cache the result, avoiding the need to make a request for every problem instance. To facilitate that, it might be interesting to put some bounds on how cacheable these type URIs are...\r\n\r\nEither way, we should qualify the 'automatically' prohibition against resolving the URI to make it applicable to runtime resolution, not debug time.\r\n\r\nThoughts?\r\n\r\n---\r\n\r\n\\* I find that an often under-appreciated aspect of APIs is the cognitive load they place upon users; if there are too many options, they're less likely to use what's available well. \r\n\r\n",
          "createdAt": "2021-07-26T03:53:52Z",
          "updatedAt": "2021-07-26T03:53:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "One other aspect of this that we haven't discussed: if we're talking about adding a new member that's valid and standard across all problem objects, it violates this statement in 7807:\r\n\r\n> Note that because extensions are effectively put into a namespace by the problem type, it is not possible to define new \"standard\" members without defining a new media type.\r\n\r\nSo if we decide that this is a must-have, we'll need to either define a new media type for problem types, or convince ourselves that defining such an extension won't break currently deployed extensions (without being able to know their breadth).",
          "createdAt": "2021-07-26T04:18:59Z",
          "updatedAt": "2021-07-26T04:18:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 111: default resolvable is good. Not a strong motivation for a 'doesn't resolve' flag; close with no action (except perhaps prose).",
          "createdAt": "2021-07-27T22:11:11Z",
          "updatedAt": "2021-07-27T22:11:11Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "> Discussed in 111: default resolvable is good\r\n\r\nSounds good to me.\r\n\r\nIf we can strengthen the spec from gentle encouragement to \"if the type is dereferenceable, it SHOULD resolve to documentation\" (or similar) and qualify the \"Consumers SHOULD NOT automatically dereference the type URI\" text as [discussed above](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/15#issuecomment-886351420), then my use case [above](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/15#issuecomment-885786041) should work reliably with no extra fields required, which would be great.\r\n\r\nThis then ties into #13 & #21: we should give a clear recommendation for an alternative, for those who do want explicitly non-resolvable types.\r\n\r\nDoes all this apply the same to `instance`? That currently doesn't state a position on this at all: \"It may or may not yield further information if dereferenced\"",
          "createdAt": "2021-07-28T10:21:23Z",
          "updatedAt": "2021-07-28T10:21:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-07-28 12:21, Tim Perry wrote:\n> Does all this apply the same to |instance|? That currently doesn't state \n> a position on this at all: \"It may or may not yield further information \n> if dereferenced\"\n\nwouldn't that be odd? the type URI probably mostly will be used for \ncomparing to some known type URIs. the instance URI on the other hand \nprobably most often will provide access to info analyzing the specific \nreasons for the problem, no?\n",
          "createdAt": "2021-07-28T13:00:33Z",
          "updatedAt": "2021-07-28T13:00:33Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "It's just that the same ambiguity applies: is `http://example.com/failed-transactions/123` intended as a link to a resource the receiver should visit for more information about that specific transaction, or intended only as an opaque identifier?\r\n\r\nIt's quite plausible that the situation isn't the same as `type`, and that's OK. It's not really as important for tooling AFAIK (I imagine tools are all more likely to be interested in linking to human-readable documentation than the failing resource itself, which could be anything) and I don't have a strong opinion either way.\r\n\r\nIf we do think both should be treated similarly (i.e. both should be resolvable by default) then that's neat and we can use consistent recommendations throughout. If not then that's fine too - we just need to make it clear that they're different (and if this is the case, I think the current text does that OK).\r\n\r\nEither way I think an answer #13 for `instance` as well as `type` would be nice, so that it's clear what to do if you want either to be explicitly not resolvable, but that's just offering an optional suggestion, not a constraint.",
          "createdAt": "2021-07-28T13:41:10Z",
          "updatedAt": "2021-07-28T13:41:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "See proposal in #26 - thoughts?",
          "createdAt": "2021-08-27T03:30:12Z",
          "updatedAt": "2021-08-27T03:30:12Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU4NDUzMTI4NzI=",
      "title": "Deprecating media type?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/16",
      "state": "CLOSED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": ">Note that because extensions are effectively put into a namespace by the problem type, it is not possible to define new \"standard\" members without defining a new media type\r\n\r\n@mnot Pardon my ignorance here...what was the reason to tie \"standard\" members with a media type and not with schema (at least for JSON and XML)? It locks the definition but it also makes it extremely difficult to evolve. Should this be revisited? \r\n\r\nIt would be much easier to resolve #6 and #8 if we could made backward-compatible changes to schemas. \r\n\r\n",
      "createdAt": "2021-03-30T21:37:56Z",
      "updatedAt": "2023-04-22T17:51:55Z",
      "closedAt": "2021-05-25T13:24:39Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The media type advertises that the content is of a certain format; if you make backwards-compatible changes to that, you're going to break some processors. ",
          "createdAt": "2021-03-30T21:50:30Z",
          "updatedAt": "2021-03-30T21:50:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Is there something actionable here, or can we close this?",
          "createdAt": "2021-04-26T06:14:11Z",
          "updatedAt": "2021-04-26T06:14:11Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "i am still struggling with this a little. i am assuming this actually talks about forward-compatible changes, i.e. an updated format processed by old processors. i am not sure what the title of this issue refers to looking at the comments, though. but it seems that following the usual practice of not making \"breaking changes\" should be fine, right? this means not changing any definitions of the existing members, and only adding members that can be safely ignored.",
          "createdAt": "2021-04-27T07:23:16Z",
          "updatedAt": "2021-04-27T07:23:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sorry, I should have typed backwards _in_compatible changes. Compatible changes are fine. ",
          "createdAt": "2021-04-27T07:26:45Z",
          "updatedAt": "2021-04-27T07:26:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, can we close?",
          "createdAt": "2021-05-25T06:53:52Z",
          "updatedAt": "2021-05-25T06:53:52Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU4NjcyMjExMjA=",
      "title": "Handling invalid problem objects",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/19",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mnot"
      ],
      "labels": [],
      "body": "From https://www.rfc-editor.org/errata/eid5515 :\r\n\r\nJSON objects with a null \"type\" are syntactically correct, but there is no information on how it should be handled.\r\n\r\n{\r\n\"type\": null,\r\n\"status\": 404,\r\n\"title\": \"Not Found\"\r\n}\r\n\r\nIt makes sense to treat null as an alias of \"about:blank\" and that's how I think it should be documented.",
      "createdAt": "2021-04-26T03:30:48Z",
      "updatedAt": "2021-09-21T07:42:26Z",
      "closedAt": "2021-09-21T07:42:26Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that the errata above is only `Reported`.\r\n\r\nMy .02 -- if `type` is `null`, it's invalid, _not_ \"syntactically correct\"; it's specified to be a string, and if someone assumes that `null` has semantics, that's not currently specified behaviour. So the real question here is whether the default of `about:blank` is assumed when the value is invalid, or whether some other error handling comes into play.\r\n\r\nI think the safest thing to do would _not_ be to assume that `null` implies `about:blank` -- i.e., no change to the spec.",
          "createdAt": "2021-04-26T03:33:35Z",
          "updatedAt": "2021-04-26T03:33:35Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since this is a specification of a format for error messages, I believe it is important that the processing of the error message is clear and lenient so the processing itself does not cause errors, possibly shrouding the initial error that caused the `application/problem+json` response in the first place.\r\n\r\nI therefore think the specification should be explicit that all erroneous values (such as `\"type\": null`, `\"status\": \"invalid\"`, `\"detail\": 123`, etc.) should be ignored and treated as the default value of each member, which for `type` equals to `about:blank`, but for other members equal to an empty string(?).",
          "createdAt": "2021-04-26T04:58:21Z",
          "updatedAt": "2021-04-26T04:58:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I agree; changing issue title.",
          "createdAt": "2021-04-26T06:13:15Z",
          "updatedAt": "2021-04-26T06:13:15Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU5MDgzNjIyMDc=",
      "title": "provide guidance for intentionally non-dereferencable URIs",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/21",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#11 provides good guidance in terms of probably bets avoiding relative URIs. what about also providing guidance for people who intentionally want to use non-dereferencable URIs for `type` or `instance`? should we add some guidance for this as well? we had some discussion around `tag` URIs in #11 and there are other possibilities as well. but the main question is: if somebody never intends to use dereferencable URIs for `type` or `instance`, should we mention that and provide guidance?",
      "createdAt": "2021-06-01T14:35:54Z",
      "updatedAt": "2021-07-29T02:02:34Z",
      "closedAt": "2021-07-29T02:02:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this a duplicate of #13?",
          "createdAt": "2021-07-14T05:22:49Z",
          "updatedAt": "2021-07-14T05:22:49Z"
        },
        {
          "author": "pimterry",
          "authorAssociation": "NONE",
          "body": "I think this is indeed a duplicate",
          "createdAt": "2021-07-28T10:21:24Z",
          "updatedAt": "2021-07-28T10:21:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now; if there's a reason to distinguish it we can reopen.",
          "createdAt": "2021-07-29T02:02:34Z",
          "updatedAt": "2021-07-29T02:02:34Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU5NzU0MTU3NDg=",
      "title": "Cardinality of problem details object members",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/25",
      "state": "CLOSED",
      "author": "tdonker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "When reading:\r\n\r\nhttps://ietf-wg-httpapi.github.io/rfc7807bis/draft-ietf-httpapi-rfc7807bis.html\r\n\r\nit's not entrirely clear which member field of the problem details object (type, status, title, detail, instance) is mandatory and which is optional. Is it correct to state that only the 'type' member is mandatory and all others are optional?",
      "createdAt": "2021-08-20T09:05:05Z",
      "updatedAt": "2023-04-22T17:48:18Z",
      "closedAt": "2021-09-08T05:06:06Z",
      "comments": [
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "As I understand it, none of them are mandatory.\r\n\r\nUnder `type` it states:\r\n> When this member is not present, its value is assumed to be \"about:blank\".\r\n\r\nUnder `status` it states: (Emphasis mine)\r\n> The \"status\" member, **if present**, is only advisory\r\n\r\nUnder `title` it states:\r\n> The \"title\" string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them\r\n\r\nUnder `detail` it states: (Emphasis mine)\r\n> The \"detail\" member, **if present**\r\n\r\nAnd `instance` doesn't actually say anything one way or the other, but I've always assumed it's present only if there is anything to include.",
          "createdAt": "2021-08-20T09:20:15Z",
          "updatedAt": "2021-08-20T09:20:15Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, all of them are optional and `type` has a default value.",
          "createdAt": "2021-08-20T09:27:13Z",
          "updatedAt": "2021-08-20T09:27:13Z"
        },
        {
          "author": "tdonker",
          "authorAssociation": "NONE",
          "body": "Thanks for the quick reply. The cardinality of the 'type' member made doubt a little bit - but thats clear now.",
          "createdAt": "2021-08-20T09:31:10Z",
          "updatedAt": "2021-08-20T09:31:10Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "I'm not 100% sure I agree that they all *should* be optional. In some ways\nthat makes it just a little bit harder to work with, since the spec defines\n5 fields that are all optional and allows you to add arbitrary other fields\nas well it means that almost any JSON object is a valid Problem Details\nobject. The only actual rules end up being \"Any fields that have these 5\nnames must have the correct meaning\" and nothing else can be relied upon.\n\nFor example, the following is a perfectly legal response:\n```\nHTTP/1.1 404 Not Found\nContent-Type: application/problem+json\n\n{\n    \"id\": \"12345\"\n}\n```\n\nOn Fri, 20 Aug 2021 at 10:40, Ton Donker ***@***.***> wrote:\n\n> Closed #25 <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/25>.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/25#event-5185848490>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGB5CI3JXABOOEWYZ2LT5YPHBANCNFSM5CP45WOQ>\n> .\n>\n",
          "createdAt": "2021-08-20T10:06:34Z",
          "updatedAt": "2021-08-20T10:06:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think we can change that, @sazzer, without changing the media type for the format, so it's probably out of scope for this effort.",
          "createdAt": "2021-08-27T03:31:36Z",
          "updatedAt": "2021-08-27T03:31:36Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOE-NsGs49SA2C",
      "title": "Extension to show source of problem in request for 4xx class of errors",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/32",
      "state": "CLOSED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "Example added for multiple problems shows use of an extension called `property_location` which is a JSON Pointer RFC6901 that points to the source of the problem in the corresponding HTTP request. Such an extension could only be used to show source of problem in 4xx class of errors such as Bad Request. HTTP request validation errors are the most common and most frequent client side error in HTTP APIs. \r\n\r\nOpening this issue on suggestion of @asbjornu...\r\n\r\n>Although property_location is just added as an example extension, having it in the specification gives it weight and authority. For something like this to be added (even if only as an extension to an example) I think it needs to be thoroughly discussed in a separate issue first.",
      "createdAt": "2021-10-16T19:41:15Z",
      "updatedAt": "2023-04-22T17:47:00Z",
      "closedAt": "2022-05-17T00:15:21Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-16 21:41, Sanjay Dalal wrote:\n> Example added for multiple problems shows use of an extension called \n> |property_location| which is a JSON Pointer RFC6901 that points to the \n> source of the problem in the corresponding HTTP request. Such an \n> extension could only be used to show source of problem in 4xx class of \n> errors such as Bad Request. HTTP request validation errors are the most \n> common and most frequent client side error in HTTP APIs.\n\nstill agreeing with @asbjornu that the examples may not be the best \nplace to try to be creative in ways that need a lot of explanation. \nafter all, we want to show how to use the spec and not speculate about \nwhat people might add on.\n\niff we go the creative route, my preferred naming choice would be \nsomething along the lines of \"problem-pointer\" to leave it independent \nof the payload format and relate it to the name of the problem spec.\n",
          "createdAt": "2021-10-17T10:21:25Z",
          "updatedAt": "2021-10-17T10:21:25Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense. +1\r\n\r\n>iff we go the creative route, my preferred naming choice would be\r\nsomething along the lines of \"problem-pointer\" to leave it independent\r\nof the payload format and relate it to the name of the problem spec.",
          "createdAt": "2021-10-17T16:09:01Z",
          "updatedAt": "2021-10-17T16:09:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Can this be closed?",
          "createdAt": "2021-11-12T11:36:32Z",
          "updatedAt": "2021-11-12T11:36:32Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-11-12 12:36, Mark Nottingham wrote:\n> Can this be closed?\n\ni think so since we haven't seen an actual proposal for this.\n",
          "createdAt": "2021-11-12T11:50:54Z",
          "updatedAt": "2021-11-12T11:50:54Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Hold on please. I have given example in https://github.com/ietf-wg-httpapi/rfc7807bis/issues/32. Not sure if additional proposal was needed. ",
          "createdAt": "2021-11-12T12:25:30Z",
          "updatedAt": "2021-11-12T12:25:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Note that adding a new member has potential issues; see https://github.com/ietf-wg-httpapi/rfc7807bis/issues/15#issuecomment-886360909",
          "createdAt": "2022-02-07T01:10:29Z",
          "updatedAt": "2022-02-07T01:10:29Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "We seem to be in a catch-22 here.  We can't add it as a standard property in the specification because that would require a new media type and it has been asserted that we should not use examples to suggest how people might extend the specification.\r\n\r\nWhere does this leave us?  Should we consider a complementary \"best practices\" document that suggests ways in which errors could be extended?  Would this also help to address the multiple problems issue? #6  ",
          "createdAt": "2022-03-19T21:12:26Z",
          "updatedAt": "2022-03-19T21:12:26Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "It seems to me that there should have been a mechanism for forward compatibility. For example, that non-standard/user keywords must be a (full) URI, and names (e.g. `/[a-z0-9]+/`) have a standard meaning. If we can't do that without breaking backward compatibility, well then I don't see a problem with a new media type.",
          "createdAt": "2022-03-20T20:39:50Z",
          "updatedAt": "2022-03-20T20:39:50Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "my vote still goes to avoiding speculative examples. the built-in extension mechanism (https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-rfc7807bis#section-3.2) provides for forward compatibility, @awwright, as long as you don't make any of the things that are added later mandatory. and either way, since RFC 7807 defined no such more specific mechanism, we cannot add one now without breaking things.",
          "createdAt": "2022-03-23T16:54:44Z",
          "updatedAt": "2022-03-23T16:54:44Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@dret Not to get this thread too off-topic, I filed #36 in response",
          "createdAt": "2022-03-23T20:13:16Z",
          "updatedAt": "2022-03-23T20:13:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Agree that #36 blocks this.\r\n\r\nIF we do this, we'd need conventions for at least XML and JSON, I think -- which means that something more than just `problem-pointer` is necessary. ",
          "createdAt": "2022-03-24T03:30:02Z",
          "updatedAt": "2022-03-24T03:30:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I started to rough this in. Working out the details made me realise this isn't a very good fit for a generic, standard member that's defined across *all* problem types, because:\r\n\r\n* it's format-specific; we'll need to define e.g., `json-pointer` and `xml-pointer` for those formats; other formats will have to define their own\r\n* it's specific to problem types that are about request state; it doesn't apply to problems that are about server-side state, for example\r\n* it's specific to problems that have exactly one location in the request that triggers the issue\r\n\r\nInstead, I think the example we have is sufficient, and we should close with no further action.",
          "createdAt": "2022-05-11T01:18:20Z",
          "updatedAt": "2022-05-11T01:18:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@sdatspun2 does that work for you?",
          "createdAt": "2022-05-16T03:53:38Z",
          "updatedAt": "2022-05-16T03:53:38Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "@mnot Sorry for lateness. The example may work... for now. However, I also agree with @darrelmiller. For a graceful evolution of this spec, we need figure out if requirements like the 4xx errors or multiple problems should be handled by defining a new media type or there could be some other way which is not as restricting (good and bad). I am not sure if the \"best practices\" document helps here, it will not be a standard. If new media type, I would think that it would need to evolve in future too so it has to be defined with that requirement in mind. Should there be a corresponding media type for problem type schema which can be referred from the existing media type?\r\n\r\n>We seem to be in a catch-22 here. We can't add it as a standard property in the specification because that would require a new media type and it has been asserted that we should not use examples to suggest how people might extend the specification.\r\n\r\nWhere does this leave us? Should we consider a complementary \"best practices\" document that suggests ways in which errors could be extended? ",
          "createdAt": "2022-05-17T00:03:35Z",
          "updatedAt": "2022-05-17T00:03:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": ">  we need figure out if requirements like the 4xx errors or multiple problems should be handled by defining a new media type or there could be some other way which is not as restricting (good and bad). \r\n\r\nThose are separate issues. Do we need to resolve them to ship *this* document (keeping in mind that we now have a path for future standard extensions to be defined)?\r\n\r\n> Should we consider a complementary \"best practices\" document that suggests ways in which errors could be extended?\r\n\r\nI don't think that's necessary; what's important is that we build a community where those things can be discussed.\r\n\r\n",
          "createdAt": "2022-05-17T00:15:12Z",
          "updatedAt": "2022-05-17T00:15:12Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOE-NsGs5DE_Xi",
      "title": "Requiring a specification document",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/34",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently:\r\n\r\n> A Designated Expert reviews and approves registration requests, as per {{RFC8126, Section 4.5}}. A specification document is appreciated, but not required.\r\n\r\nThat doesn't seem like a recipe for good interop. While it doesn't need to be an RFC, _some_ sort of reference is necessary...",
      "createdAt": "2022-02-07T01:00:37Z",
      "updatedAt": "2022-03-24T20:47:38Z",
      "closedAt": "2022-03-24T20:47:38Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sorry, but I don't quite understand what is being referred to here. Is the quoted paragraph from RFC7807? Because I can't find it. Without more context I also don't quote understand what it is referring to.",
          "createdAt": "2022-02-07T10:49:55Z",
          "updatedAt": "2022-02-07T10:49:55Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "@asbjornu: https://ietf-wg-httpapi.github.io/rfc7807bis/draft-ietf-httpapi-rfc7807bis.html#name-registered-problem-types",
          "createdAt": "2022-02-07T11:22:23Z",
          "updatedAt": "2022-02-07T11:22:23Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOE-NsGs5DE_26",
      "title": "Mapping problem details into a header?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/35",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header_field"
      ],
      "body": "Should we define a header that can carry problem details? \r\n\r\nE.g., for the first example in the spec:\r\n\r\n~~~ json\r\n{\r\n \"type\": \"https://example.com/probs/out-of-credit\",\r\n \"title\": \"You do not have enough credit.\",\r\n \"detail\": \"Your current balance is 30, but that costs 50.\",\r\n \"instance\": \"/account/12345/msgs/abc\",\r\n \"balance\": 30,\r\n \"accounts\": [\"/account/12345\",\r\n              \"/account/67890\"]\r\n}\r\n~~~\r\n\r\na workable mapping might be to use [Structured Fields](https://www.rfc-editor.org/rfc/rfc8941.html) to represent the top-level members of the object, like this:\r\n\r\n~~~\r\nProblem-Details: type=\"https://example.com/probs/out-of-credit\", \r\n          title=\"You do not have enough credit.\", \r\n          detail=\"Your current balance is 30, but that costs 50.\", \r\n          instance=\"/account/12345/msgs/abc\", \r\n          balance=30\r\n~~~\r\n\r\nThat drops any extensions that are not simple values, but I think that's a reasonable tradeoff...\r\n\r\nWould this be useful?",
      "createdAt": "2022-02-07T01:04:12Z",
      "updatedAt": "2023-04-22T17:43:53Z",
      "closedAt": "2022-05-11T01:10:26Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting idea! Asking for some community feedback here: https://twitter.com/dret/status/1490617958305042433",
          "createdAt": "2022-02-07T09:27:11Z",
          "updatedAt": "2022-02-07T09:27:11Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the idea. Would it be a problem (\ud83e\udd41) to name the header just `Problem`?",
          "createdAt": "2022-02-07T10:15:21Z",
          "updatedAt": "2022-02-07T10:15:21Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unfortunately, structured fields do not work well with prose if it uses non-ASCII characters...",
          "createdAt": "2022-02-07T10:30:59Z",
          "updatedAt": "2022-02-07T10:30:59Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "\"not well\" or \"not at all\", @reschke? https://datatracker.ietf.org/doc/html/rfc8941#section-4.1.6 sounds a bit like the latter unless we'd go through the effort of defining a specific mapping for non-ASCII characters. it would be an option to restrict values to ASCII for the `Problem` field, but that would not be great in terms of i18n support.",
          "createdAt": "2022-02-07T10:36:00Z",
          "updatedAt": "2022-02-07T10:36:00Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"not well\" in that we would need to allow byte sequences (https://www.rfc-editor.org/rfc/rfc8941.html#name-byte-sequences) in addition to strings.",
          "createdAt": "2022-02-07T11:27:37Z",
          "updatedAt": "2022-02-07T11:27:37Z"
        },
        {
          "author": "vasilakisfil",
          "authorAssociation": "NONE",
          "body": "Can someone clarify what we are trying to solve with this suggestion? ",
          "createdAt": "2022-02-07T20:39:10Z",
          "updatedAt": "2022-02-07T20:39:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "In the past, some have expressed a desire to convey problem details outside the body of the response, for whatever reason. This would facilitate that, in a limited fashion.",
          "createdAt": "2022-02-08T00:04:16Z",
          "updatedAt": "2022-02-08T00:04:16Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "Could the example in the first post, be used together with [HTTP 402](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402)?",
          "createdAt": "2022-02-09T10:45:20Z",
          "updatedAt": "2022-02-09T10:45:20Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "This seems like it would be a potential solution to the the topic of \"warnings\" that keeps coming back.  I am assuming that returning `Problem-Details` header with a 2XX status code would be allowed.  Although, I am a little terrified about the potential for abuse with that.",
          "createdAt": "2022-03-04T19:39:39Z",
          "updatedAt": "2022-03-04T19:39:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @andrecedik",
          "createdAt": "2022-03-06T19:17:18Z",
          "updatedAt": "2022-03-06T19:17:18Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the past, some have expressed a desire to convey problem details outside the body of the response, for whatever reason. This would facilitate that, in a limited fashion.\r\n\r\nI am curious about the use cases where error would be sent in header and rest of the goods would be sent in response body or in some cases errors are sent in response body and sometimes they are not. I wonder how the developer experience would be in consuming such an API. \r\n\r\nThis could be explored to convey warnings though, I agree with @darrelmiller.",
          "createdAt": "2022-03-07T13:59:26Z",
          "updatedAt": "2022-03-07T13:59:26Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "Thank you for the ping @dret\r\n\r\nI agree with @sdatspun2 \r\n> This could be explored to convey warnings though\r\n\r\nYes, it is basically what we were trying to achieve with our I-D \"[Communicating Warning Information in HTTP APIs](https://datatracker.ietf.org/doc/draft-cedik-http-warning/)\". Although in the I-D we named the header `Content-Warning` (but that's \"just naming things\") - and we were trying to return the warning information in the body. Which brings us to the matter of developer experience, that @sdatspun2 was writing about. \r\n\r\nTBH, it still feels weird to have problem details in the body and warnings in the header. Shouldn't both be in the body or both in a header? But maybe that is just my own stubbornness.\r\n\r\nAnyway - it's very confusing when you can return data in either the body or in a header or - god forbid - in both at the same time. Who knows maybe someone will even put different content in each. Which is probably what @darrelmiller was thinking about when he's thinking about abuse.\r\n\r\n...\r\n\r\nI've been thinking about this the whole day and I've come to the conclusion that there is probably only one solution.\r\n\r\n**Problem Details in the body. Warning Details in a header**\r\nThis way problem details are being transmitted the same way the original RFC proposed. There is no confusion, because problem details can be in the body or not. If there is a warning it can be transmitted as a header, thus keeping the integrity of the original RFC. \r\n\r\nThere's probably one caveat. In my mind there's always the use case where multiple warnings are being returned. This could lead to problems when the value gets too big for a server to handle. \r\n\r\nWhich is why I'd love to have the warnings in the body. One can simply return more data in the body. Also, having one \"severity level of information\" in the body and another one on a header feels weird to me, maybe this is a compromise I'll have to make.\r\n\r\nAll the other options don't seem feasible, due to the side effects stated above. \r\n\r\n---\r\n\r\n@mnot do you have insights into the use cases for having problem details in the header? The only reason that comes to my mind is when a \"204 - No Content\" response is being returned. Then it wouldn't seem right to have problem details being returned as the only content.",
          "createdAt": "2022-03-10T19:35:54Z",
          "updatedAt": "2022-03-10T19:35:54Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "liking @andrecedik's reasoning here which could mean for RFC7807bis to potentially subsume the https://datatracker.ietf.org/doc/html/draft-cedik-http-warning-02 draft (probably renaming the header field but using the same general idea). or we could stay the course, stick with RFC 7807's model of content-only, and possibly revive and better align the http-warning draft, potentially even adopting the `Problem` name suggestion made by @asbjornu. i kind of like the second option better so that RFC7807bis stays lean and mean without adding too many new things.",
          "createdAt": "2022-03-23T17:11:16Z",
          "updatedAt": "2022-03-23T17:11:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If we think that this is going to be done / get used, we should probably do it now, to avoid the overhead of opening another spec.\r\n\r\nThat said, I don't see a strong response -- I'm happy to leave this floating as an idea that we might get to one day if demand eventuates.",
          "createdAt": "2022-03-24T03:28:38Z",
          "updatedAt": "2022-03-24T03:28:38Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "What if I want to transmit multiple problems\u2014for example, what if I'm operating a gateway and I want to add a problem header without changing the semantics of an existing upstream one? Shouldn't the fields be delimited with a semicolon `;`?",
          "createdAt": "2022-03-25T18:36:34Z",
          "updatedAt": "2022-03-25T18:36:34Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrecedik,\r\n\r\n> TBH, it still feels weird to have problem details in the body and warnings in the header. Shouldn't both be in the body or both in a header? But maybe that is just my own stubbornness.\r\n\r\nI think warnings and errors are distinctly different and thus should be treated differently. In most programming languages, errors are conveyed by having their own keywords (`throw` or `raise`) and types (`Exception` or `Error`), while warnings are usually delegated to logs. In the terminal, `stderr` is separate from `stdout` and while you'd expect a CLI application to continue executing through the occurrence of warnings, you'd expect a non-zero exit if it were to encounter an error.\r\n\r\nFor this reason, I think the treatment of errors and warnings warrants a different behavior in HTTP as well. Delegating warnings to a header; allowing the app to continue working \u2013\u00a0while allowing errors to take over the entire response and thus stopping the application from working \u2013 feels both natural and right to me. \r\n\r\nWhat I do think warnings and errors share, though, is structure; which is why I'm supportive of a suggested `Problem` header conveying the same data and metadata as that of RFC 7807. And as @awwright writes, a `Problem` header is even able to convey multiple problems in a simpler and more ergonomic way than what is possible in the HTTP body, by separating each problem occurrence (i.e. warning) with a comma (with each field within a problem occurrence separated by a semicolon).\r\n\r\nWhile I don't think it's very important to bake the `Problem` header into the same spec as rfc7807bis, I do see the benefit of maintaining them in synchrony to avoid feature drift and (worst case) incompatibilities. So if was to come down to a vote, I would give a +1 to roll the `Problem` header into rfc7807bis.",
          "createdAt": "2022-03-26T11:02:27Z",
          "updatedAt": "2022-03-26T11:02:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@awwright the problem object can only serialise one problem, I think the same would apply here.",
          "createdAt": "2022-03-28T03:01:07Z",
          "updatedAt": "2022-03-28T03:01:07Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "Hey @asbjornu \r\n\r\nI'd like to challenge you a bit on your statement. Sure, at first it seems that errors and warnings are handled differently since they are separated from each other by different \"logfiles\". But the actual process of logging the error or warning is the same. You send an (error or warning) string to a file. \r\n\r\nBut I can relate to what you're trying to say. What you are logging can be totally different. Most often errors come with a stack trace, giving a more detailed look into the \"state of the machine\" at the time. Thus when looking at an error file you'd expect different types of log entries, then in a file that warnings have been written to.\r\n\r\nAnyhow, I think we're both trying to achieve the same thing here. As I wrote earlier, I'd be happy to have warnings in a header field. Unfortunately, the challenge I see is still there, when returning warnings one would probably want to return more data, than with an error, thus resulting in messages that could get too large.\r\n\r\nIf this is something everyone thinks is negligible then let's go for the header field.",
          "createdAt": "2022-03-29T06:34:41Z",
          "updatedAt": "2022-03-29T06:34:41Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> @awwright the problem object can only serialise one problem, I think the same would apply here.\r\n\r\nI would expect if one problem document can serialize one problem, then one Problem header would serialize one problem. It's not obvious to me that this would \"bubble up\" to the entire HTTP message.\r\n\r\nAlso I would expect HTTP semantics to apply, if I append a Problem header, that it won't change the meaning of existing headers (or at least, I would expect this to be a detectable error or ambiguity).",
          "createdAt": "2022-03-30T23:48:23Z",
          "updatedAt": "2022-03-30T23:48:23Z"
        },
        {
          "author": "olijaun",
          "authorAssociation": "NONE",
          "body": "I just came across this discussion by incident. I'm a bit late for the party... so please ignore me if you think the following makes no sense:\r\n\r\nI don't really see the point in having problems/warnings in a header field. Isn't a problem a \"business problem\"? Something like \"out-of-credit\". It is not some meta data but it is something essential that is relevant to \"the business\". The same is the case for warnings. To me this is an essential part of the response, so why would I want to add this to a Header-Field? It should be part of the body oft the response. It is still possible to define some kind of standard structure for this kind of stuff and then you embed that into your response (as draft-cedik-http-warning-02 suggests).",
          "createdAt": "2022-04-11T15:53:55Z",
          "updatedAt": "2022-04-11T15:53:55Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "I'm not sure if there's a specific use defined, but I would use it similar to 4xx errors. If there's no specific 4xx code for the error, this enables you to use a Problem header field with a 400 Client Error to make your specific class of error more machine-readable. Whereas normally, 400 requires human intervention because it could mean any error.",
          "createdAt": "2022-04-11T18:36:33Z",
          "updatedAt": "2022-04-11T18:43:58Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-04-11 20:36, Austin Wright wrote:\n> I'm not sure if there's a specific use defined, but I think you can see \n> it similar to 4xx errors. If there's no specific 4xx code for the error, \n> this enables you to use a Problem header field with a 400 Client Error \n> to make your specific class of error more machine-readable. Whereas \n> normally, 400 requires human intervention because it could mean any error.\n\ni agree in principle, but i'd argue that you could make the specific \nerror equally machine-readable by using a body with a problem report.\n\nwhere a header may be useful is when you want your API to generate \nhuman-readable error responses (in HTML) but still want a machine \nreadable version for machine clients. there would be other patterns to \naccomplish the same goal, but i think that's a line of reasoning you \ncould follow.\n",
          "createdAt": "2022-04-12T06:30:23Z",
          "updatedAt": "2022-04-12T06:30:23Z"
        },
        {
          "author": "olijaun",
          "authorAssociation": "NONE",
          "body": "I don't really see why one would need both things at the same time (but maybe my view is too limited).\r\n\r\nEither you request a HTML page and then you also expect a HTML response in case of an error. OR you add \"application/problems+json\" in addition to some \"application/myapp+json\" type to the accept header and you get the machine-readable response-\r\n\r\nAssuming your request a HTML file and it is returned with the header in question: How would you access these header fields? If you load a page with a browser you can't afterwards access the HTTP-Headers of this page in Javascript (I had too look that up here: https://stackoverflow.com/questions/220231/accessing-the-web-pages-http-headers-in-javascript) .\r\n\r\nOr you load the page with javascript but then why would you request a HTML? It would be possible of course but why?\r\n\r\nOf course: If browsers started to support this header field natively then maybe...",
          "createdAt": "2022-04-14T13:01:35Z",
          "updatedAt": "2022-04-14T13:01:35Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@olijaun I would expect a `Problem` header along with an HTML document for the same reason I would expect a server to respond with a 4xx code (instead of a generic 400 one). It provides more information about the nature of the error to the user agent.\r\n\r\nThat is, the Problem header is probably intended for use by the user agent itself\u2014not the webpage. (Although I agree, a webpage should be able to access the response headers that it was delivered with, except possibly Set-Cookie.)",
          "createdAt": "2022-04-14T23:42:37Z",
          "updatedAt": "2022-04-14T23:42:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Coming back to this, it seems like there's some support for adding this, but it's not especially strong. I can't see too many risks of including it in the spec (obvious worst case: it doesn't get used). That's not enough to justify including it, of course.\r\n\r\n@richsalz @darrelmiller perhaps a consensus call on list is in order?",
          "createdAt": "2022-04-27T04:02:58Z",
          "updatedAt": "2022-04-27T04:02:58Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Sure, a consensus call is fine. But could you write a summary of this issue and post to the list? ",
          "createdAt": "2022-04-27T16:51:01Z",
          "updatedAt": "2022-04-27T16:51:01Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "I like it a lot. Error messages are a serious problem point in most HTTP based APIs. Everybody rolls their own error spec, with slightly different semantics. It's good to have them specced consistently and sanely.\r\n\r\nThe semantics used in the spec are very sound. There's:\r\n* a unique computer-readable ID (type),\r\n* a human-readable and translated description of the generic problem,\r\n* a specific human-readable and translated description of the specific problem with parameters, and\r\n* custom computer-readable parameters for the values of this specific error.\r\nThis is great. I also love that you say that \"detail\" shall not be parsed, but custom values (\"extensions\") be used.\r\n\r\nI would just improve 2 aspects:\r\n\r\n* Add \"debug\" and \"stack\" as explicit additional fields. It's great that you specifically mandate that \"detail\" shall not contain debugging info. That's wise to define, because a field called \"detail\" is bound to be used for that. Unfortunately, most devs do not read specs, so if you have a field called \"detail\", I'm certain that devs are going to put stack traces in there. To avoid that urge, I would recommend to add two explicit fields \"debug\" and \"stack\". Both optional of course. But they should be two separate fields, because the stack is well-defined, and \"debug\" can be a dump of internal variables or anything else useful for debugging.\r\n\r\n* Be more tight in the definitions. Please mandate that the title and detail fields *are* in fact translated on the server side. The client cannot realistically do it, because the server can add new error conditions at any time, plus the business of including parameters in the user message. It's important that there is clarity about who is responsible for the translation of the error messages, and that this aspect is not left vague. So, I would define clearly: If there is a translation happening at all, then the server is translating the human-readable message, not the client.\r\n\r\nOther than these two simple changes: I like the spec a lot, and it's very much needed.\r\n\r\nThanks for your push for it!",
          "createdAt": "2022-04-28T08:47:15Z",
          "updatedAt": "2022-04-28T08:47:15Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOE-NsGs5GQC2E",
      "title": "Forward compatibility",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/36",
      "state": "CLOSED",
      "author": "awwright",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "([In reply to #32](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/32#issuecomment-1076569614), which I think is blocked by this issue.)\r\n\r\nI would call this specification \"forward compatible\" if we can add new features to it without interfering with existing compliant implementations. This is important so that standards can evolve to support new functionality, like proposed in #32.\r\n\r\nIt does not appear to me that there's any mechanism for forward compatibility, and this is noted:\r\n\r\n>    Note that because extensions are effectively put into a namespace by\r\n   the problem type, it is not possible to define new \"standard\" members\r\n   without defining a new media type.\r\n\r\nWhile the media type can be \"extended\" in some fashion, this is not the same as forward compatibility, because all extensions are by definition user extensions, so they cannot be standardized. I.e. there is no way to define new \"global\" members.\r\n\r\nI think this is important to fix. I see a few options:\r\n\r\n(1) Note how the concept of \"user\" extensions has some amount of ambiguity. In order to know what a non-standard member means, you have to know _who_ issued the Problem document. But there's no standard way to encode this! (It does say the type is \"effectively\" a namespace for extensions, but this doesn't seem like particularly authoritative language.) Applications that are tightly coupled with a specific API may not have trouble consuming user extensions, but other user-agents (e.g. spiders) may have a problem deciphering them. Because of this, I think we could more rigorously specify the behavior without significant breakage \"in the wild\". For example, specify that extension members must use a URI, and all other members have a standard definition. Or, choose some prefix that sorts high in ASCII, like `!` or `$`, to indicate standard \"global\" members.\r\n\r\n(2) If this still causes too much breakage, we could either reserve the member names that would cause breakage, or I would support minting a new media type.\r\n\r\nWe could also consider defining a JSON-LD vocabulary. There's likely a good way to encode the problem details that's easily detectable as a document describing the error, and having a standardized form and properties, while also being easily extensible for specific types of problems/errors.\r\n",
      "createdAt": "2022-03-23T20:12:37Z",
      "updatedAt": "2023-04-22T17:39:19Z",
      "closedAt": "2022-04-27T04:04:33Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This has been discussed as part of a few other issues, but it's good to separate it out into an explicit one.\r\n\r\nI think you're in the ballpark here -- to allow new standard extensions (i.e., those not in the original spec and not explicitly nominated by the type in use), we have two choices:\r\n\r\n1. Find a naming convention that doesn't conflict with existing usage (e.g., a prefix)\r\n2. Mint a new media type\r\n\r\n(1) is hard, because we don't and can't know the extent of existing usage. However, we might be able to create a convention that's extremely unlikely to conflict with existing usage, advertise it widely, and make sure there's a transition period before it's actually used. If we do all that, the risks could be low enough to be acceptable.\r\n\r\n(2) is certainly possible, but when we've discussed this in the past, the concern has been that it would further fragment usage.\r\n\r\nThere is a third option. We can define conventions that individual types opt into, saving them the work of defining the mechanism. For things like `problem-pointer` (or whatever it becomes), that might be enough. ",
          "createdAt": "2022-03-23T22:55:26Z",
          "updatedAt": "2022-03-23T22:55:26Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "based on the IETF 113 discussion it looks like option (1) with a prefix that isn't too upsetting for JSON users is the best option going forward. it's called \"faking forward compatibility when you ignored it initially\" and looks good enough to me.",
          "createdAt": "2022-03-24T11:01:06Z",
          "updatedAt": "2022-03-24T11:01:06Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> We can define conventions that individual types opt into\r\n\r\nHow would clients know if a type has opted in or not?\r\n\r\n> based on the IETF 113 discussion it looks like option (1) with a prefix that isn't too upsetting for JSON users is the best option going forward. it's called \"faking forward compatibility when you ignored it initially\" and looks good enough to me.\r\n\r\nAnd this enjoys some precedent from some other JSON media types (JSON-LD, JSON Schema). Reserving a prefix seems to have also been deployed in e.g. HTTP cookies (the double underscore prefix) without too much breakage in the wild.\r\n\r\nAlso, as I sort of hinted, it would be nice to add some stronger language about how to namespace or interpret extension members. Can we guarantee that two \"balance\" extensions aren't necessarily the same, if the \"type\" is different? And what do we do if there is no type?",
          "createdAt": "2022-03-24T20:22:05Z",
          "updatedAt": "2022-03-24T20:22:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If we choose a prefix, I think it needs to conform to the constraints that I just added to #39 --\r\n\r\n> When creating extensions, problem type authors should choose their names carefully. To be used in the XML format (see {{xml-syntax}}), they will need to conform to the Name rule in {{Section 2.3 of XML}}. To be used in the HTTP field (see {{field}}), they will need to conform to the Dictionary key syntax defined in {{Section 3.2 of STRUCTURED-FIELDS}}.\r\n\r\nThat rules out things like `$`.  \r\n\r\nOf the two, Dictionary keys are more constrained - their first characters need to be lcalpha or `*`. \r\n\r\nSo how about `*`?",
          "createdAt": "2022-03-24T21:49:31Z",
          "updatedAt": "2022-03-24T21:49:31Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-03-24 22:49, Mark Nottingham wrote:\n> So how about |*|?\n\ni am fairly open to anything since it's nothing but an opaque thing that \n*we* will have to adhere to for future standard members. would it be '*\" \nor '*-'? i may have a slight preference for the latter for readability.\n",
          "createdAt": "2022-03-25T08:03:02Z",
          "updatedAt": "2022-03-25T08:03:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Either one. `*-` is a bit weird IMO.\r\n\r\nEg\r\n\r\n`\"*json-pointer\": \"/foo/bar\"`\r\n\r\nvs\r\n\r\n`\"*-json-pointer\": \"/foo/bar\"`\r\n\r\n(keep in mind that if #39 doesn't eventuate the possibilities open up quite a bit)",
          "createdAt": "2022-03-28T03:03:44Z",
          "updatedAt": "2022-03-28T03:03:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR #41 ",
          "createdAt": "2022-04-18T22:28:55Z",
          "updatedAt": "2022-04-18T22:28:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Merging, with the expectation that we'll discuss it on list and advertise this change to make sure we're not clashing with anyone. Even if we don't do the `Problem` header field now, doing something compatible with SH dictionaries seems like a good idea so that it's future-proof.",
          "createdAt": "2022-04-27T04:04:21Z",
          "updatedAt": "2022-04-27T04:04:21Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOE-NsGs5Hysyk",
      "title": "Questions regarding extension",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/40",
      "state": "CLOSED",
      "author": "olijaun",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "Hi\r\n\r\nThe draft states:\r\n\r\n> Note that because extensions are effectively put into a namespace by the problem type, it is not possible to define new \"standard\" members without defining a new media type.\r\n\r\nI get the part regarding the media type.\r\n\r\nI'm not sure if I understand the part about the namespace correctly (I'm not a native speaker so this might be the problem):\r\n\r\nLet's say I have the following problem (Ex. 1):\r\n```\r\n{\r\n  \"type\": \"about:blank\",\r\n  \"title\": \"something's wrong\"\r\n}\r\n```\r\n\r\nNow I need an extension \"myextension\". Does this mean I necessarily have to define a specific type as shown in Ex 2?\r\n```\r\n{\r\n  \"type\": \"http://example.com/mytype\",\r\n  \"title\": \"something's wrong\",\r\n  \"myextension\": \"bla\"\r\n}\r\n```\r\n\r\nOr could I just add an extension to a problem detail of type \"about:blank\"? This would mean that extensions are defined always for all types (Ex 3)?\r\n\r\n```\r\n{\r\n  \"type\": \"about:blank\",\r\n  \"title\": \"something's wrong\",\r\n  \"myextension\": \"bla\"\r\n}\r\n```\r\n\r\nIf Ex 2 is the correct way then I don't understand the other discussion regarding forward compatibility.\r\n\r\nIf Ex 3 is correct then I don't understand the quote I've put in the beginning of my post.\r\n\r\nRegards\r\nOliver",
      "createdAt": "2022-04-14T12:34:07Z",
      "updatedAt": "2023-04-22T17:43:33Z",
      "closedAt": "2022-04-18T10:52:58Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "To add an extension to a problem type, right now you need to control the type itself; you can't define an extension for another person's problem type without their permission.\r\n",
          "createdAt": "2022-04-18T10:52:58Z",
          "updatedAt": "2022-04-18T10:52:58Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-04-18 12:53, Mark Nottingham wrote:\n> To add an extension to a problem type, right now you need to control the \n> type itself; you can't define an extension for another person's problem \n> type without their permission.\n\ni think that's slightly overselling the current state. types are one \nthing, extension members a different one. RFC 7807 vaguely hints at \n\"types defining members\", but there is no namespacing or scoping, so in \nthe end these two things are independent.\n\nimho, everybody can define extension members for whatever they like, and \nthere is no mechanism to avoid or even detect conflicts with others \ndefining an identically named extension either standalone or as part of \na new type they've defined. maybe that's not ideal, but that's what we \nhave in the current spec.\n",
          "createdAt": "2022-04-18T21:24:44Z",
          "updatedAt": "2022-04-18T21:24:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Problem type definitions MAY extend the problem details object with additional members.\r\n\r\n",
          "createdAt": "2022-04-18T22:23:43Z",
          "updatedAt": "2022-04-18T22:23:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Note that because extensions are effectively put into a namespace by the problem type, it is not possible to define new \"standard\" members without defining a new media type.",
          "createdAt": "2022-04-18T22:24:07Z",
          "updatedAt": "2022-04-18T22:24:07Z"
        },
        {
          "author": "olijaun",
          "authorAssociation": "NONE",
          "body": "> Problem type definitions MAY extend the problem details object with additional members.\r\n\r\nOk, thanks @mnot. This statement in addition to your statement about \"control of the type\" makes it clear to me.  I'm not controlling the problem type \"about:blank\" definition (it's controlled by the RFC) so I cannot add additional members to \"about:blank\" but I can add them to my own problem types.\r\n",
          "createdAt": "2022-04-19T08:23:04Z",
          "updatedAt": "2022-04-19T08:24:28Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOE-NsGs5IAS4Q",
      "title": "The validation-error example is wrong(!/?)",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/42",
      "state": "CLOSED",
      "author": "olijaun",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi\r\n\r\nIn the spec there is a validation-error problem example:\r\n\r\n```\r\nHTTP/1.1 400 Bad Request\r\nContent-Type: application/problem+json\r\nContent-Language: en\r\n\r\n{\r\n \"type\": \"https://example.net/validation-error\",\r\n \"title\": \"Your request is not valid.\",\r\n \"causes\": [\r\n             {\r\n               \"detail\": \"must be a positive integer\",\r\n               \"problem-pointer\": \"#/age\"\r\n             },\r\n             {\r\n               \"detail\": \"must be 'green', 'red' or 'blue'\",\r\n               \"problem-pointer\": \"#/profile/color\"\r\n             }\r\n          ]\r\n  }\r\n```\r\n\r\nIn section 3.2 (Extension Members) it says:\r\n\r\n> Similarly, the \"Multi-Status\" example defines two extensions -- \"causes\" and \"problem-pointer\".\r\n\r\nThis actually means that each element in \"causes\" is a problem itself (otherwise there would not be two extensions but only one).\r\n\r\nIf we assume that each element in \"causes\" is a problem detail - then where is the type member? According to the RFC the type is \"about:blank\" if it is not specified. But then (according to the response of my other question https://github.com/ietf-wg-httpapi/rfc7807bis/issues/40 ) you can't define a custom extension for \"about:blank\".\r\n\r\nIf we would assume that the type of an \"embedded\" problem details is always the same as the one it is embedded then we assume something that is not part of the spec (or did I not see it?).\r\n\r\nWe could also say that the elements inside \"causes\" are not problem details but then we should remove the statement that the \"example defines two extensions\". It would only define ONE extension (the \"causes\").\r\n",
      "createdAt": "2022-04-19T09:11:57Z",
      "updatedAt": "2022-04-27T03:50:03Z",
      "closedAt": "2022-04-27T03:50:03Z",
      "comments": []
    },
    {
      "number": 43,
      "id": "I_kwDOE-NsGs5IAX3W",
      "title": "Clarifying extension member scoping",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/43",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dret"
      ],
      "labels": [],
      "body": "Following the discussion in #40 made me think that we could tighten the language around extension member scope.\r\n\r\n> Note that because extensions are effectively put into a namespace by the problem type, it is not possible to define new \"standard\" members without defining a new media type.\r\n\r\n\"Effectively\" seems a bit odd here. Are they put into a namespace or not? If they do, then processing rules follow that we may want to spell out:\r\n\r\n> Because extension members are put into a namespace by the problem type, extension members MUST only be processed when they occur for a problem type that the consumer is expecting. If an extension member is recognized by its name but in the context of a problem type that the consumer is not expecting for that member, then the extension member MUST be ignored.\r\n> In addition, because extension members are put into a namespace by the problem type, it is not possible to define new \"standard\" members (i.e., members that can be used with any problem type) without defining a new media type.\r\n\r\nMaybe that's not good wording, but it seems to me that the current wording may be a little too vague.",
      "createdAt": "2022-04-19T09:26:01Z",
      "updatedAt": "2022-05-11T08:47:26Z",
      "closedAt": "2022-05-11T08:47:26Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "I just realized that my above text clashes with https://github.com/ietf-wg-httpapi/rfc7807bis/pull/41 but once that one is merged I can come up with a suggestion that works with the updated draft text.",
          "createdAt": "2022-04-19T09:29:00Z",
          "updatedAt": "2022-04-19T09:29:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think adding new requirements here is a good idea. I've tweaked a bit to make things clearer.",
          "createdAt": "2022-05-11T01:07:52Z",
          "updatedAt": "2022-05-11T01:07:52Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "this proposal wasn't meant as adding new requirements, but as clarifying rules that may have been implicit before. thanks for the tweaks.",
          "createdAt": "2022-05-11T08:34:08Z",
          "updatedAt": "2022-05-11T08:34:08Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOE-NsGs5Jv29D",
      "title": "Discuss usage of application/json",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/44",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dret"
      ],
      "labels": [],
      "body": "What about a short paragraph/section saying that APIs using the spec don't require clients to always add `Accept` with the problem-specific media types? I've now had several people asking this very question, and maybe we could clarify this by saying \"HTTP allows you to respond with media types other than those listed in `Accept`.\"",
      "createdAt": "2022-05-16T14:52:18Z",
      "updatedAt": "2022-05-25T06:59:21Z",
      "closedAt": "2022-05-25T06:59:21Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "Because I am curious to see what people think: https://twitter.com/dret/status/1526218691603464192",
          "createdAt": "2022-05-16T15:11:41Z",
          "updatedAt": "2022-05-16T15:11:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We shouldn't restate or explain HTTP in our prose -- it's a specification, not a tutorial. Extrinsic materials can handle that.\r\n\r\nHowever, we can include an example that includes a request without Accept. ",
          "createdAt": "2022-05-16T21:52:05Z",
          "updatedAt": "2022-05-16T21:52:05Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-05-16 23:52, Mark Nottingham wrote:\n> We shouldn't restate or explain HTTP in our prose -- it's a \n> specification, not a tutorial. Extrinsic materials can handle that.\n> However, we can include an example that includes a request without Accept.\n\nok, sounds good. but if we do that then we should at least mention that \nwe're showing this because servers are free to respond with the \napplication/problem+json media type, even if clients don't specifically \nrequest it. is that ok for you?\n",
          "createdAt": "2022-05-17T05:57:50Z",
          "updatedAt": "2022-05-17T05:57:50Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOE-NsGs5L7Z7A",
      "title": "Last chance for comments",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/46",
      "state": "CLOSED",
      "author": "richsalz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Please see https://mailarchive.ietf.org/arch/msg/httpapi/VlX_Excs5jhWsnxgZxZkwOOrx_E/\r\n\r\n    This is a two-week Working Group Last Call. If you have objections or\r\n    concerns about this document, please post them by the end of the month. \r\n    Thank you.\r\n",
      "createdAt": "2022-06-16T17:16:27Z",
      "updatedAt": "2022-08-26T10:45:32Z",
      "closedAt": "2022-07-19T20:04:11Z",
      "comments": [
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "The document is looking good to me.   One minor possible nit in section 3.1.1.\r\n\r\n> Consumers MUST use the \"type\" URI (after resolution, if necessary) problem's primary identifier.\r\n\r\n@mnot Should the above actually say?\r\n\r\n> Consumers MUST use the \"type\" URI (after resolution, if necessary) as the problem's primary identifier.\r\n\r\n",
          "createdAt": "2022-06-19T19:25:10Z",
          "updatedAt": "2022-06-19T19:25:25Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dear chairs @darrelmiller @richsalz, I have a request to add an informal section to the spec to have #10 resolved. It should not be a large change; as it is only an informative section, it should also not be controversial. I have been inhibited from working on a PR due to a rather exhausting parental leave, but I'm finally easing back to work so I now have some time on my hands and the ability to contribute. I'll get to work on the PR and hope you'll accept it although the two-week last call is long surpassed. \ud83d\ude4f\ud83c\udffc ",
          "createdAt": "2022-07-26T07:44:54Z",
          "updatedAt": "2022-07-26T07:52:09Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@asbjornu Thank you for this contribution.  Can you help me understand why it is valuable to add a description of how JSON-LD users should use http-problem into the http-problem specification?  Wouldn't it be a more scalable solution to document in JSON-LD documentation how http-problem can be used?  What about how http-problem can be used in JSON:API, OData, gRPC, GraphQL,etc?  Documenting how to use JSON-LD in the http-problem specification feels inverted to how this should actually be done.  ",
          "createdAt": "2022-08-09T13:52:27Z",
          "updatedAt": "2022-08-09T13:52:27Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this was only about documenting usage, I would completely agree, @darrelmiller. But this is also about establishing a shared vocabulary, such that all JSON-LD-capable consumers of rfc7807bis interpret it in the same way. None of the formats or protocols you mention have a concept of shared vocabulary or namespace, and as such, they are not affected by this issue.\r\n\r\nNot defining the shared vocabulary within rfc7807bis is like RFC 4287 not defining its own namespace URI to be `http://www.w3.org/2005/Atom`, but instead, leaving that part up to every producer and consumer of Atom. Needless to say, that would have caused a lot of compatibility issues with Atom implementations, where I suppose some namespace URIs would become de facto standards every consumer would have to support. However, since RFC 4287 does define its own namespace URI, that whole compatibility conundrum is avoided.\r\n\r\nWhat is needed in rfc7807bis to establish this shared vocabulary is just to mint a URI. That's it. We've explored many different options (URNs, URIs, URLs), but IETF does not have a procedure to mint URIs meant for such namespace-like usage and to have W3C mint such a URL for us (like they did for Atom) seems like a difficult task. I have no contacts in W3C to ask, at least.",
          "createdAt": "2022-08-09T21:11:25Z",
          "updatedAt": "2022-08-09T21:12:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey @asbjornu. When we discussed this at IETF114, concern was expressed that we might not get it right, because we don't have broad expertise in JSON-LD, and also that baking it into an immutable RFC doesn't allow for easy adjustment later. \r\n\r\nGiven that, I think the relevant question is why it's important to establish a shared vocabulary in _this_ document -- keeping in mind that most users of this document will _not_ be using JSON-LD (unlike your example of the Atom namespace).",
          "createdAt": "2022-08-10T02:16:02Z",
          "updatedAt": "2022-08-10T02:16:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-08-10 04:16, Mark Nottingham wrote:\n> Given that, I think the relevant question is why it's important to \n> establish a shared vocabulary in /this/ document -- keeping in mind that \n> most users of this document will /not/ be using JSON-LD (unlike your \n> example of the Atom namespace).\n\nit just seems like an odd thing to give a non-normative JSON-LD context. \nif it's non-normative, it's simply showing how to use JSON-LD and that \nseems to be something that applies to any JSON out there.\n\nin my mind, to make sense this would need to be a normative context so \nthat the RDF community would have a model to represent problem reports. \nfor that it seems like it would make more sense for the RDF community to \nwork on such a vocabulary, publish it, and then provide a JSON-LD with it.\n",
          "createdAt": "2022-08-10T07:25:55Z",
          "updatedAt": "2022-08-10T07:25:55Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Given that, I think the relevant question is why it's important to establish a shared vocabulary in _this_ document -- keeping in mind that most users of this document will _not_ be using JSON-LD (unlike your example of the Atom namespace).\r\n\r\nOk, please allow me to explore a thought experiment. A lot of XML was and is consumed without any care for XML namespaces. For those XML processors, it wouldn't matter whether RFC 4287 declared an official namespace URI or not. Authors of these processors could even argue that it's not their problem that someone wants to burden their simple XML processors with XMLNS and that those who want to process XML with namespaces should do so by minting their own namespace URI outside the scope of RFC 4287.\r\n\r\nNow, which would you say is the natural authority to assume the task of registering a namespace URI for RFC 4287? How do you ensure there's no fragmentation? That everyone that wants to consume Atom with XMLNS uses the same URI?\r\n\r\nI don't think those questions have clear or good answers if RFC 4287 did not mint its own XMLNS and I think the same applies to rfc8707bis if it doesn't mint its own URI. I would even be happy about leaving JSON-LD in the dust and for the JSON-LD community to figure out and just having rfc8707bis declare something like:\r\n\r\n> For applications that require Problem Details for HTTP to be identified by a URI, the following can be used:\r\n> `https://example.com/ns/problem#`\r\n\r\n",
          "createdAt": "2022-08-11T23:08:53Z",
          "updatedAt": "2022-08-11T23:08:53Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@asbjornu The abstract of RFC 4287 says\r\n\r\n> This document specifies Atom, an XML-based Web content and metadata syndication format.\r\n\r\nThe Atom format takes a normative dependency on XML and therefore has an obligation to play by the rules of XML and define an official namespace.\r\n\r\nRFC 7807 says,\r\n> this specification defines simple JSON and XML  document formats and a HTTP field to describe the specifics of problem(s) encountered -- \"problem details\".\r\n\r\nIt doesn't say it is the authoritative source for a JSON-LD format.  I don't think adding a non-normative appendix for JSON-LD is the right solution to the problem as a) it is not authoritative and b) it doesn't scale.",
          "createdAt": "2022-08-19T14:03:59Z",
          "updatedAt": "2022-08-19T14:03:59Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-08-19 16:04, Darrel wrote:\n> The Atom format takes a normative dependency on XML and therefore has an \n> obligation to play by the rules of XML and define an official namespace.\n> \n> RFC 7807 says,\n> \n>     this specification defines simple JSON and XML document formats and\n>     a HTTP field to describe the specifics of problem(s) encountered --\n>     \"problem details\".\n> \n> It doesn't say it is the authoritative source for a JSON-LD format. I \n> don't think adding a non-normative appendix for JSON-LD is the right \n> solution to the problem as a) it is not authoritative and b) it doesn't \n> scale.\n\nbecause RFC 7807 does define an XML format it does define a namespace \nfor it.\n\nhttps://www.rfc-editor.org/rfc/rfc7807#appendix-A\n\nbut that's for the XML vocabulary of RFC 7807. there's no mention of \nnamespaces/identifiers for RDF vocabularies in either RFC 4287 or RFC \n7807. both specs are simply not concerned with RDF representations.\n",
          "createdAt": "2022-08-19T14:12:41Z",
          "updatedAt": "2022-08-19T14:12:41Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@darrelmiller:\r\n\r\n> The Atom format takes a normative dependency on XML and therefore has an obligation to play by the rules of XML and define an official namespace.\r\n\r\nNamespaces are an optional addition to XML. Swathes of XML doesn't contain a single `xmlns` attribute and there are a plethora of XML processors that don't grok namespaces at all. XML existed for a year before XMLNS was a thing and it took a while before the most widespread processors caught on to it. Although it was considered good (perhaps even best) practice, there was afaik nothing that forced us to mint a namespace for Atom when we developed it.\r\n\r\n> It doesn't say it is the authoritative source for a JSON-LD format. I don't think adding a non-normative appendix for JSON-LD is the right solution to the problem as a) it is not authoritative and b) it doesn't scale.\r\n\r\nI can come to terms with that if you please consider what I suggested in https://github.com/ietf-wg-httpapi/rfc7807bis/issues/46#issuecomment-1212578885:\r\n\r\n> I would even be happy about leaving JSON-LD in the dust and for the JSON-LD community to figure out and just having rfc8707bis declare something like:\r\n> \r\n> > For applications that require Problem Details for HTTP to be identified by a URI, the following can be used:\r\n> > `https://example.com/ns/problem#`\r\n\r\n@dret:\r\n\r\n> because RFC 7807 does define an XML format it does define a namespace for it. \r\n> https://www.rfc-editor.org/rfc/rfc7807#appendix-A\r\n\r\nIndeed, but as we've discussed `urn:ietf:rfc:7807` is not extensible. It is impossible for a JSON-LD context to state that `status` is `urn:ietf:rfc:7807:status` or `urn:ietf:rfc:7807#status` for instance.\r\n\r\n> there's no mention of namespaces/identifiers for RDF vocabularies in either RFC 4287 or RFC 7807. both specs are simply not concerned with RDF representations.\r\n\r\nNor does rfc7807bis have to be, either. It just needs to provide an extensible URI that JSON-LD and XML consumers can use to say \"this is the authoritative URI that represents rfc7807bis\". Is it nothing we can do about the `urn:ietf:rfc:7807` URI to allow this sort of extensibility?",
          "createdAt": "2022-08-25T21:21:39Z",
          "updatedAt": "2022-08-25T21:21:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-08-25 23:21, Asbj\u00f8rn Ulsberg wrote:\n> Indeed, but as we've discussed |urn:ietf:rfc:7807| is not extensible. It \n> is impossible for a JSON-LD context to state that |status| is \n> |urn:ietf:rfc:7807:status| or |urn:ietf:rfc:7807#status| for instance.\n\nthat URI is the XML namespace URI and was never intended or never \nclaimed to be more than that.\n\n> Nor does rfc7807bis have to be, either. It just needs to provide an \n> extensible URI that JSON-LD and XML consumers can use to say \"this is \n> the authoritative URI that represents rfc7807bis\". Is it nothing we can \n> do about the |urn:ietf:rfc:7807| URI to allow this sort of extensibility?\n\nthat ship sailed six years ago with RFC 7807. since our explicit goal is \nto not break things, changing the XML namespace URI is not an option.\n",
          "createdAt": "2022-08-26T06:25:33Z",
          "updatedAt": "2022-08-26T06:25:33Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> that ship sailed six years ago with RFC 7807. since our explicit goal is to not break things, changing the XML namespace URI is not an option.\r\n\r\nI'm not asking to change the XML namespace URI (in the XML context), I'm asking to reuse and expand it in other contexts. The fact that JSON-LD expands `status` to `urn:ietf:rfc:7807:status` is not going to affect the XML serialization or processing of rfc7807bis.",
          "createdAt": "2022-08-26T10:45:32Z",
          "updatedAt": "2022-08-26T10:45:32Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOE-NsGs5RNXiv",
      "title": "nit: Normative reference to HTTP spec needs to be updated to latest published document",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/49",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-05T20:47:10Z",
      "updatedAt": "2022-09-06T00:57:25Z",
      "closedAt": "2022-09-06T00:57:25Z",
      "comments": []
    },
    {
      "number": 50,
      "id": "I_kwDOE-NsGs5RNXk9",
      "title": "nit: Abstract should mention that this document obsoletes RFC7807",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/50",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-05T20:47:29Z",
      "updatedAt": "2022-09-06T00:57:25Z",
      "closedAt": "2022-09-06T00:57:25Z",
      "comments": []
    },
    {
      "number": 51,
      "id": "I_kwDOE-NsGs5RNXm7",
      "title": "nit: A later version of JSON Schema exists for the informative reference.",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/51",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-05T20:47:45Z",
      "updatedAt": "2022-09-06T00:54:08Z",
      "closedAt": "2022-09-06T00:54:07Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "will automagically be updated on publication.",
          "createdAt": "2022-09-06T00:54:07Z",
          "updatedAt": "2022-09-06T00:54:07Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOE-NsGs5RNXp-",
      "title": "nit: Introduction should briefly explain what has changed from 7807 and why",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/52",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-05T20:48:10Z",
      "updatedAt": "2022-09-06T01:06:13Z",
      "closedAt": "2022-09-06T01:06:13Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOE-NsGs5RNXr2",
      "title": "nit: Summary of Changes section should provide greater detail on the motivation and changes",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/53",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-05T20:48:25Z",
      "updatedAt": "2022-09-06T01:06:13Z",
      "closedAt": "2022-09-06T01:06:13Z",
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOE-NsGs5RNXz9",
      "title": "Errata 5515: Clarification of meaning when type member is null",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/54",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Errata 5515\r\nhttps://www.rfc-editor.org/errata/eid5515 should be addressed",
      "createdAt": "2022-09-05T20:49:36Z",
      "updatedAt": "2022-09-06T00:57:08Z",
      "closedAt": "2022-09-06T00:57:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Null isn't allowed as a value of `type`; this errata is not valid.",
          "createdAt": "2022-09-06T00:57:08Z",
          "updatedAt": "2022-09-06T00:57:08Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOE-NsGs5UouQ8",
      "title": "Shouldn't parameters be semicolon-separated?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/56",
      "state": "CLOSED",
      "author": "awwright",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header_field"
      ],
      "body": "Over in https://mailarchive.ietf.org/arch/msg/httpapi/GRGrz_dh4ccwB696uYR21_6brU8/ I noted that it's odd that parameters are separated by commas, because in other contexts this is semantically the same as the same header repeated multiple times.\r\n\r\nIt doesn't make sense that\r\n\r\n```\r\nProblem: type=\"https://example.net/problems/almost-out\"\r\nProblem: title=\"you're almost out of credit\"\r\nProblem: credit_left=20\r\n```\r\n\r\nshould be the same as\r\n\r\n```\r\nProblem: type=\"https://example.net/problems/almost-out\", title=\"you're almost out of credit\", credit_left=20\r\n```\r\n\r\n... This is a problem because if an intermediary appends a `Problem` header to a response that already contains a `Problem` header; the problem in the resulting message would become mangled.\r\n\r\nI suggested using the syntax of the `Link` header, which is already well established and could easily be re-used, something like:\r\n\r\n```\r\nProblem: <https://example.net/problems/almost-out>; title=\"you're almost out of credit\u201d; credit_left=20\r\n```\r\n\r\nThis syntax has an [exact representation as regular expression](https://mailarchive.ietf.org/arch/msg/httpapi/Heu3hsHCNs4mkeNIgEcWCNy1CBo/).\r\n\r\nOr `sf-item`:\r\n\r\n```\r\nProblem: \"https://example.net/problems/almost-out\"; title=\"you're almost out of credit\u201d; credit_left=20\r\n```\r\n\r\nI don't think I got much of a formal response so I'd like to ask here.",
      "createdAt": "2022-10-23T22:34:44Z",
      "updatedAt": "2023-04-22T17:13:04Z",
      "closedAt": "2023-01-27T02:01:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey @awwright  - sorry you didn't get a response earlier.\r\n\r\nThere can only be one problem in a response, which is why we chose this representation -- it's the most direct mapping from the data structure (as a Dictionary). \r\n\r\nYou're right that an intermediary adding a problem will mangle it, we should address that as a LC comment. However, the fix is not to allow multiple problems in the syntax; it's to warn intermediaries against doing that.\r\n\r\nAnd please, please don't use a regex to parse structured fields -- there's no need, [many implementations](https://github.com/httpwg/wiki/wiki/Structured-Fields) are available.",
          "createdAt": "2022-10-23T23:06:58Z",
          "updatedAt": "2022-10-23T23:06:58Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "If re-using Link is out of the question, then wouldn't `sf-item` be most appropriate? That seems to support all the same features, and would be clear that more than one Problem field is invalid.\r\n\r\nI only bring up regex because since compliance is a concern, and since every (non-recursive) ABNF has an exact representation as a regex, you can avoid the need to use any hand-written parser (including structured fields). But this doesn't seem very widespread and hopefully I can share more on this later.",
          "createdAt": "2022-10-24T06:38:26Z",
          "updatedAt": "2022-10-24T06:38:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The nice thing about using Dictionary is that it mirrors the dictionary-based format of a Problem in JSON.\r\n\r\nUsing Item would have the effect of more visibily breaking if someone erroneously added another Problem header. I'm not sure I like the implicit type as the item, but am not hugely against it.\r\n\r\nAnyone else have an opinion? @dret @sdatgit ?",
          "createdAt": "2022-11-29T01:31:19Z",
          "updatedAt": "2022-11-29T01:31:19Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">The nice thing about using Dictionary is that it mirrors the dictionary-based format of a Problem in JSON.\r\n>I'm not sure I like the implicit type as the item\r\n\r\n+1 on both. \r\n\r\nHonestly, I have yet to come across a need to convey problem details via a header in HTTP APIs yet. APIs that would send problem details in header should not send any problem details in message content and vice a versa. Nothing wrong technically but two different parsers, etc. hurts dev experience. I have been to places where different groups of the same enterprise send errors in message content using different schemas, just because they cannot agree on a single schema or they want innovation or etc. Imagine how difficult it would be for developers writing apps consuming those APIs. ",
          "createdAt": "2022-11-29T03:45:33Z",
          "updatedAt": "2022-11-29T03:45:33Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> The nice thing about using Dictionary is that it mirrors the dictionary-based format of a Problem in JSON.\r\n\r\nI think the key difference is the `sf-dictionary` is an open map (the set may be incomplete, and additional items can be added at any time), and a JSON object is closed (the set is exhaustive). Whereas with `sf-item`, once properties on an item are defined, they cannot be expanded. This open behavior of sf-dictionary may be reasonable in many places, but I don't think it is here.\r\n\r\n> Honestly, I have yet to come across a need to convey problem details via a header in HTTP APIs yet\r\n\r\nI see two big uses:\r\n\r\n(1) Web browsers might be able to act on the headers in a way not feasible for the response body, or the server wants to return a machine-readable error _and_ an HTML response; and\r\n\r\n(2) it can be used to better specify the nature of generic x00 statuses; making a superior alternative to minting your own status codes: Instead of people unilaterally minting cutesy status codes like \"420 Enhance Your Calm\", this would encourage responses like \"400 Client Error\" with `Problem: \"http://example.com/errors/enhance-your-calm\"`",
          "createdAt": "2022-11-29T06:14:59Z",
          "updatedAt": "2022-11-29T06:18:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> I think the key difference is the sf-dictionary is an open map (the set may be incomplete, and additional items can be added at any time), and a JSON object is closed (the set is exhaustive). Whereas with sf-item, once properties on an item are defined, they cannot be expanded. This open behavior of sf-dictionary may be reasonable in many places, but I don't think it is here.\r\n\r\nThat's a very minor difference; adding two `types` to both forms is invalid; it's just that they'll be handled in different ways. I don't see that as making a big difference, though (e.g., to debugging).",
          "createdAt": "2022-11-29T06:42:24Z",
          "updatedAt": "2022-11-29T06:42:24Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> That's a very minor difference; adding two types to both forms is invalid\r\n\r\nDoes either Problem or Structured Fields say that a repeated key would be an error? I can't find anything on this, and it hasn't occurred to me to check for repeated keys or how I should handle those (ignore the whole Problem field? Ignore the duplicate key only?).\r\n\r\nI agree the likelihood of an error is low, but to paraphrase my earlier argument, if purpose of using Structured Fields is highly robust parsing (among other benefits), then the definition of Problem should probably be robust against gateways that append headers, too.\r\n\r\nAs I'm reading, one more thing to address is that a Dictionary implicitly exists even when there's no members:\r\n\r\n> As with Lists, an empty Dictionary is represented by omitting the entire field. This implies that fields defined as Dictionaries have a default empty value.\r\n\r\nI'm not sure this poses a problem as such\u2014but to me it's just more intuitive to say if there's no Items in the `sf-item` then there's no Problem, and if there's one item, then that is the Problem.\r\n\r\n---\r\n\r\nI'd like to make one last pitch, I've seen more than a couple people now question the benefit of the `Problem` header, and I really appreciate how it can extend generic status codes, so I think this should be described better:\r\n\r\n```\r\nHTTP/1.1 400 Client Error\r\nProblem: \"http://example.com/errors/enhance-your-calm\"\r\n```\r\n\r\nNotice how using the `sf-item` form emphasizes that interpretations of the extension members depend on the problem type, and how this saves a few bytes for the most common case.",
          "createdAt": "2022-11-29T20:13:41Z",
          "updatedAt": "2022-11-29T20:13:41Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> adding two `types` to both forms is invalid\r\n\r\nActually, can you please elaborate on this? Most JSON implementations will ignore the earlier properties, and Structured Fields [requires this specifically](https://httpwg.org/specs/rfc8941.html#parse-dictionary):\r\n\r\n> Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.\r\n\r\nSo I don't think there's any way for a Structured Field parser to detect a duplicate \"type\"\u2014the only option is to mangle the previous Problem header.",
          "createdAt": "2022-11-29T23:45:20Z",
          "updatedAt": "2022-11-29T23:45:20Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Speaking as an individual, I have to say, there is a lot of elegance in the simplicity of this\r\n\r\n```\r\nHTTP/1.1 400 Client Error\r\nProblem: \"http://example.com/errors/enhance-your-calm\"\r\n```\r\n\r\nand this feels very natural to me\r\n\r\n```\r\nProblem: \"https://example.net/problems/almost-out\"; title=\"you're almost out of credit\u201d; credit_left=20\r\n```\r\n\r\nIf the use of `sf-item` helps to detect duplicate problem fields, then that seems like a win to me.",
          "createdAt": "2022-12-07T05:27:44Z",
          "updatedAt": "2022-12-07T05:27:44Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@mnot @sdatspun2 As document authors, you have expressed a preference for the dictionary format.  There are obviously pros and cons to both options.  Do you wish to discuss this further, or consider the issue closed?",
          "createdAt": "2022-12-20T16:42:07Z",
          "updatedAt": "2022-12-20T16:42:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It seems like there's non-trivial support for switching to an Item. I don't think this header is really deployed anywhere yet, so that shouldn't be an issue -- but I'd like to have some confirmation of that (i.e., has anyone else deployed this, or heard of deploying it?).\r\n\r\nI'll work on a PR so we can compare the options.",
          "createdAt": "2022-12-21T01:39:38Z",
          "updatedAt": "2022-12-21T01:39:38Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOE-NsGs5VJ6sf",
      "title": "Gen-ART editorial comment",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/57",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This paragraph in section 4 struck me oddly:\r\n\r\n>  An extension member (see Section 3.2) MAY occur in the Problem field\r\n  if its name is compatible with the syntax of Dictionary keys (see\r\n  Section 3.2 of [STRUCTURED-FIELDS]) and if the defining problem type\r\n  specifies a Structured Type to serialize the value into.\r\n\r\nThat almost sounds like what you want to say is:\r\n\r\n>  If an extension member (see Section 3.2) occurs in the Problem field,\r\n  its name MUST be compatible with the syntax of Dictionary keys (see\r\n  Section 3.2 of [STRUCTURED-FIELDS]) and the defining problem type\r\n  MUST specify a Structured Type to serialize the value into.\r\n\r\nI'm curious if you are making a normative statement that would get lost in the\r\ncurrent form. But I'm not sure what the high-order bit here is, so I leave it\r\nto you.",
      "createdAt": "2022-10-30T08:04:18Z",
      "updatedAt": "2022-11-29T01:34:31Z",
      "closedAt": "2022-11-29T01:34:31Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "it seems to me that the updated version captures the goal better than the original. after all, we want to disallow fields that aren't well-defined or serializable.\r\na general problem with this snippet (independent of the rewording) is that \"type\" is optional, so technically there isn't always a \"defining problem type\". do we want to address this case explicitly (either in the old or in the new wording)?",
          "createdAt": "2022-10-30T18:50:57Z",
          "updatedAt": "2022-10-30T18:50:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Type is optional, but it defaults to something well-defined, so I don't think that's an issue.",
          "createdAt": "2022-11-29T01:33:45Z",
          "updatedAt": "2022-11-29T01:33:45Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOE-NsGs5VlEvO",
      "title": "ARTART review",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/60",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "General - RFC7807 / RFC 7807 (when used in prose)\r\n\r\nSection 3.1.3 - The entire section is bold in the HTML output.\r\n\r\n  Current:  The \"title\" string is advisory, and is included only \r\n            for users who both are not aware of ...\r\n\r\n  Perhaps: The \"title\" string is advisory and is included only \r\n           for users who are both unaware of ...\r\n\r\nSection 3.2 - a \"errors\" extension / an \"errors\" extension\r\n\r\nSection 7 - IANA prefers that a registry name not include \"Registry\" \r\n\r\nCurrent: \"HTTP Problem Types Registry\"\r\n\r\nPerhaps: \"HTTP Problem Types\" registry",
      "createdAt": "2022-11-04T09:24:14Z",
      "updatedAt": "2022-11-29T01:37:49Z",
      "closedAt": "2022-11-29T01:37:49Z",
      "comments": []
    },
    {
      "number": 61,
      "id": "I_kwDOE-NsGs5VrYyR",
      "title": "To do so",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/61",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "3.1.1:\r\n\r\n>  Non-resolvable URIs ought not be used when there is some future\r\n  possibility that it might become desirable to do so.\r\n\r\nTo this non-native speaker, \"to do so\" points nowhere (well, actually\r\nto using them, but that is a paradox then).\r\nWhat is probably meant is:\r\n\r\n>  Non-resolvable URIs ought not be used when there is some future\r\n  possibility that it might become desirable to be able to resolve\r\n  the URIs.",
      "createdAt": "2022-11-06T15:10:59Z",
      "updatedAt": "2022-11-29T01:38:45Z",
      "closedAt": "2022-11-29T01:38:45Z",
      "comments": [
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "agreed that the proposed wording is clearer.",
          "createdAt": "2022-11-07T14:26:20Z",
          "updatedAt": "2022-11-07T14:26:20Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOE-NsGs5VrY_I",
      "title": "Resolvability of IANA URIs",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/62",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed in Carsten's feedback, we should note that IANA URLs with fragment identifiers are currently not resolveable to the fragment identifier.",
      "createdAt": "2022-11-06T15:13:22Z",
      "updatedAt": "2023-04-23T20:58:12Z",
      "closedAt": "2022-11-29T02:22:30Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we assist IANA in making this a supported use case? From the outset, it seems like supporting fragment identifiers is trivial. I saw the discussion about not being able to mandate an HTML structure and I don't really know enough about IANA's inner workings or process to understand what the problem of supporting fragment identifiers really is. If anyone can elaborate on that, I'd be grateful.",
          "createdAt": "2022-11-08T09:33:02Z",
          "updatedAt": "2022-11-08T09:33:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We can start that discussion this week, but it's a much larger coordination (they'll want to do it for *all* registries), so we shouldn't take a dependency on it.",
          "createdAt": "2022-11-08T09:40:00Z",
          "updatedAt": "2022-11-08T09:40:00Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see. Yeah, that makes sense. How does this fit in with the general UX and design work I've seen IETF has been RFQ-ing about lately? Does the scope of that work include any of IANA's areas? If not, perhaps we can piggyback on the general IETF design to improve the look, feel and UX of IANA's registries?",
          "createdAt": "2022-11-08T09:51:10Z",
          "updatedAt": "2022-11-08T09:51:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "There is a lot of friction there, but we'll see. Please be patient :)",
          "createdAt": "2022-11-08T09:52:24Z",
          "updatedAt": "2022-11-08T09:52:24Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-11-08 01:33, Asbj\u00f8rn Ulsberg wrote:\n> Can we assist IANA in making this a supported use case? From the outset, \n> it seems like supporting fragment identifiers is trivial. I saw the \n> discussion about not being able to mandate an HTML structure and I don't \n> really know enough about IANA's inner workings or process to understand \n> what the problem of supporting fragment identifiers really is. If anyone \n> can elaborate on that, I'd be grateful.\n\niirc this debate has been going on for many years now. i am afraid that \nif we make this draft depend on it being resolved, this will probably \ndelay any further progress for a very long period of time.\n\ni would still love to see the IANA registry pages being created so that \nthey can be more reliably processed. but i think we should strictly \nseparate what's possible today for RFC7807bis, and what we'd ideally \nlike to see for the IANA registry pages.\n",
          "createdAt": "2022-11-08T10:13:27Z",
          "updatedAt": "2022-11-08T10:13:27Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-11-08 01:51, Asbj\u00f8rn Ulsberg wrote:\n> I see. Yeah, that makes sense. How does this fit in with the general UX \n> and design work I've seen IETF has been RFQ-ing about lately? Does the \n> scope of that work include any of IANA's areas? If not, perhaps we can \n> piggyback on the general IETF design to improve the look, feel and UX of \n> IANA's registries?\n\njust piggybacking on a recent trend in the API space i think what we \nshould really try to do is improve the DX of their registry pages: i.e., \ngiven that there isn't an actual registry API (there isn't, right?), \nthen it would be reasonable and probably the easiest way forward to turn \ntheir registry pages into their API.\n\nthey have some good start because they're using XHTML. a long time ago i \ndid experiment a bit with simply processing everything as one XML API. \nthat didn't go great but sort of worked after a bit of clean-up and \nadding some special case rules. i think improving this wouldn't be too \nhard, if they're willing to make that a goal.\n",
          "createdAt": "2022-11-08T10:20:34Z",
          "updatedAt": "2022-11-08T10:20:34Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "It's not a small change, but I wonder if theres any benefit in making those\npages instead be just XML files that then link to an appropriate XSLT\nstylesheet whichi re-renders them as HTML for browsers? That way, API\nconsumers could get the XML version instead and have a slightly easier time\nparsing them, whilst human consumers still get to see them in an\neasier-to-read format in their browsers.\n\nCheers\n-- \nGraham Cox\n\nOn Tue, 8 Nov 2022 at 10:20, Erik Wilde ***@***.***> wrote:\n\n> On 2022-11-08 01:51, Asbj\u00f8rn Ulsberg wrote:\n> > I see. Yeah, that makes sense. How does this fit in with the general UX\n> > and design work I've seen IETF has been RFQ-ing about lately? Does the\n> > scope of that work include any of IANA's areas? If not, perhaps we can\n> > piggyback on the general IETF design to improve the look, feel and UX of\n> > IANA's registries?\n>\n> just piggybacking on a recent trend in the API space i think what we\n> should really try to do is improve the DX of their registry pages: i.e.,\n> given that there isn't an actual registry API (there isn't, right?),\n> then it would be reasonable and probably the easiest way forward to turn\n> their registry pages into their API.\n>\n> they have some good start because they're using XHTML. a long time ago i\n> did experiment a bit with simply processing everything as one XML API.\n> that didn't go great but sort of worked after a bit of clean-up and\n> adding some special case rules. i think improving this wouldn't be too\n> hard, if they're willing to make that a goal.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-httpapi/rfc7807bis/issues/62#issuecomment-1306973043>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAQEGDI3PNEWTET36Z66JTWHISPZANCNFSM6AAAAAARYPAIZM>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n",
          "createdAt": "2022-11-08T10:53:50Z",
          "updatedAt": "2022-11-08T10:53:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please understand that how IANA does its job is regulated by a contract and some oversight bodies, and so we can't go in and say 'do it this way.' We can start that process but it's not going to happen on this issue. Let's constrain this discussion to what should happen in _this_ specification.",
          "createdAt": "2022-11-08T13:38:16Z",
          "updatedAt": "2022-11-08T13:38:16Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "> As discussed in Carsten's feedback, we should note that IANA URLs with fragment identifiers are currently not resolveable to the fragment identifier.\r\n\r\nRecord keeping nit: is there a link to that discussion which can be addd to this issue?",
          "createdAt": "2023-04-22T17:04:49Z",
          "updatedAt": "2023-04-22T17:04:49Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@sdatspun2 I believe this is the thread https://mailarchive.ietf.org/arch/msg/httpapi/AGCGu1xzdZdJ3ntsfzwUnxo4LNY/",
          "createdAt": "2023-04-23T20:58:12Z",
          "updatedAt": "2023-04-23T20:58:12Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOE-NsGs5VrZVX",
      "title": "Resolveability text",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/63",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From Carsten:\r\n\r\n> The specification is a bit wobbly on whether type URIs should be\r\nresolvable -- it explains the possibility, immediately explains an\r\nevolvability problem with non-resolvable type URIs, and then later has\r\na SHOULD for being resolvable.",
      "createdAt": "2022-11-06T15:17:57Z",
      "updatedAt": "2022-11-29T02:27:11Z",
      "closedAt": "2022-11-29T02:27:11Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": ">     The specification is a bit wobbly on whether type URIs should be\n>     resolvable -- it explains the possibility, immediately explains an\n>     evolvability problem with non-resolvable type URIs, and then later has\n>     a SHOULD for being resolvable.\n\nin my mind, advocacy for resolvable URIs could be less pronounced. we \nhave made a choice to use type URIs as identifiers, and describing all \nthe things that they could also be might be more confusing than it is \nhelpful.\n",
          "createdAt": "2022-11-06T18:57:55Z",
          "updatedAt": "2022-11-06T18:57:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right now we say:\r\n\r\n> A non-resolvable URI ought not be used when there is some future possibility that it might become desirable to be able to resolve the URI. For example, if an API designer used the URI above and later adopted a tool that resolves type URIs to discover information about the error, taking advantage of that capability would require switching to a resolvable URI, creating a new identity for the problem type and thus introducing a breaking change.\r\n\r\nand then:\r\n\r\n> A problem's type URI SHOULD resolve to HTML {{HTML5}} documentation that explains how to resolve the problem.\r\n\r\n\r\nI'll make a small change to align this a bit better. I don't think we should revisit / weaken this, it'd just involve more going around. Let's respect the consensus we found.",
          "createdAt": "2022-11-29T02:25:12Z",
          "updatedAt": "2022-11-29T02:25:12Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOE-NsGs5VvPCd",
      "title": "Uncertainty created by relative URIs used as IDs for problem \"type\" field",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/64",
      "state": "CLOSED",
      "author": "benbucksch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "You are specifying problem \"type\" IDs as URIs. That's a good idea, it allows for scoping and teams to assign their own error IDs.\r\n\r\nHowever, allowing relative URIs creates significant real world problems:\r\n* Most of the time, parsing of the errors will be adhoc. The chances that the client does not resolve the relative URLs into absolute URLs is high. This creates potential for conflict and/or multiple IDs.\r\n* APIs may be available on different endpoints (URLs). Depending on the endpoint, that would create different IDs. That is not desirable. For a realistic example, a dev uses a small npm lib to parse Problem errors, and the lib correctly resolves the relative URI in \"type\" into absolute URIs. The dev treats errors based on these these types with absolute URIs. He and QA are testing against a dev or staging server and they do not know or realize that the production server will have a different API endpoint URL. So, it works in testing, but fails in production. This is a likely scenario. Reliable testing would be difficult. Using relative URI for \"type\" is setting up for such a problem.\r\n\r\nI would recommend to either\r\n1) mandate absolute URIs\r\nor alternatively to\r\n2) define the ID as free-form generic string. In the latter case, relative URLs would not be resolved, but everybody would use them as strings - which is what likely happens in reality anyways.\r\n",
      "createdAt": "2022-11-07T14:18:59Z",
      "updatedAt": "2022-12-22T09:19:17Z",
      "closedAt": "2022-12-20T16:38:50Z",
      "comments": [
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@benbucksch I don't think you will get any disagreement from the folks lurking here that type should be an absolute URI, however there is a significant amount of community feedback that requiring an absolute URI would impact adoption https://github.com/ietf-wg-httpapi/rfc7807bis/issues/11\r\n\r\nIt would also be a breaking change to RFC 7807 which would fragment the ecosystem and require a new media type registration.\r\n\r\n",
          "createdAt": "2022-11-07T15:18:00Z",
          "updatedAt": "2022-11-07T15:18:00Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "@darrelmiller Thanks for the link to #11 and the Twitter thread quoted there. I can surely see why absolute URIs are unpopular. That is esp. true when there is an expectation that they are resolvable or might be resolvable in the future. It immediately triggers an internal discussion about which hostname to use, which format, which URL is the most stable to host long-term etc.pp., and that internal discussion causes considerable delay and internal friction. So, I can see why pure strings for \"type\" are more popular and make adoption of the spec far easier.\r\n\r\nThis issue is not contradicting #11. Rather, this issue is about relative URIs specifically. We should avoid the use of relative URIs in this particular use case. While they seem like an elegant solution to allow simple strings, they are actually harmful here in specific situation. To put it into a punchline: _Stable and relative doesn't match well._\r\n\r\nCommon practice is that API endpoint URLs are configurable, and to have different endpoints for testing and production environments, so using relative URIs pretty much *guarantees* that the \"type\" IDs are not stable, and even change between testing and production environment, which leads to serious problems. The worst kind of bugs are which the customer sees, but the dev cannot reproduce in his dev environment, and the relative URIs (if they are processed in a spec-conforming way) are provoking exactly that scenario.",
          "createdAt": "2022-11-08T19:14:14Z",
          "updatedAt": "2022-11-08T19:35:52Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "I can see the following possible solutions:\r\n\r\n1. Demand that \"type\" is always an absolute URI.\r\n  * Based on [#11](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/11), I can see why that is a non-starter, so let's forget about that option and move on to other solutions.\r\n2. Define \"type\" to be an arbitrary string.\r\n  * This allows for absolute URIs, but also allows more relaxed assignment of error IDs.\r\n  * It is easier to parse, because it removes the requirement to resolve relative URIs to absolute URIs in order to get the actual type.\r\n  * It is more stable than relative URIs, because relative URIs are pretty much guaranteed to change.\r\n3. Remove the recommendation that the type ID is a resolvable URI with error documentation, and instead add a second \"documentation\" field with a link. This removes the coupling between the ID, which needs stability, and hosting of webpages. Very few orgs in this world are capable of guaranting their web URLs to be stable over the next 20 years. Many don't even know what happens in 2 months.\r\n\r\nI would recommend options 2 and 3 above. It's easy to use, it's backwards-compatible, and relaxes the discussions of web hosting before assigning error IDs.\r\n\r\nIt also allows devs to easily add new error IDs without worrying about creating a web page for it, translating it, etc. This is turn avoids that devs lump multiple errors into the same type ID, which defeats the purpose.",
          "createdAt": "2022-11-08T19:18:36Z",
          "updatedAt": "2022-11-08T19:28:20Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, @benbucksch. On e-mail to the list, you wrote:\r\n\r\n>As mentioned in my feedback, I would recommend to *not* couple resolvable description webpage URLs and stable error type IDs. If even IANA has troubles providing this right now, can you imagine the discussions in companies and within projects?\r\n\r\nAs RFC 7807 is from 2016, that discussion has been ongoing for more than 6 years and I haven't seen any convincing arguments during that time to change how `type` works.\r\n\r\n> Just publishing anything on the website is often a major process for many companies. And then guaranteeing stability on top of that\u2026\r\n\r\nGuaranteeing stability of `type` URIs is no more difficult than guaranteeing stability of URIs used in an API. As most HTTP APIs today are not hypermedia-driven, clients hard-code URIs and thus require them to be stable.\r\n\r\n> Even if the webpage is optional, there'll be the discussion that we might in the future make a page, so better choose wisely now... But which hostname? Which URL form?\r\n\r\nMy recommendation is to use the same base URI as in the API for `type` URIs. For example:\r\n\r\n```\r\nhttps://api.example.com/problems/out-of-funds\r\n```\r\n\r\nSince `problems` now is a programmable resource within the API, it's easy to redirect from the above URI to:\r\n\r\n```\r\nhttps://www.example.com/docs/reference/problem-types\r\n```\r\n\r\nWhenever the URI of the documentation changes, it's just to change the coded redirection within the `problems` resource. Simple, no?",
          "createdAt": "2022-11-14T08:28:18Z",
          "updatedAt": "2022-11-14T08:28:18Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> As RFC 7807 is from 2016\r\n\r\nAnd neither PayPal nor Stripe nor any other API that I ran into uses it.\r\n\r\n@asbjornu The problems mentioned in the initial comment are real. Let's please try to solve them. I've made a few suggestions.",
          "createdAt": "2022-11-14T12:39:49Z",
          "updatedAt": "2022-11-14T12:39:49Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> Demand that \"type\" is always an absolute URI\r\n\r\nIf this is a concern in your implementation, then you can use (full) URIs, I'm not sure how mandating them for everyone resolves an interoperability concern.\r\n\r\n(Small nit: \"absolute URI\" is an ambiguous term, it can refer to either the fragmentless URI like what HTTP servers receive, or what we would normally call just a URI as opposed to a URI reference.)\r\n\r\n> Define \"type\" to be an arbitrary string\r\n\r\nThis would break implementations that use URI references: You should be able to use URIs and URI references interchangeably. It would also create a namespace collision, since \"type\" is supposed to be globally unique.\r\n\r\n> Remove the recommendation that the type ID is a resolvable URI with error documentation, and instead add a second \"documentation\" field with a link\r\n\r\nI'm not sure this fixes the problem? Though it is true that the URI identifying the error type, and a document _about_ the error type, are not necessarily the same resource.",
          "createdAt": "2022-11-25T21:50:03Z",
          "updatedAt": "2022-11-25T21:50:03Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> in your implementation\r\n\r\nI'm not talking about myself, but about typical professional setups. Almost all pro setups will have a staging environment for testing before going into production, and they are all affected.",
          "createdAt": "2022-11-25T21:54:45Z",
          "updatedAt": "2022-11-25T21:54:45Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@benbucksch My point applies regardless of who \"you\" is; if a URI reference in your staging environment isn't the behavior you want, then use a URI instead. I don't think it makes sense to say \"URI references don't make sense in some situations therefore they should be prohibited.\" What about the situations where they do make sense?\r\n\r\nAlso note that multiple different URIs are allowed to identify the same resource; and likewise, two URIs that are different don't necessarily identify different resources. Resolving multiple different URIs that identify the same type is by no means wrong.",
          "createdAt": "2022-11-26T00:19:36Z",
          "updatedAt": "2022-11-26T06:55:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@benbucksch the specification already warns about the issues involved when relative URIs are used. Given the constraints that others have mentioned, I don't think we can do much more.\r\n\r\nIf you can suggest ways to improve those warnings, that'd be helpful. ",
          "createdAt": "2022-11-29T01:23:36Z",
          "updatedAt": "2022-11-29T01:23:36Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Closing this issue.  @benbucksch if you have suggestions on how to improve the warning, feel free to re-open.  ",
          "createdAt": "2022-12-20T16:38:50Z",
          "updatedAt": "2022-12-20T16:38:50Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "The issue I reported is a real-world problem. Whatever the solution, there needs to be some kind of solution that addresses the issue.\r\n\r\nIf none of the suggestions are acceptable, and nobody has a better idea, then the safest option is to deprecate relative URLs in the ID field, for the harm that they can cause.\r\n\r\n\"\r\n@deprecated Simple string and relative URLs in the type field are deprecated. Some existing software might still use it, but such software should be changed to use absolute URIs instead.\r\nIf you use relative URLs in the type field, and the client correctly resolves it into an absolute URL, and then processes the type further, and you have a testing and production setup on different hostnames or different URLs, then the client may behave differently in production than in testing. Some error handling may work in your testing environment, but will not work in production. To avoid such surprises, relative URLs are discouraged and should no longer be used.\r\nA simple solution is to use your company's domain name, and your app name, and construct a non-resolvable URI like \"https://error.example.com/myapp/file-not-found\" and use this as type.\r\n\"\r\n\r\n@darrelmiller I do not have the ability/rights to re-open.",
          "createdAt": "2022-12-20T19:26:46Z",
          "updatedAt": "2022-12-20T19:26:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's not a suggestion for improved wording, that's recycling a proposal that failed to get consensus.",
          "createdAt": "2022-12-21T01:26:03Z",
          "updatedAt": "2022-12-21T01:26:03Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "If you have any other suggestion how to **fix** the original issue, I'd be happy to hear it.",
          "createdAt": "2022-12-21T14:10:02Z",
          "updatedAt": "2022-12-21T14:10:02Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@benbucksch Both of the identified \"problems\" are useful features that people might want to rely on, you're just pointing out that some people might not use them correctly, but I'm not sure that implies \"deprecating\" is a solution.\r\n\r\nIf the feature is too confusing for you then don't use it; you can guarantee to your clients you'll always use a URI.\r\n\r\nHave you personally seen these \"real world\" problems?",
          "createdAt": "2022-12-21T23:03:55Z",
          "updatedAt": "2022-12-21T23:03:55Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> If the feature is too confusing for you\r\n\r\nIt is not. As I stated [above already in response to you](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/64#issuecomment-1327903469), this issue is not about me personally.\r\n\r\nYou're questioning the scope of the problem.\r\nThe scenario I outlined is a problem for **everybody** who\r\n* uses relative URLs as type ID (100% of people concerned by relative URIs discussed here)\r\n* correctly resolves them on the client (100% of people who use the spec as specced)\r\n* has specific error handling for some specific errors, which he recognizes based on the type as absolute URI, as the spec intended (again, all the people who do error handling and use the spec correctly as intended), and\r\n* has a separate qa/testing/staging and production server setup (i.e. everybody with a proper testing setup), (or the same API is available on multiple endpoints/server URLs for any other reason).\r\n",
          "createdAt": "2022-12-21T23:33:23Z",
          "updatedAt": "2022-12-22T00:04:14Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@benbucksch Well, again, my point applies regardless of who \"you\" is. But also you said \"real world\", as if this is a problem you've seen previously.\r\n\r\n> The scenario I outlined is a problem for everybody who\r\n\r\nThe scenario you outlined is one where the application should use a constant, full URI and not a URI reference. That solves the problem without removing a feature that's useful for other people.\r\n\r\nWhat you have to explain is why you (in your hypothetical) are using a URI reference instead of a full URI, then why removing URI reference resolution is the solution to this problem instead of just changing to a full URI in the Problem document.\r\n\r\nThe fact that lots of file formats use relative URI references without these problems also suggests to me this is a hypothetical problem and not a real one; you have to also explain what's unique about this specification that doesn't apply to anywhere else URI references are deployed.",
          "createdAt": "2022-12-22T08:35:37Z",
          "updatedAt": "2022-12-22T08:35:37Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-12-22 09:35, Austin Wright wrote:\n> What you have to explain is why you (in your hypothetical) are using a \n> URI reference instead of a full URI, then why removing URI reference \n> resolution is the solution to this problem instead of just changing to a \n> full URI in the Problem document.\n\nwhat seems to be repeatedly getting lost in this never-ending discussion \nis that this is a revision of an existing spec. breaking changes are not \non the table. deprecating existing features is not an option. the \nrevision has added cautionary text and that's all that possibly can be done.\n\nhappy holidays everybody!\n\n-- \nErik Wilde | ***@***.***    |\n            | https://youtube.com/ErikWilde |\n",
          "createdAt": "2022-12-22T09:19:17Z",
          "updatedAt": "2022-12-22T09:19:17Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOE-NsGs5VvPPo",
      "title": "Avoid a default \"type\"",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/65",
      "state": "CLOSED",
      "author": "benbucksch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "Remove: `When this member is not present, its value is assumed to be [\"about:blank\"](about:blank).`\r\n\r\nRationale: This would **require** (!) conforming clients to lump all non-typed errors together into one error type. Better to leave this unspecced and allow the client to make sense of it.",
      "createdAt": "2022-11-07T14:19:29Z",
      "updatedAt": "2023-04-20T13:22:49Z",
      "closedAt": "2022-11-29T01:42:02Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-11-07 06:19, Ben Bucksch wrote:\n> Remove: |When this member is not present, its value is assumed to be \n> [\"about:blank\"](about:blank).|\n> \n> Rationale: This would *require* (!) conforming clients to lump all \n> non-typed errors together into one error. Better to leave this unspecced \n> and allow the client to make sense of it.\n\nthis may fall victim to compatibility considerations. RFC 7807 defines \nabout:blank as being a \"default error\": \nhttps://www.rfc-editor.org/rfc/rfc7807#section-4.2\n\nif we introduce a second \"default\" (not about:blank but the one where \nthe type is absent) then that introduces the questions how these two \ndefaults relate. it seems to be simpler to just keep the one default \nthat we have and that we cannot take away.\n",
          "createdAt": "2022-11-07T17:33:29Z",
          "updatedAt": "2022-11-07T17:33:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We can't change this without changing the media type, and it's too late to do that. Closing.",
          "createdAt": "2022-11-29T01:42:02Z",
          "updatedAt": "2022-11-29T01:42:02Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOE-NsGs5VvPpt",
      "title": "Translation",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/66",
      "state": "CLOSED",
      "author": "benbucksch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There needs to be clarity which party is expected to translate the message. Leaving this undefined can lead to problems in practice.\r\n\r\na) If both client and server try to translate, it can cause chaos.\r\nb) Generic usage of a third party server API - which is the goal of an IETF spec - means that the client cannot possibly know all the error types.\r\nc) Even if all error types were known, all clients would need to translate the same strings\r\nd) The server may need to add new error types at any time.\r\n(See also next point 4 for importance.)\r\n\r\nCurrent spec: \"title\" is defined as `a short, human-readable summary of the problem type`, and \"detail\" is defined as `human-readable explanation specific to this occurrence of the problem`. It allows localization of \"title\" by stating `it SHOULD NOT change..., except for localization`, but it's only an allowance.\r\n\r\nImplication: Therefore, a client cannot rely on the error messages to be useful for the user. Given that for many errors, the only possible recourse is to show the error to the end user, translation is a real world problem. The client needs to rely on the error string to be useful for the user.\r\n\r\nRecommendation:\r\n```\r\nIf error strings are translated at all, it is expected that the localization happens on the server side\r\nand the server sends localized strings for \"type\", \"detail\" and custom fields, based on the\r\n\"Accept-Language:\" HTTP header sent by the client.\r\n\r\nRationale: The server is better suited to perform language-specific variable insertion in the \"detail\" field.\r\nIt allows for processing of errors from generic third party servers, and allows the server to add new\r\nerror types without prior arranging with the client.\r\n```\r\n",
      "createdAt": "2022-11-07T14:20:39Z",
      "updatedAt": "2022-11-29T01:48:31Z",
      "closedAt": "2022-11-29T01:48:31Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOE-NsGs5VvQFr",
      "title": "`Problem:` HTTP header field and localization",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/67",
      "state": "CLOSED",
      "author": "benbucksch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The spec currently states: `The title and detail values MUST NOT be serialized in the Problem field if they contain characters that are not allowed by String; see {{Section 3.3.3 of STRUCTURED-FIELDS}}. Practically, this has the effect of limiting them to ASCII strings.`\r\n\r\nI understand that the limitation to ASCII is imposed by prior existing specs. However, mandating error strings to be in English (which is what ASCII means in practice) is not very helpful for the purposes of this specification.\r\nImportance: Errors strings need to be helpful for the user and allow them to correct the problem. If they are in a language that the user does not understand, they are unlikely to be helpful. This in turn leaves the end user frustrated. Messages that are potentially important for the end user MUST be translated into the user's language.\r\n\r\nYou could specify an escaping mechanism which allows for escaping of Unicode characters to be expressed with ASCII, e.g. a JSON string (RFC 4627 Point 2.5, Paragr. 2, \"\\u005C\").\r\nRecommendation: `The Problem: HTTP header field is a JSON string. Non-ASCII Unicode characters MUST be escaped, because HTTP Headers require ASCII.` (This would probably need a lot more tweaking.)\r\n\r\nIf it is not reasonably possible to convey in the HTTP header field, I would recommend to remove this transmission method entirely.",
      "createdAt": "2022-11-07T14:21:58Z",
      "updatedAt": "2023-01-27T08:36:59Z",
      "closedAt": "2023-01-27T02:01:43Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Repeating what I said in email somewhere else: this invents yet another way to express non-ASCII in structured fields; I believe HTTPAPI and HTTP working groups should come up with a common solution that does not require out-of-band informatio about the format.\r\n\r\nThe alternative would be to remove the \"title\" parameter altogether; a common argument *against* support of non-ASCII characters in structured fields is that header fields are not a good place for human-readable information.",
          "createdAt": "2023-01-22T15:44:00Z",
          "updatedAt": "2023-01-22T15:44:00Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "It does feel weird for RFC 8941 to say\r\n\r\n> When it is necessary for a field value to convey non-ASCII content, a Byte Sequence ([Section 3.3.5](https://datatracker.ietf.org/doc/html/rfc8941#binary)) can be specified, along with a character encoding (preferably UTF-8 [[STD63](https://www.rfc-editor.org/info/std63)]).\r\n\r\nand then have RFC7807bis provide different guidance.  Is it common for SF implementations to provide functions to encode strings with non-ASCII characters into strings with Byte Sequences?  If so, wouldn't it be more natural to use the SF implementation do the encoding.",
          "createdAt": "2023-01-22T15:59:08Z",
          "updatedAt": "2023-01-22T16:11:54Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed. I think we (that is the HTTP WG) should define a common approach that does not require out-of-band information (from the perspective of a Sf parser/serializer).",
          "createdAt": "2023-01-22T16:48:02Z",
          "updatedAt": "2023-01-22T16:48:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "hello.\n\nOn 2023-01-22 17:48, Julian Reschke wrote:\n> Indeed. I think we should define a common approach that does not require \n> out-of-band information (from the perspective of a Sf parser/serializer).\n\nit would be fantastic if we could all agree on SF not being the next \nmaslow hammer. it's a good idea, but it also is something that apart \nfrom the usual suspects (insert your favorite CDN name here) won't be \nsuch a natural thing to support for the foreseeable future.\n\ni am a bit worried because i have seen SF very enthusiastically being \nsold as \"this is how things are now, better adjust to it\". it's a good \nidea, but we also have to get used to the idea that there's tooling out \nthere that for the next few years (at the very least) won't be able to \ncope with it. reality is annoyingly complex if we step away from the \nviews of large players.\n\nso as much as i like the idea of a foundation that HTTP header fields \ncould/should build on going forward, it seems to me that the view of how \nmuch backwards compatibility we need is a bit skewed.\n\nin the HTTP API working group we have pretty much being blocked when the \nclear consensus (as counted by people saying \"looks good to me\") was \noverwritten by people playing the spec card (SF is the new thing, \nnothing else can be done). it's a delicate balance to get right, but it \ndoesn't feel like we're getting it right so far.\n\ncheers,\n\ndret.\n\n-- \nErik Wilde | ***@***.***    |\n            | https://youtube.com/ErikWilde |\n",
          "createdAt": "2023-01-22T16:59:57Z",
          "updatedAt": "2023-01-22T16:59:57Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FTR, I disagree with that view of things. The lack of standardized parsing for field values has been a major pain in the past. So something like SF is definively we need to use *and* improve.",
          "createdAt": "2023-01-23T10:43:44Z",
          "updatedAt": "2023-01-23T10:43:44Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2023-01-23 11:43, Julian Reschke wrote:\n> FTR, I disagree with that view of things. The lack of standardized \n> parsing for field values has been a major pain in the past. So something \n> like SF is definively we need to use /and/ improve.\n\nyes, this needs to be used and improved. but we also have to embrace the \nfact that for many years going forward, we will have software out there \nthat doesn't support SF, that's just the reality of APIs.\n\nthe API space is structurally very different from the browser space. \ninstead of having very few CDN players being intermediaries, there are \nmany different API management products in place in many different \nplaces, and many of them cannot and will not be easily updated to deal \nwith SF.\n\nso yes, let's move things towards SF. but let's also be mindful that we \nshouldn't assume that everybody will support SF very soon. that's just \nnot going to happen, no matter how nice it would be if it did.\n\n-- \nErik Wilde | ***@***.***    |\n            | https://youtube.com/ErikWilde |\n",
          "createdAt": "2023-01-23T10:52:13Z",
          "updatedAt": "2023-01-23T10:52:13Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> in the HTTP API working group we have pretty much being blocked when the\r\n> clear consensus (as counted by people saying \"looks good to me\") was\r\n> overwritten by people playing the spec card (SF is the new thing,\r\n> nothing else can be done).\r\n\r\nI concur with Erik / dret here. I am surprised to hear that SF was chosen *against* the consensus.  L10n is just one of the problems.\r\n\r\nTo get back to the point here: Restricting field values (not field names) to ASCII was bad in 1980. In 2023, it's just missing reality. Localized error messages are mandatory since 1992 or so. So, either SF can support Unicode, or it's not fit.",
          "createdAt": "2023-01-23T12:13:39Z",
          "updatedAt": "2023-01-24T11:59:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "CC @tfpauly as HTTP WG chair who's in charge here.\r\n\r\nThe HTTP Working Group has discussed that extensively and come to a conclusion; it's not helpful to restart the discussion in a separate Working Group and not even link to that. \r\n\r\nSee: https://github.com/httpwg/http-extensions/issues/2343\r\n\r\nRegarding the suggestion -- removing `title` would require removing `detail` as well. That would reduce some of the utility of the field; not sure how much.\r\n\r\nAlternatively, we could remove the field altogether; it was added somewhat speculatively, and if it's causing this much trouble, perhaps it was premature.",
          "createdAt": "2023-01-24T05:16:14Z",
          "updatedAt": "2023-01-24T05:16:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm in favor of removing the field for now if it helps us getting this revision out of the door.",
          "createdAt": "2023-01-24T05:53:59Z",
          "updatedAt": "2023-01-24T05:53:59Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree. Let's remove the header field and revisit once we have ironed out all of the issues that have been highlighted during this discussion.",
          "createdAt": "2023-01-24T11:00:48Z",
          "updatedAt": "2023-01-24T11:00:48Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": ">I understand that the limitation to ASCII is imposed by prior existing specs. However, mandating error strings to be in English (which is what ASCII means in practice) is not very helpful for the purposes of this specification.\r\nImportance: Errors strings need to be helpful for the user and allow them to correct the problem. If they are in a language that the user does not understand, they are unlikely to be helpful. This in turn leaves the end user frustrated. Messages that are potentially important for the end user MUST be translated into the user's language.\r\n\r\nShould the Problem Details recognize (not ignore) Accept-Language?\r\n",
          "createdAt": "2023-01-24T15:32:54Z",
          "updatedAt": "2023-01-24T15:32:54Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> Should the Problem Details recognize (not ignore) Accept-Language?\r\n\r\nYes, the [current (adapted) draft](https://github.com/ietf-wg-httpapi/rfc7807bis/blob/e3b445536d86efdfd6a6b4d7956ae1b0a5df8ce6/draft-ietf-httpapi-rfc7807bis.md) says this explicitly:\r\n\"the language used for human-readable strings (such as those in title and description) can be negotiated using the Accept-Language request header field\"",
          "createdAt": "2023-01-24T16:07:30Z",
          "updatedAt": "2023-01-24T16:07:46Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool, I missed all the fun discussion but glad to know it is incorporated. I am switching to whole repo notifications for this repo and 2 more so I don't miss such. ",
          "createdAt": "2023-01-24T16:16:03Z",
          "updatedAt": "2023-01-24T16:16:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, let's remove the field -- we can always reintroduce it separately.",
          "createdAt": "2023-01-24T23:06:20Z",
          "updatedAt": "2023-01-24T23:06:20Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> OK, let's remove the field\r\n\r\nIf this is the only thing holding publication back then I suppose so... but at the same time, I'm disappointed it would come to this; the header is the part I'm most excited about.\r\n\r\n---\r\n\r\nI think adding an encoding step to sf-string negates most of the advantages of Structured Fields. I don't see anyone implementing that step correctly. I still haven't implemented it.\r\n\r\nBut there is another format that has already solved this problem... In issue #56 I suggested that we re-use the syntax of the Link header, e.g.:\r\n\r\n```\r\nProblem: <http://example.com/api/enhance-your-calm>;\r\n       title*=UTF-8'ja'%E8%90%BD%E3%81%A1%E7%9D%80%E3%81%8D%E3%82%92%E9%AB%98%E3%82%81%E3%81%A6\r\n```\r\n\r\nI understand the other advantage of Structured Fields is supposed to be that the types are self-descriptive (like in JSON, where you don't need a schema to distinguish a boolean from a number, the encodings of both are completely disjoint)... But if we're going to add processing steps for some strings but not others, that frustrates this goal: Some \"strings\" have to be decoded, and some don't, and you have to know the \"schema\" of the field to know the correct behavior. _What would the benefit of structured fields be, then?_\r\n\r\nAnd we have to apply validation to the end result _anyways_, so in the end I don't see any advantage over defining an ABNF.\r\n\r\n> FTR, I disagree with that view of things. The lack of standardized parsing for field values has been a major pain in the past. So something like SF is definively we need to use and improve.\r\n\r\nBut the parsing of field values _is_ standardized, though. There is _exactly_ one correct way to parse a string according to an ABNF. Not only that, but an ABNF is provable... it's possible to look at an implementation, and generate an ABNF (or sometimes regular expression) of all of the strings that the implementation accepts that it should reject, and vice-versa. (In compliant implementations this result will be empty.) It is some complicated math, but it is straightforward.\r\n\r\nIf implementations aren't implementing the ABNF correctly, I'm not sure why I should trust Structured Fields to be any better. I think most of the advantages in practice can be attributed to the test suites and stricter error handling/interoperability requirements.",
          "createdAt": "2023-01-25T07:42:02Z",
          "updatedAt": "2023-01-25T07:42:02Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think most of the advantages in practice can be attributed to the test suites and stricter error handling/interoperability requirements.\r\n\r\nYes. So how do you achieve that when your proposal is to re-use an existing Link header field parser?",
          "createdAt": "2023-01-25T09:41:36Z",
          "updatedAt": "2023-01-25T09:41:36Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "> So how do you achieve that when your proposal is to re-use an existing Link header field parser?\r\n\r\nYou'd achieve it by publishing test cases for the ABNF.\r\n\r\nI'm not sure what additional interoperability requirements would look like exactly, except an option to report a syntax error.\r\n\r\nIf I drew up a comprehensive list of tests, would that be persuasive at all?",
          "createdAt": "2023-01-25T19:25:36Z",
          "updatedAt": "2023-01-25T19:25:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What would be the benefit over SF?",
          "createdAt": "2023-01-26T06:30:14Z",
          "updatedAt": "2023-01-26T06:30:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Reusing that syntax is a non-starter; doing so would further fragment the landscape.",
          "createdAt": "2023-01-27T01:56:03Z",
          "updatedAt": "2023-01-27T01:56:03Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "@reschke I listed the benefits [above](https://github.com/ietf-wg-httpapi/rfc7807bis/issues/67#issuecomment-1403213007)... In particular, the Link syntax natively supports internationalized parameters, and I gave one example of what that would look like.\r\n\r\nThere's also benefits _in general_... SF will bring more cases of problems resembling \"impedance mismatches\" and headers that require context-based parsing, which a pure ABNF solution would avoid from the beginning. Headers defined with an ABNF can be compressed more compactly than SF.\r\n\r\nSome of my expertise is in parsing JSON, in languages for defining grammars like ABNF, and the overlap of the two (i.e. JSON Schema). If \"SF Schema\" is a phrase that makes you shudder, then I would like to share some research you'd probably be interested in.\r\n\r\n@mnot Could you briefly explain what you mean? I suggested the Link syntax precisely to _avoid_ fragmentation (it's a well-established syntax).",
          "createdAt": "2023-01-27T07:52:14Z",
          "updatedAt": "2023-01-27T07:52:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @reschke I listed the benefits https://github.com/ietf-wg-httpapi/rfc7807bis/issues/67#issuecomment-1403213007... In particular, the Link syntax natively supports internationalized parameters, and I gave one example of what that would look like.\r\n\r\nI'm very aware of that, look at the author list for RFC 8187. The same syntax could be used with SF, for what it's worth (if the string has a key). There's a reason why key names in SF support \"*\" (https://httpwg.org/specs/rfc8941.html#param).\r\n\r\n> There's also benefits in general... SF will bring more cases of problems resembling \"impedance mismatches\" and headers that require context-based parsing, which a pure ABNF solution would avoid from the beginning. Headers defined with an ABNF can be compressed more compactly than SF.\r\n\r\nI have really no idea what you're talking about here.\r\n\r\n> @mnot Could you briefly explain what you mean? I suggested the Link syntax precisely to avoid fragmentation (it's a well-established syntax).\r\n\r\nIt's well established, but has poor parsers.\r\n\r\n",
          "createdAt": "2023-01-27T08:04:46Z",
          "updatedAt": "2023-01-27T08:04:46Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "\r\n\r\n> I have really no idea what you're talking about here.\r\n\r\nI'm suggesting that there's _many_ drawbacks to SF, but I'm not sure what you're looking for, or what you would find persuasive, and I'd have to go into some depth to explain.\r\n\r\nAs two examples, I'm saying we will run into endless problems just like this, where there's not a clean way to represent some aspects of HTTP semantics, actually making things more complicated instead of less. And since one of the selling points of SF is the idea of a binary packing, it turns out SF cannot be compressed better than an ABNF that does the same functions, and you can show this mathematically.\r\n\r\nI'm not going to be able to make a compelling point in one comment... but if I wrote up a comprehensive email to the list detailing my findings, would you review it?\r\n\r\n> It's well established, but has poor parsers.\r\n\r\nThis is why I was asking about test suites... If I showed that the parsers could be improved to the same level as SF, would that be persuasive?",
          "createdAt": "2023-01-27T08:31:40Z",
          "updatedAt": "2023-01-27T08:31:40Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, please do that on the HTTP WG's mailing list. IMHO we should focus on fixing issues in SF, not inventing something new once again.\r\n\r\nFWIW, letting people \"parse\" field values based on substring matches or broken regexps is the problem we need to solve. Everytime we define a new syntax, we make things worse.",
          "createdAt": "2023-01-27T08:36:59Z",
          "updatedAt": "2023-01-27T08:36:59Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOE-NsGs5dRPI7",
      "title": "replace mnot.com with example.com, etc",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/71",
      "state": "CLOSED",
      "author": "richsalz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From Murray, ART AD:  \"As part of my AD review, I suggested that the `mnot.net` example in Section 3.1.1 should be replaced by a more standard `example.com` or `example.org`, in accordance with BCP 32.  Any reason why the WG wants to stick with using a private use domain name here?",
      "createdAt": "2023-01-31T18:19:41Z",
      "updatedAt": "2023-04-13T00:11:35Z",
      "closedAt": "2023-04-13T00:11:35Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOE-NsGs5efJTZ",
      "title": "Update JSON Schema refs to HTTP, etc.",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/72",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2023-02-15T05:04:07Z",
      "updatedAt": "2023-04-13T00:10:30Z",
      "closedAt": "2023-04-13T00:10:30Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOE-NsGs5f5oG5",
      "title": "\"*\" names for new members are not going to work in XML",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/74",
      "state": "OPEN",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "These two paragraphs read a little funny in conjunction, given that the first one announces that the spec may start using names that are against the guidance in the second paragraph.\r\n\r\n> Future updates to this specification might define additional members that are available to all problem types, distinguished by a name starting with \"*\". To avoid conflicts, extension member names SHOULD NOT start with the \"*\" character.When creating extensions, problem type authors should choose their names carefully.\r\n> \r\n> To be used in the XML format (see [Appendix B](https://www.ietf.org/archive/id/draft-ietf-httpapi-rfc7807bis-06.html#xml-syntax)), they will need to conform to the Name rule in [Section 2.3](https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name) of [[XML](https://www.ietf.org/archive/id/draft-ietf-httpapi-rfc7807bis-06.html#XML)].\r\n\r\nI have no great idea how to improve this, but reading through the text just made me wonder how these two things fit together and others may have the same reaction.",
      "createdAt": "2023-03-03T16:40:20Z",
      "updatedAt": "2023-04-14T21:38:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Huh. ",
          "createdAt": "2023-03-08T05:41:14Z",
          "updatedAt": "2023-03-08T05:41:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "After a bit of discussion, I think we've landed on `std-` -- thoughts?",
          "createdAt": "2023-03-13T23:37:46Z",
          "updatedAt": "2023-03-13T23:37:46Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Many programming languages don't support hyphen as a character in identifiers.  Using `std_` would require less translation as all the languages I have seen do support underscore.  Having said that, most serializers/deserializers already have the ability to do mappings between wire formats and types so it is not a big deal.",
          "createdAt": "2023-03-18T16:28:33Z",
          "updatedAt": "2023-03-18T16:28:33Z"
        },
        {
          "author": "ndw",
          "authorAssociation": "NONE",
          "body": "You're defining the format. I think you can do better. Don't invent a new mechanism. If you have the will to do it in a proper, extensible fashion, borrow a page from XML or JSON-LD and work out how to associate URIs with short names in some way. If you don't have the will to do that, borrow a page from HTML5 and reserve all names that don't include a hypen (or an underscore or \ud83d\udca9) in them for yourself and let anyone adding new properties distinguish theirs.",
          "createdAt": "2023-03-24T16:28:31Z",
          "updatedAt": "2023-03-24T16:28:31Z"
        },
        {
          "author": "benbucksch",
          "authorAssociation": "NONE",
          "body": "> reserve all names that don't include a hyp[h]en ... in them for yourself and let anyone adding new properties distinguish theirs [by using a hyphen]\r\n\r\nI like that suggestion. Standard fields should be easy and straight-forward (including future ones). Non-standard fields should do a little extra.",
          "createdAt": "2023-04-05T20:40:21Z",
          "updatedAt": "2023-04-05T20:40:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If we were doing this from scratch, that might be workable (although it's not very intuitive). As it is, we have to take reasonable steps to assure we won't collide with existing usage; that is _very_ likely to.",
          "createdAt": "2023-04-05T22:59:58Z",
          "updatedAt": "2023-04-05T22:59:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, the opposite of [\"X-\"](https://datatracker.ietf.org/doc/html/rfc6648) then?  I find myself wondering whether this solution is worse than the problem it aims to fix.\r\n\r\nLet's say that I include a field that encodes an entire problem report from an upstream server.  I define \"upstream\" to carry the problem report.  That turns out to be useful and it is standardized as \"std-upstream\"[^1].  Now, do I teach my code to just strip \"std-\" prefixes?  Maybe not for one instance like this, but if that starts happening more often, it starts looking tempting and \"std-\" becomes meaningless.\r\n\r\nThe alternative is just to suck it up and acknowledge that there might be collisions between what a standard defines and what a resource uses.  New additions to standards might conflict with resource-specific usage that is unaware of changes in standards.  But problem reports are always subject to some amount of interpretation and subtle semantic differences in the interpretation of fields with the same name but different definitions is already possible for stuff defined outside of standards.  Reifying standardized values doesn't really improve that situation a whole lot.\r\n\r\nAs @mnot says, with forethought, this problem might have been anticipated and avoided.\r\n\r\n[^1]: More likely it would a different name because standards, but maybe I was lucky this time and no one decided to bikeshed names.",
          "createdAt": "2023-04-06T00:49:47Z",
          "updatedAt": "2023-04-06T00:49:47Z"
        },
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "I'm torn between all of the proposed solutions. I can totally understand the arguments for/against each and every one of them. In the end, what matters is that the solution is usable and understandable for all parties involved. \r\n\r\nI do have to agree with @martinthomson and would like to pick up his example. If `std-upstream` gets introduced we would have elements in the returned JSON that have the prefix attached to them and some that don't. From a users perspective this feels odd. So it probably would make sense to also \"claim\" the prefixed version for the old elements (`std-status`, `std-instance`, `std-type`, and so on).\r\n\r\nThe second option would be to define that API providers who use their own elements prefix them with `x-` or make them use a hyphen like @ndw proposed. This would make it also easier for consumers who are not familiar with the spec to understand what has been added by the provider. Yes this would also \"break\" existing implementations, but at least API providers only have to adjust their work once, instead of doing it every time a new \"standard element\" gets introduced.\r\n\r\nThe third option would be to create a new (version of the) standard replacing this one and in there define extensibility the way we think it should be implemented. Of course this would mean postponing a solution for providing future extensions for quite some time, but at least then we don't have to fear that we're breaking existing implementations.",
          "createdAt": "2023-04-06T11:32:19Z",
          "updatedAt": "2023-04-06T11:32:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "There are many ways to spell this; e.g., if we want a new standard extension `foo` that takes integer values from conflicting with a type-local extension that takes (for example) string values, we could put standard extensions in a container:\r\n\r\n~~~ json\r\n{\r\n \"type\": \"https://example.com/probs/out-of-credit\",\r\n \"title\": \"You do not have enough credit.\",\r\n \"detail\": \"Your current balance is 30, but that costs 50.\",\r\n \"instance\": \"/account/12345/msgs/abc\",\r\n \"std-exts\": {\r\n     \"foo\": 1\r\n  },\r\n  \"foo\": \"abc\"\r\n}\r\n~~~\r\n\r\nOr, we could invert that, and recommend that future problem types put everything into a `local-exts` container:\r\n\r\n~~~ json\r\n{\r\n \"type\": \"https://example.com/probs/out-of-credit\",\r\n \"title\": \"You do not have enough credit.\",\r\n \"detail\": \"Your current balance is 30, but that costs 50.\",\r\n \"instance\": \"/account/12345/msgs/abc\",\r\n \"foo\": 1,\r\n \"local-exts\": {\r\n     \"foo\": \"abc\"\r\n  }\r\n}\r\n~~~\r\n\r\nHowever, that doesn't avoid the problem that @martinthomson points out -- someone using a type-local extension that gets promoted to a standard extension needs to transition.\r\n\r\nMaybe it's not that bad. If I'm consuming an existing problem type that uses the local extension, I'll need to understand that extension to consume it; it merely being defined as a standard extension doesn't change that. The producer of the problem can rely upon that, and can choose to either add the standard extension as a backwards-compatible change to their API, or they can wait until they version the API to switch to the standard, as a breaking change.\r\n\r\n",
          "createdAt": "2023-04-11T04:45:25Z",
          "updatedAt": "2023-04-11T04:45:25Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The producer of the problem can rely upon that, and can choose to either add the standard extension as a backwards-compatible change to their API, or they can wait until they version the API to switch to the standard, as a breaking change.\r\n\r\nThat holds true if the producer has complete control over how the `problem+json` is produced. As https://github.com/ietf-wg-httpapi/rfc7807bis/pull/48#issuecomment-1256130831 proves, various web application frameworks such as Microsoft ASP.NET may be the deciding factor in what is included in the response, and how.\r\n\r\nAs an upgrade from one version of a framework to another may rest on many other factors than its `problem+json` implementation, there's reasons to believe future extensions to the standard implemented in such frameworks may cause unintentional breakage.",
          "createdAt": "2023-04-11T16:02:30Z",
          "updatedAt": "2023-04-11T16:02:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, AIUI you're saying that if a framework adds a new standard member and a deployment upgrades to it without versioning their API, trouble could result. Fair.\r\n\r\nStepping back, the purpose of `*-` (or whatever we call it) was to make room for future standard extensions; we don't have one to include at the moment. Since it appears we're not sure how best to accommodate them, it might be best _not_ to try to accommodate them -- i.e., punt the issue down the road -- especially since the _right_ solution might be to introduce a new media type.",
          "createdAt": "2023-04-12T06:02:19Z",
          "updatedAt": "2023-04-12T06:02:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm supportive of that conclusion.  This has escaped and thus we no longer have any control over it.  Though a new media type is a bit disruptive, it seems commensurate with the risks.",
          "createdAt": "2023-04-12T06:47:30Z",
          "updatedAt": "2023-04-12T06:47:30Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On Apr 12, 2023, at 08:02, Mark Nottingham ***@***.***> wrote:\n> \n> Stepping back, the purpose of *- (or whatever we call it) was to make room for future standard extensions; we don't have one to include at the moment. Since it appears we're not sure how best to accommodate them, it might be best not to try to accommodate them -- i.e., punt the issue down the road -- especially since the right solution might be to introduce a new media type.\n> \ni my mind let's keep punting. we didn't address it in the original RFC and it may just be one of those things where the cure is worse than the disease.",
          "createdAt": "2023-04-12T07:23:14Z",
          "updatedAt": "2023-04-12T07:23:14Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I too support postponing this decision until the need to add another standard field arises.",
          "createdAt": "2023-04-12T10:57:08Z",
          "updatedAt": "2023-04-12T10:57:08Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Without chair hat, I support the removal of the extension.  ",
          "createdAt": "2023-04-14T21:38:57Z",
          "updatedAt": "2023-04-14T21:38:57Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOE-NsGs5gDWTb",
      "title": "How should Accept header be used by the server?",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/75",
      "state": "CLOSED",
      "author": "maricn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In some examples ([[1]](https://github.com/ietf-wg-httpapi/rfc7807bis/blob/ca4dd4b6159b620d81226e20dac3e124a629e68f/draft-ietf-httpapi-rfc7807bis.md?plain=1#L129) and [[2]](https://github.com/ietf-wg-httpapi/rfc7807bis/blob/ca4dd4b6159b620d81226e20dac3e124a629e68f/draft-ietf-httpapi-rfc7807bis.md?plain=1#L160)) at current state of `main` branch, there are different values of the `Accept` request header - `application/json` and `application/json, application/problem+json`. They are interchangeably used without any comment or note. This creates confusion and it could be helpful to have a clarification of how does the Accept header influence the response.",
      "createdAt": "2023-03-06T13:59:33Z",
      "updatedAt": "2023-03-07T02:49:43Z",
      "closedAt": "2023-03-07T02:49:43Z",
      "comments": [
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "RFC-6838 defines \"Structured Syntax Name Suffixes\", and in particular it defines that anything with a `+json` suffix should be treated as `application/json` unless there are stricter rules for that exact media type.\r\n\r\nAs such, it seems reasonable (to me at least, and I'm not an expert!) to reply with `application/problem+json` to something that only accepts `application/json` - since, per those rules, `application/problem+json` can be interpreted as valid `application/json` as well.",
          "createdAt": "2023-03-06T14:16:06Z",
          "updatedAt": "2023-03-06T14:16:06Z"
        },
        {
          "author": "maricn",
          "authorAssociation": "NONE",
          "body": "@sazzer thank you for the prompt response - i find that logic very reasonable! \r\n\r\nit is also implicit in the examples i linked in the original post, but considering how the RFC at hand defines `application/problem+json`, i would personally still find it valuable if that piece of \"sidenote\" information would be explicit in the document.. ",
          "createdAt": "2023-03-06T15:32:52Z",
          "updatedAt": "2023-03-06T15:32:52Z"
        },
        {
          "author": "sazzer",
          "authorAssociation": "NONE",
          "body": "Personally, I agree, and I think that having the examples be inconsistent isn't great. I was just explaining how they are both technically valid :)",
          "createdAt": "2023-03-06T16:28:43Z",
          "updatedAt": "2023-03-06T16:28:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(1) is saying that the client expects json (in the case of a successful response), and also can process the problem format.\r\n\r\n(2) is a request, not a response.\r\n\r\n",
          "createdAt": "2023-03-07T02:49:40Z",
          "updatedAt": "2023-03-07T02:49:40Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOE-NsGs5h1QMH",
      "title": "Update example to be more HTTP-focused",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/issues/76",
      "state": "OPEN",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The original example in https://www.rfc-editor.org/rfc/rfc7807#section-3 is more about a business problem than about an HTTP problem. It might be helpful to change the example to one that's more specifically about a technical problem.\r\nOptionally, we could also mention that different people have different preferences when it comes to if/how business problem should be reflected in HTTP status codes. By choosing an example that's clearly technical in nature, we could better avoid taking sides in that discussion.",
      "createdAt": "2023-03-27T04:29:14Z",
      "updatedAt": "2023-04-13T22:22:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm afraid I have to disagree with a \"neutral\" stance on whether to represent business problems in HTTP or not. As HTTP is an application protocol, representing the application's state in HTTP is IMHO the correct thing to do.\r\n\r\nIf anything, I believe it's important that RFC 7807 takes a clear stance on this issue to help nudge this discussion in the right direction, and not re-enforce the view of HTTP merely being a transport protocol.",
          "createdAt": "2023-03-27T21:02:32Z",
          "updatedAt": "2023-03-27T21:02:32Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2023-03-27 22:02, Asbj\u00f8rn Ulsberg wrote:\n> I'm afraid I have to disagree with a \"neutral\" stance on whether to \n> represent business problems in HTTP or not. As HTTP is an application \n> protocol, representing the application's state in HTTP is IMHO the \n> correct thing to do.\n> \n> If anything, I believe it's important that RFC 7807 takes a clear stance \n> on this issue to help nudge this discussion in the right direction, and \n> not re-enforce the view of HTTP merely being a transport protocol.\n\nsome things are relatively clear: when you send a request with a wrong \nmedia type or with payload violating the request schema, you are \nviolating the contract and a 4xx is in order. problem reports can help \nto be more explicit about what happened.\n\nother things are less clear: if you ask to transfer money but you don't \nhave enough, denying the transfer is not really an \"client error\", it \nfollows the rules of the contract: you can only transfer money when you \nhave money.\n\nsome people like exposing those latter problems in HTTP as well, others \ndon't. one reason is that not all these decisions are binary, and HTTP \nhas no way to natively signal \"your request partly succeeded\".\n\none way or the other, there is no reason for the spec to go down this \nparticular rabbit hole, and using an example that's clearly from the \nbinary category (such as validating against a schema) allows us to be \nexplain how the spec works without having to be opinionated about how \npeople design their APIs.\n\n-- \nErik Wilde | ***@***.***    |\n            | https://youtube.com/ErikWilde |\n",
          "createdAt": "2023-03-28T06:29:34Z",
          "updatedAt": "2023-03-28T06:29:34Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> some people like exposing those latter problems in HTTP as well, others don't. \r\n\r\nFor those who don't like to expose business problems in HTTP, how would they represent the error of trying to transfer money from an account with insufficient funds? `200 OK`?",
          "createdAt": "2023-03-28T09:05:47Z",
          "updatedAt": "2023-03-28T09:05:47Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2023-03-28 11:05, Asbj\u00f8rn Ulsberg wrote:\n> For those who don't like to expose business problems in HTTP, how would \n> they represent the error of trying to transfer money from an account \n> with insufficient funds? |200 OK|?\n\nyup, which i am sure makes you unhappy. but there is some logic to it: \nyou receive a request and responded according to what the business logic \ndefines. that's a successful processing of the request and it's hard to \nimagine that a user agent would be able to fix anything and retry.\n",
          "createdAt": "2023-03-30T14:41:00Z",
          "updatedAt": "2023-03-30T14:41:00Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> you receive a request and responded according to what the business logic defines. that's a successful processing of the request and it's hard to imagine that a user agent would be able to fix anything and retry.\r\n\r\nThe request was to transfer money, not to have the HTTP body parsed according to its `Content-Type` and assigned programmatic schema. The request to transfer money failed, therefore the response should indicate that the request failed.\r\n\r\nA `200 OK` response for a failing request is a clear violation of the HTTP specification, imho.",
          "createdAt": "2023-04-07T20:11:10Z",
          "updatedAt": "2023-04-07T20:11:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I agree with @dret here -- this is not the spec to resolve this debate in.",
          "createdAt": "2023-04-11T04:47:03Z",
          "updatedAt": "2023-04-11T04:47:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> A 200 OK response for a failing request is a clear violation of the HTTP specification, imho.\r\n\r\nIt depends on how you define fail. When I perform a web search, if there aren't any results, should the results really be a 4xx? What about when a banking transaction fails in an HTML interface?\r\n\r\nI was looking at resolving this issue by changing the example completely, but given where we're at in the process, that's not really desireable. So I think the best thing to do here is to keep 403 on the first example, and use 422 on the second one. See commit forthcoming.\r\n",
          "createdAt": "2023-04-13T04:53:04Z",
          "updatedAt": "2023-04-13T04:54:00Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It depends on how you define fail. When I perform a web search, if there aren't any results, should the results really be a 4xx?\r\n\r\nThe search resource exists, so a `404` would be wrong, at least. But I would say that the nature of search is to often not return any results and as such, that's not something I would consider an exception and therefore not an error. `200 OK`.\r\n\r\n> What about when a banking transaction fails in an HTML interface?\r\n\r\nI'm not sure why the HTML interface is relevant? If the transaction fails, `4xx` is the appropriate response code regardless of media type, imho.\r\n\r\n> I was looking at resolving this issue by changing the example completely, but given where we're at in the process, that's not really desireable. So I think the best thing to do here is to keep 403 on the first example, and use 422 on the second one. See commit forthcoming.\r\n\r\nFair.",
          "createdAt": "2023-04-13T22:22:19Z",
          "updatedAt": "2023-04-13T22:22:19Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2NTk4NTA0",
      "title": "fix metadata",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/17",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-16T07:13:19Z",
      "updatedAt": "2021-04-16T07:43:47Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "a832532a9cd89835cc9ecc2c41c511a47e6ea963",
      "headRepository": "reschke/rfc7807bis",
      "headRefName": "patch-1",
      "headRefOid": "c02f381ea4e471983605dd74ae5e6e987fe0bf97",
      "closedAt": "2021-04-16T07:43:43Z",
      "mergedAt": "2021-04-16T07:43:43Z",
      "mergedBy": "dret",
      "mergeCommit": {
        "oid": "c1bd1003cb39fa4c3fecd6aa593445aa928a473e"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "looks good. thanks, @reschke!",
          "createdAt": "2021-04-16T07:43:47Z",
          "updatedAt": "2021-04-16T07:43:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyMTAwOTUw",
      "title": "Added JSON schema",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/18",
      "state": "MERGED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-23T14:11:40Z",
      "updatedAt": "2021-07-05T16:45:59Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "c1bd1003cb39fa4c3fecd6aa593445aa928a473e",
      "headRepository": "sdatspun2/rfc7807bis",
      "headRefName": "main",
      "headRefOid": "fc9781b97ed20c7f4214b658e3a5521bed214fa3",
      "closedAt": "2021-07-05T16:45:59Z",
      "mergedAt": "2021-07-05T16:45:59Z",
      "mergedBy": "sdatspun2",
      "mergeCommit": {
        "oid": "d2958d39ffea9e76444199513f8f67f29e2691d4"
      },
      "comments": [
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is for Issue #8 ",
          "createdAt": "2021-04-23T14:15:24Z",
          "updatedAt": "2021-04-23T14:15:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MjI3NjUx",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "See inline.",
          "createdAt": "2021-04-26T02:37:14Z",
          "updatedAt": "2021-04-26T02:42:46Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Might be worth adding a `minimum` of `100` and a `maximum` of `599`.",
              "createdAt": "2021-04-26T02:37:14Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n      \"format\": \"uri-reference\",\r\n```",
              "createdAt": "2021-04-26T02:38:07Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n      \"format\": \"uri-reference\",\r\n```",
              "createdAt": "2021-04-26T02:38:19Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 2,
              "body": "Is this the right URI? I'm not up to speed on the latest in schema-land...",
              "createdAt": "2021-04-26T02:39:19Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 20,
              "body": "Shouldn't this be `examples` and an array, as per http://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.9.5 ?",
              "createdAt": "2021-04-26T02:40:14Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 18,
              "body": "We should remove this until the spec text is in place -- it's not clear we're going to go this way.",
              "createdAt": "2021-04-26T02:42:08Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            },
            {
              "originalPosition": 35,
              "body": "Same as above, should be removed until the issue is settled.",
              "createdAt": "2021-04-26T02:42:28Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0Njk4Mzc3",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T13:52:00Z",
          "updatedAt": "2021-04-26T13:52:01Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5\r\n\r\nI kept it slightly old to increase adoption. Latest is 2020-12. Other option could be 2019-09. Lmk so I can change in next commit.\r\n\r\nhttps://json-schema.org/specification-links.html\r\n",
              "createdAt": "2021-04-26T13:52:00Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NzEwOTgy",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T14:02:19Z",
          "updatedAt": "2021-04-26T14:02:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Hmm...relied on a tool. Fixing in next commit.",
              "createdAt": "2021-04-26T14:02:19Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NzExODM3",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T14:03:03Z",
          "updatedAt": "2021-04-26T14:03:04Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ohk...",
              "createdAt": "2021-04-26T14:03:04Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NzEyMjUz",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T14:03:27Z",
          "updatedAt": "2021-04-26T14:03:27Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Next commit.",
              "createdAt": "2021-04-26T14:03:27Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NzEyNjAz",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T14:03:45Z",
          "updatedAt": "2021-04-26T14:03:45Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yes. Relative should be supported. Next commit.",
              "createdAt": "2021-04-26T14:03:45Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NzEyOTA0",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T14:04:01Z",
          "updatedAt": "2021-04-26T14:04:01Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "+1",
              "createdAt": "2021-04-26T14:04:01Z",
              "updatedAt": "2021-04-28T13:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4MDE4NDU2",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-29T09:56:03Z",
          "updatedAt": "2021-04-29T09:56:03Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "not sure about the \"best\" version/URI to choose, as they're still in eternal draft mode.",
              "createdAt": "2021-04-29T09:56:03Z",
              "updatedAt": "2021-04-29T09:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4MDE5MzYx",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-29T09:57:04Z",
          "updatedAt": "2021-04-29T09:57:05Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "\"going to go this way\" meaning adding a JSON schema, @mnot?",
              "createdAt": "2021-04-29T09:57:04Z",
              "updatedAt": "2021-04-29T09:57:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4NzcyMDk0",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-30T00:10:25Z",
          "updatedAt": "2021-04-30T00:10:25Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "No, I mean we haven't resolved how multiple problems should be handled.",
              "createdAt": "2021-04-30T00:10:25Z",
              "updatedAt": "2021-04-30T00:10:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5NzAwNjE2",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T00:59:43Z",
          "updatedAt": "2021-05-01T00:59:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The schema proposal is an attempt to resolve it :)",
              "createdAt": "2021-05-01T00:59:43Z",
              "updatedAt": "2021-05-01T00:59:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5NzAwNzc3",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T01:01:08Z",
          "updatedAt": "2021-05-01T01:01:08Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "I am thinking of removing it. Some linters do not recognize $schema, esp. those that follow pre OpenAPI 3.1 spec.",
              "createdAt": "2021-05-01T01:01:08Z",
              "updatedAt": "2021-05-01T01:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5NzAyMjc4",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T01:15:42Z",
          "updatedAt": "2021-05-01T01:15:42Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "We use the following \r\n```\r\n \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\r\n```\r\nin the [OpenAPI 3.1 metaschema](https://github.com/OAI/OpenAPI-Specification/blob/main/schemas/v3.1/schema.json) and it has been reviewed by the JSON Schema editors.",
              "createdAt": "2021-05-01T01:15:42Z",
              "updatedAt": "2021-05-01T01:15:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1ODQ0MjQ2",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-17T03:59:19Z",
          "updatedAt": "2021-06-17T03:59:19Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Right, but this is a proposal to resolve the issue about having a JSON Schema, not that. Addressing two issues together conflates them, and we haven't yet come to consensus on the latter. \r\n\r\nIn this situation, the usual process is to address the more straightforward thing first -- in this case, adding a JSON Schema -- and then adding to it when we resolve the other issue. So I'd suggest removing `properties` for now (although we might add it back later).",
              "createdAt": "2021-06-17T03:59:19Z",
              "updatedAt": "2021-06-17T03:59:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1ODQ0MzIw",
          "commit": {
            "abbreviatedOid": "4ed3cca"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-17T03:59:33Z",
          "updatedAt": "2021-06-17T03:59:33Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Sounds good to me - let's change to that value.",
              "createdAt": "2021-06-17T03:59:33Z",
              "updatedAt": "2021-06-17T03:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3MDQwNDMy",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-18T05:24:46Z",
          "updatedAt": "2021-06-18T05:24:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Removed",
              "createdAt": "2021-06-18T05:24:46Z",
              "updatedAt": "2021-06-18T05:24:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3MDQwNTA5",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-18T05:24:59Z",
          "updatedAt": "2021-06-18T05:24:59Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Removed",
              "createdAt": "2021-06-18T05:24:59Z",
              "updatedAt": "2021-06-18T05:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3MDQwNjE4",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-18T05:25:18Z",
          "updatedAt": "2021-06-18T05:25:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "not relevant. removed.",
              "createdAt": "2021-06-18T05:25:19Z",
              "updatedAt": "2021-06-18T05:25:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3MDQwOTE3",
          "commit": {
            "abbreviatedOid": "5467bff"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-18T05:25:57Z",
          "updatedAt": "2021-06-18T05:25:57Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Changed",
              "createdAt": "2021-06-18T05:25:57Z",
              "updatedAt": "2021-06-18T05:25:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3MTA3MDM4",
          "commit": {
            "abbreviatedOid": "fc9781b"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-06-18T07:24:13Z",
          "updatedAt": "2021-06-18T07:24:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyOTMwOTA3",
      "title": "Warn about relative URIs in \"type\" and \"instance\"",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/20",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This necessitated rearranging the section on members for clarity.\r\n\r\nAlso, \"Consumers MUST use the 'type' string...\" was changed to\r\n\"Consumers MUST use the 'type' URI...\" for consistency.\r\n\r\nFixes #11.",
      "createdAt": "2021-04-26T03:51:55Z",
      "updatedAt": "2021-05-25T06:56:53Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "7d017bddc129bbd4785c9cc498da3efcb3ab8297",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot-11",
      "headRefOid": "4a7649c3445d0aed16151d8cc2a9c4f64fd7c5a8",
      "closedAt": "2021-05-25T06:56:46Z",
      "mergedAt": "2021-05-25T06:56:46Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "aa4ec7750fcc3252ed6e523f12bef68aff8825f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MjU5NDE4",
          "commit": {
            "abbreviatedOid": "ce8340d"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think this is a great improvement and that it resolves the issue. I would just like a bit more verbosity in the example given for relative URIs.",
          "createdAt": "2021-04-26T04:40:08Z",
          "updatedAt": "2021-04-26T04:49:50Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This is a great improvement, but I think we should be even more verbose with the example to explain thoroughly what the issue with relative URIs is and not expect everyone to know relative URI resolving by heart. Below is a suggestion for how to make this paragraph even clearer.\r\n\r\n```suggestion\r\nWhile relative URIs are allowed in \"type\", it is RECOMMENDED that only absolute URIs be used, to avoid confusion. For example, if the two resources \"https://api.example.org/foo/bar/123\" and \"https://api.example.org/widget/456\" both respond with a \"type\" equal to the relative URI reference \"example-problem\", when resolved they will identify different resources (\"https://api.example.org/foo/bar/example-problem\" and \"https://api.example.org/widget/example-problem\" respectively), which is counter-intuitive for many users.\r\n```",
              "createdAt": "2021-04-26T04:40:08Z",
              "updatedAt": "2021-04-26T04:55:17Z"
            },
            {
              "originalPosition": 20,
              "body": "Perhaps we should say something about dereferencing being encouraged on user interaction, such as clicking a button in a UI or similar? It would be good to give ideas about how the `type` URI is intended to be used for human-readable documentation in practice, imho.",
              "createdAt": "2021-04-26T04:44:21Z",
              "updatedAt": "2021-04-26T04:55:17Z"
            },
            {
              "originalPosition": 5,
              "body": "Thumbs up for giving each member a heading. \ud83d\udc4d\ud83c\udffc ",
              "createdAt": "2021-04-26T04:45:54Z",
              "updatedAt": "2021-04-26T04:55:17Z"
            },
            {
              "originalPosition": 51,
              "body": "If the similar paragraph for \"type\" is modified, this paragraph should be modified to remain consistent with it.",
              "createdAt": "2021-04-26T04:48:21Z",
              "updatedAt": "2021-04-26T04:55:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MjYzODA2",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T04:55:36Z",
          "updatedAt": "2021-04-26T04:55:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":)",
              "createdAt": "2021-04-26T04:55:36Z",
              "updatedAt": "2021-04-26T04:55:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MjY5NDA0",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T05:12:55Z",
          "updatedAt": "2021-04-26T05:12:56Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That sounds like a separate issue, maybe #13.",
              "createdAt": "2021-04-26T05:12:55Z",
              "updatedAt": "2021-04-26T05:12:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MjY5ODE1",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-26T05:14:10Z",
          "updatedAt": "2021-04-26T05:14:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Agreed",
              "createdAt": "2021-04-26T05:14:10Z",
              "updatedAt": "2021-04-26T05:14:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0NTYyNDU1",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "pimterry",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I've added a couple of quick thoughts on ways this could go slightly further, but I think this is already a great improvement that would fix #14.",
          "createdAt": "2021-04-26T11:31:14Z",
          "updatedAt": "2021-04-26T11:54:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Is it worth mentioning that this isn't just counter-intuitive, but is actually handled wrongly by most existing implementations? Similar to GET with a body in the HTTP RFC, where it says\r\n\r\n> sending a payload body on a GET request might cause some existing implementations to reject the request.\r\n\r\nMaybe here something like:\r\n\r\n> ...which is counter-intuitive for many users, and might be misinterpreted by some existing implementations.\r\n\r\nThis would help readers to better understand the practical impact of ignoring this recommendation: there is a very real possibility that tools will handle this incorrectly.",
              "createdAt": "2021-04-26T11:31:14Z",
              "updatedAt": "2021-04-26T11:54:58Z"
            },
            {
              "originalPosition": 14,
              "body": "Do we have a recommendation on relative-host absolute-path URIs, e.g. `/problems/example-problem`?\r\n\r\nThese are encouraged today as the best option in [some existing popular API style guides](https://github.com/zalando/restful-api-guidelines/blob/master/chapters/http-status-codes-and-errors.adoc#must-support-problem-json), so could be worth an explicit mention.\r\n\r\nI'm not actually sure the best position is here: they're still potentially slightly confusing but \"it's an error code scoped to the whole origin\" is much less tricky that the fully relative case imo.\r\n\r\nIf we think that these are discouraged too, as the current text implies since they are indeed relative URIs, then it still might be useful to explicitly include them in the explanation here, since they do behave somewhat differently and they're in real use today.\r\n\r\nIf we think that they're actually OK, then it would definitely be good to clarify why this is different from fully relative URIs like `example-problem`, and be clear that they're not recommended against in the same way.",
              "createdAt": "2021-04-26T11:45:35Z",
              "updatedAt": "2021-04-26T11:54:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ1NTIzMjk2",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-27T07:27:47Z",
          "updatedAt": "2021-04-27T07:27:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Good suggestion; will add something along those lines.",
              "createdAt": "2021-04-27T07:27:47Z",
              "updatedAt": "2021-04-27T07:27:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ1NTIzNTAx",
          "commit": {
            "abbreviatedOid": "8d7a808"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-27T07:28:01Z",
          "updatedAt": "2021-04-27T07:28:01Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Also a good point; will refine this.",
              "createdAt": "2021-04-27T07:28:01Z",
              "updatedAt": "2021-04-27T07:28:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUwMjY2NTE5",
          "commit": {
            "abbreviatedOid": "4a7649c"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d\ud83c\udffc ",
          "createdAt": "2021-05-03T11:22:35Z",
          "updatedAt": "2021-05-03T11:22:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2NzQ4NTA2",
      "title": "all predefined members are optional",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/22",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "adding a clear statement that all members of the problem details object are optional. i guess using the RFC 2119 \"OPTIONAL\" makes sense in this case.",
      "createdAt": "2021-06-10T10:25:02Z",
      "updatedAt": "2022-01-20T01:19:21Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "2b0d06306d9de017088e04b12e9321397b6a59f9",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "dret-patch-1",
      "headRefOid": "2eddf3a78dbc1abd2862a1daa9606a4a278fd6fa",
      "closedAt": "2021-12-06T07:38:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "OBE",
          "createdAt": "2021-12-06T07:38:29Z",
          "updatedAt": "2021-12-06T07:38:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2NzU0NDkz",
      "title": "adding processing model (closing #19)",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/23",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "making it clear that members using the wrong type must be ignored.",
      "createdAt": "2021-06-10T10:32:24Z",
      "updatedAt": "2022-01-20T01:19:22Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "2b0d06306d9de017088e04b12e9321397b6a59f9",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "dret-patch-2",
      "headRefOid": "aaba2eba8aaefca0a2e54f02a985c7f3c3848887",
      "closedAt": "2021-09-23T01:07:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of things:\r\n\r\n* I don't know what \"Any member defined by this specification must be tested to use the type given in its definition\" means.\r\n* Generally, MUST is used to specify interoperability requirements; they should be testable. These MUSTs read oddly in that light. \r\n* This isn't so much a processing model as it does specify error handling. Processing models generally specify behaviours; this doesn't (and arguably, this spec can't; that's up to the application in question)\r\n* In the case that a problem type defines that a particular extension member MUST be present and valid, what happens? \r\n\r\nSo, I'd just say something like: \"When interpreting problem details, errors (such as an an extension member whose value type is unexpected) might be encountered. In most situations, the information in other valid parts of the problem details can still be relied upon.\"",
          "createdAt": "2021-06-11T02:43:12Z",
          "updatedAt": "2021-06-11T02:43:12Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-06-11 04:43, Mark Nottingham wrote:\n>   * Generally, MUST is used to specify interoperability requirements;\n>     they should be testable. These MUSTs read oddly in that light.\n\nwouldn't the test simply be whether the member values conform to the \ntype given in the definition or not? if they don't, interop suffers \nbecause consumers don't know how to interpret the invalid type.\n\n>   * This isn't so much a processing model as it does specify error\n>     handling. Processing models generally specify behaviours; this\n>     doesn't (and arguably, this spec can't; that's up to the application\n>     in question)\n\nok. to me, the first line of defense in behavior is to do this kind of \nvalidation. validate, then proceed. the original issue was asking what \nto do when validation fails.\n\n>   * In the case that a problem type defines that a particular extension\n>     member MUST be present and valid, what happens?\n\ni forgot that this is even possible. wouldn't that up for the type to \ndefine? that's hard for the generic spec to do. but i agree that saying \nthis in the new section probably would help.\n\n> So, I'd just say something like: \"When interpreting problem details, \n> errors (such as an an extension member whose value type is unexpected) \n> might be encountered. In most situations, the information in other valid \n> parts of the problem details can still be relied upon.\"\n\nthanks, i tweaked that a little and updated the PR.\n",
          "createdAt": "2021-06-11T14:55:03Z",
          "updatedAt": "2021-06-11T14:55:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "OBE",
          "createdAt": "2021-09-23T01:07:36Z",
          "updatedAt": "2021-09-23T01:07:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NjMwMDgw",
          "commit": {
            "abbreviatedOid": "aaba2eb"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-16T00:49:48Z",
          "updatedAt": "2021-06-16T00:49:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg5NjA0MTk1",
      "title": "Propose IANA registry",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/24",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Note that the recommendation regarding a URI prefix for registered values is subject to other discussions.\r\n\r\nFixes #7.",
      "createdAt": "2021-07-14T05:48:07Z",
      "updatedAt": "2021-07-29T07:26:57Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "20d6bdea3ab973451e6590e99fdc94603da69b56",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot-7",
      "headRefOid": "49f380249fd0ef85f0347b55377b21b6e219e260",
      "closedAt": "2021-07-29T07:26:56Z",
      "mergedAt": "2021-07-29T07:26:56Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "b7fa43ea9a083057bc5d6dff9810df4ea0c05eb2"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-07-16 15:12, Sanjay Dalal wrote:\n> In addition to the about:blank, should we also define the problem types \n> for the most common errors in http apis with this document itself? 400, \n> 401, 403, 404, 500, ? These would provide good examples and also once \n> the document is approved, these would be right away useful to API \n> developers without waiting for them being registered and approved \n> separately.\n\nmy reading of RFC 7807 is that the vanilla status codes do not need \ntypes and this is where about:blank is explicitly recommended (if \nsomebody does not want to simply omit the type URI, which also is \nallowed). i think this is how the RFC does it and i don't think we even \nhave the option to change this and to now recommend specific type URIs \nfor vanilla problem reports.\n",
          "createdAt": "2021-07-16T18:09:38Z",
          "updatedAt": "2021-07-16T18:09:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA1OTc5OTcz",
          "commit": {
            "abbreviatedOid": "6894176"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-14T08:11:57Z",
          "updatedAt": "2021-07-14T08:11:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4MjM3MTU1",
          "commit": {
            "abbreviatedOid": "49f3802"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "i like it, but i am wondering if proposing a URI that points at the IANA registry isn't potentially a risky thing to do (in terms of driving traffic to that URI). i personally like the idea of a dedicated URN scheme better, as we will now have the registry to aid with discovery.",
          "createdAt": "2021-07-16T10:38:33Z",
          "updatedAt": "2021-07-16T10:38:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4MDEwMjUw",
          "commit": {
            "abbreviatedOid": "6894176"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-16T05:06:37Z",
          "updatedAt": "2021-07-16T13:12:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "In addition to the about:blank, should we also define the problem types for the most common errors in http apis with this document itself? 400, 401, 403, 404, 500, ? These would provide good examples and also once the document is approved, these would be right away useful to API developers without waiting for them being registered and approved separately.",
              "createdAt": "2021-07-16T05:06:38Z",
              "updatedAt": "2021-07-16T13:12:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIwOTk4NzI5",
      "title": "Recommendations about dereferenceability of type",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/26",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #15",
      "createdAt": "2021-08-27T03:29:54Z",
      "updatedAt": "2021-09-08T05:06:48Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "b7fa43ea9a083057bc5d6dff9810df4ea0c05eb2",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot-15",
      "headRefOid": "66236119b0f1b58a1cefbb911f5e4a2e45a27a34",
      "closedAt": "2021-09-08T05:06:48Z",
      "mergedAt": "2021-09-08T05:06:47Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "3511e0d2d6d2198adf8094d83866409edd5f91e4"
      },
      "comments": [
        {
          "author": "andrecedik",
          "authorAssociation": "NONE",
          "body": "\ud83d\udc4d ",
          "createdAt": "2021-08-27T06:09:33Z",
          "updatedAt": "2021-08-27T06:09:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQwMzcwNDEz",
          "commit": {
            "abbreviatedOid": "6623611"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-27T10:23:48Z",
          "updatedAt": "2021-08-27T10:23:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQxNzIxMzMz",
          "commit": {
            "abbreviatedOid": "6623611"
          },
          "author": "pimterry",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Good improvement, fixes #15 for me, thanks!",
          "createdAt": "2021-08-30T14:34:15Z",
          "updatedAt": "2021-08-30T14:34:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI0NTU5Njgw",
      "title": "fix broken link into [SEMANTICS]",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/27",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-01T14:32:03Z",
      "updatedAt": "2021-09-01T23:16:32Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "b7fa43ea9a083057bc5d6dff9810df4ea0c05eb2",
      "headRepository": "reschke/rfc7807bis",
      "headRefName": "patch-2",
      "headRefOid": "7c44f9118d69450d4834da6d7ef3b4ab11626e13",
      "closedAt": "2021-09-01T23:16:27Z",
      "mergedAt": "2021-09-01T23:16:27Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "16e596bef33378566dc1019bdc2f6d30d5733483"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.",
          "createdAt": "2021-09-01T23:16:32Z",
          "updatedAt": "2021-09-01T23:16:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOE-NsGs4r3q35",
      "title": "Explain how type errors for members are handled.  ",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/28",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #19.",
      "createdAt": "2021-09-17T03:11:04Z",
      "updatedAt": "2021-09-21T07:42:27Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "3511e0d2d6d2198adf8094d83866409edd5f91e4",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/issue19",
      "headRefOid": "ac5cf4907e6144f6fd365c19a0153266beafabfa",
      "closedAt": "2021-09-21T07:42:26Z",
      "mergedAt": "2021-09-21T07:42:26Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "8f5baecb919512ca877edecb1e334123fde9f52b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs4tJbi0",
          "commit": {
            "abbreviatedOid": "62c6a46"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "\"does not match that specified\" -> \"does not match the specified type\"",
          "createdAt": "2021-09-17T13:12:52Z",
          "updatedAt": "2021-09-17T13:12:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOE-NsGs4tQ12F",
          "commit": {
            "abbreviatedOid": "62c6a46"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T07:26:04Z",
          "updatedAt": "2021-09-21T07:26:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nProblem detail objects can have the following members. If the type of a member's value does not match the specified type, the member MUST be ignored -- i.e., processing will continue as if the member had not been present.\r\n```",
              "createdAt": "2021-09-21T07:26:05Z",
              "updatedAt": "2021-09-21T07:26:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4tQ5D0",
          "commit": {
            "abbreviatedOid": "ac5cf49"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T07:40:28Z",
          "updatedAt": "2021-09-21T07:40:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOE-NsGs4r3sk4",
      "title": "Talk about non-resolveable type URIs",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/29",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #13",
      "createdAt": "2021-09-17T03:28:29Z",
      "updatedAt": "2021-09-23T23:43:51Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "b9f1720d4a81b8c9573aed231f3b02b09671cdbd",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/issue13",
      "headRefOid": "c8df441fe7a84d3c88c1aff9bc66fcc59505eb65",
      "closedAt": "2021-09-23T23:43:51Z",
      "mergedAt": "2021-09-23T23:43:50Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c2c60daaecc21ce563ad9a0d28c8aadb36ba3d01"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "@dret done; see change.\r\n\r\nP.S. GitHub lets you make suggestions using the little +/- icon in the inline comment UX :)",
          "createdAt": "2021-09-23T01:07:06Z",
          "updatedAt": "2021-09-23T01:07:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs4tJbKg",
          "commit": {
            "abbreviatedOid": "afcc74c"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "looks good to me. maybe change\r\n\r\n\"taking advantage of that function would require using a different URI, causing clients to break if additional transition work is not performed.\"\r\n\r\nto\r\n\r\n\"taking advantage of that capability would require switching to a resolvable URI, thereby creating a new identity for the problem type and thus introducing a breaking change.\"",
          "createdAt": "2021-09-17T13:11:20Z",
          "updatedAt": "2021-09-17T13:11:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOE-NsGs4tY-5Q",
          "commit": {
            "abbreviatedOid": "afcc74c"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T01:06:22Z",
          "updatedAt": "2021-09-23T01:06:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nNon-resolvable URIs ought not be used when there is some future possibility that it might become desireable to do so. For example, if the URI above were used in an API and later a tool was adopted that resolves type URIs to discover information about the error, taking advantage of that capability would require switching to a resolvable URI, thereby creating a new identity for the problem type and thus introducing a breaking change.\r\n```",
              "createdAt": "2021-09-23T01:06:22Z",
              "updatedAt": "2021-09-23T01:06:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4tZwE8",
          "commit": {
            "abbreviatedOid": "c8df441"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T08:27:33Z",
          "updatedAt": "2021-09-23T08:27:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "this is a really neat feature! thanks for pointing me to it! ;-)",
              "createdAt": "2021-09-23T08:27:34Z",
              "updatedAt": "2021-09-23T08:27:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4tZw6d",
          "commit": {
            "abbreviatedOid": "c8df441"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-23T08:30:52Z",
          "updatedAt": "2021-09-23T08:30:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOE-NsGs4tBjuP",
      "title": "Multiple problems example",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/30",
      "state": "MERGED",
      "author": "sdatspun2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Examples are using `causes` for consistency. Added an example for 207 and multiple problems #6 .",
      "createdAt": "2021-10-11T15:01:29Z",
      "updatedAt": "2021-12-07T16:17:37Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "88cfabe5f656dd4721fdbfb0c8f8e1fd07912794",
      "headRepository": "sdatspun2/rfc7807bis",
      "headRefName": "main",
      "headRefOid": "d151eec15b5143e494f04a33bd36c4f3aedafb05",
      "closedAt": "2021-12-07T16:17:37Z",
      "mergedAt": "2021-12-07T16:17:37Z",
      "mergedBy": "sdatspun2",
      "mergeCommit": {
        "oid": "e62318852b10a00d6dd85852472eebf315baa701"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-12 00:00, Sanjay Dalal wrote:\n> - \"instance\": \"/account/12345/msgs/abc\",\n> + \"instance\": \"/amount/value/50\",\n> \n> Ohh, that is how you read it. I read it differently. I am trying to \n> point out the value of \"that\" in \"Your current balance is 30, but *that* \n> costs 50.\"\n\nthis is a slightly confusing edit. the instance message is about the \naccount not having enough funds. but it's very unlikely and probably \nimpractical that this message will be availble at the URI \n\"/amount/value/50\".\n\nit is more likely that the service keeps a message log somewhere along \nthe lines of \"/account/12345/msgs/abc\" and that when accessed, this log \nmessage will give you all the relevant details, probably including the \n\"this costs 50 but you only have 30\" bit.\n",
          "createdAt": "2021-10-12T07:04:31Z",
          "updatedAt": "2021-10-12T07:04:31Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-12 00:09, Asbj\u00f8rn Ulsberg wrote:\n> I think of the value of |instance| as the URI identifying the very \n> |application/problem+json| document you're currently viewing. It seldom \n> actually is in practice, but I think that's what |instance| semantically \n> conveys. Perhaps a clarification in the spec should be provided to avoid \n> confusion?\n\nRFC 7807 says:\n\n > A URI reference that identifies the specific occurrence of the \nproblem.  It may or may not yield further information if dereferenced.\n\nthe current draft says:\n\n > The \"instance\" member is a JSON string containing a URI reference \nthat identifies the specific occurrence of the problem. It may or may \nnot yield further information if dereferenced.\n\nthe current draft has a lot of additional text about relative URIs in \nthat member, but not much regarding the meaning has been changed. do you \nthink we need more text?\n",
          "createdAt": "2021-10-12T07:13:58Z",
          "updatedAt": "2021-10-12T07:13:58Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-12 16:00, Sanjay Dalal wrote:\n> ***@***.**** commented on this pull request.\n> |/amount/value/50| seems easy to explain in the context of a \n> hypothetical payment transaction vs |/account/12345/msgs/abc| where I \n> would not know what |msgs| and |abc| mean. Is it indicating that account \n> |12345| has messages (|msgs|) and |abc| identifies a message instance \n> and that message instance has a problem |Your current balance is 30, but \n> that costs 50.|? How does this help a client of an API emitting this \n> response?\n\nURIs have no meaning, they are just identifiers. so at some level, this \ndiscussion is moot.\n\nbut the way RFC 7807 works is that the instance URIs identifies the \ninstance of the error. it could be anything. if it is referencable \n(which it doesn't have to be) it most likely will reference a message in \nan error log that you can retrieve and inspect to learn more about the \nerror instance. which is why i much prefer to use a URI that vaguely \nhints in that direction, rather than having one that vaguely hints in \nthe wrong direction of suggesting that the URI itself has any inherent \nmeaning.\n\nbut it seems that by now we have established that this aspect of the \nspec seems to be harder to understand than we expected, so maybe some \nadditional explanation is warranted.\n",
          "createdAt": "2021-10-12T14:31:16Z",
          "updatedAt": "2021-10-12T14:31:16Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-13 03:25, Sanjay Dalal wrote:\n> How about now? I have used URI fragment ids in examples and clarified \n> the usage while describing \"instance\".\n\ni don't find using instance URIs particularly helpful. imho, we should \nstick to the example of the original RFC, assuming that there is some \npersistent message storage, and showing how \"instance\" then could be \nused to link to that message that represents the problem instance.\n",
          "createdAt": "2021-10-13T07:30:18Z",
          "updatedAt": "2021-10-13T07:30:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-16 21:45, Sanjay Dalal wrote:\n> +               \"property_location\": \"#/age\"\n\niff we use this example we probably shouldn't use the fragment \nidentifier separator.\n",
          "createdAt": "2021-10-17T10:24:27Z",
          "updatedAt": "2021-10-17T10:24:27Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "> On 2021-10-16 21:45, Sanjay Dalal wrote: + \"property_location\": \"#/age\"\r\n> iff we use this example we probably shouldn't use the fragment identifier separator.\r\n\r\n@dret Is this because application/problem+json was not perhaps registered to support fragment identifier syntax or it is just a preference? see my comment on the spec.\r\n\r\n{{RFC6901, Section 6}} says that a given media type needs to specify JSON Pointer as its fragment identifier syntax explicitly (usually, in its registration {{RFC6838}}). Does application/problem+json support JSON Pointer's fragment identifier syntax?",
          "createdAt": "2021-10-17T16:14:55Z",
          "updatedAt": "2021-10-17T16:14:55Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2021-10-17 18:15, Sanjay Dalal wrote:\n> @dret <https://github.com/dret> Is this because application/problem+json \n> was not perhaps registered to support fragment identifier syntax or it \n> is just a preference? see my comment on the spec.\n\nas discussed before, RFC 7807 had no intentions of pointing into a \nresource; \"instance\" has an entirely different meaning.\n",
          "createdAt": "2021-10-17T21:04:19Z",
          "updatedAt": "2021-10-17T21:04:19Z"
        },
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "> On 2021-10-17 18:15, Sanjay Dalal wrote: @dret <https://github.com/dret> Is this because application/problem+json was not perhaps registered to support fragment identifier syntax or it is just a preference? see my comment on the spec.\r\n> as discussed before, RFC 7807 had no intentions of pointing into a resource; \"instance\" has an entirely different meaning.\r\n\r\nGot it. Since JSON pointer could be represented either as a string or a URI fragment identifier, API developer could decide. Example is using the fragment identifier, but the description of the extension does not indicate any preference.",
          "createdAt": "2021-10-17T21:35:04Z",
          "updatedAt": "2021-10-17T21:35:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs4uR_3T",
          "commit": {
            "abbreviatedOid": "3eb1987"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I quite like the addition of the `207` example, but I question the `instance` values used and changed in this PR.",
          "createdAt": "2021-10-11T16:21:19Z",
          "updatedAt": "2021-10-11T16:26:20Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Why the change of `instance` value? I think the value `/account/12345/msgs/abc` better captures the intent of the property than `/amount/value/50` by binding the value to a specific occurrence of an error within a specific account number.",
              "createdAt": "2021-10-11T16:21:20Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            },
            {
              "originalPosition": 36,
              "body": "I don't think `/age/-50` gives a good indication of what `instance` is supposed to be used for.",
              "createdAt": "2021-10-11T16:24:05Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            },
            {
              "originalPosition": 40,
              "body": "I don't think `/profile-background-color` gives a good indication of what `instance` is supposed to be used for.",
              "createdAt": "2021-10-11T16:24:20Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            },
            {
              "originalPosition": 64,
              "body": "I don't think `/age/-50` gives a good indication of what `instance` is supposed to be used for.",
              "createdAt": "2021-10-11T16:24:51Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            },
            {
              "originalPosition": 71,
              "body": "I don't think `/profile-background-color/yellow` gives a good indication of what `instance` is supposed to be used for.",
              "createdAt": "2021-10-11T16:25:08Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            },
            {
              "originalPosition": 78,
              "body": "I don't think `/amount/value/50` gives a good indication of what `instance` is supposed to be used for.",
              "createdAt": "2021-10-11T16:25:23Z",
              "updatedAt": "2021-10-11T16:26:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uSLE5",
          "commit": {
            "abbreviatedOid": "3eb1987"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T17:19:29Z",
          "updatedAt": "2021-10-11T17:19:29Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "For \"Your current balance is 30, but that costs 50.\", instance value /account/12345/msgs/abc did not reflect the problem. ",
              "createdAt": "2021-10-11T17:19:29Z",
              "updatedAt": "2021-10-11T17:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uSLRf",
          "commit": {
            "abbreviatedOid": "3eb1987"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T17:20:33Z",
          "updatedAt": "2021-10-11T17:20:33Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I am just trying to relate detail with instance. ",
              "createdAt": "2021-10-11T17:20:33Z",
              "updatedAt": "2021-10-11T17:20:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uSw-3",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T21:21:07Z",
          "updatedAt": "2021-10-11T21:21:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "But the instance of the problem relates to the context in which the problem occurred, who it occurred for, when, and so on. The type of the problem is reflected in the `type` property and doesn't need repetition in the `instance` property?",
              "createdAt": "2021-10-11T21:21:07Z",
              "updatedAt": "2021-10-11T21:21:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uS2uE",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T22:00:00Z",
          "updatedAt": "2021-10-11T22:00:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ohh, that is how you read it. I read it differently. I am trying to point out the value of \"that\" in \"Your current balance is 30, but **that** costs 50.\" ",
              "createdAt": "2021-10-11T22:00:00Z",
              "updatedAt": "2021-10-11T22:00:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uS4aH",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T22:09:22Z",
          "updatedAt": "2021-10-11T22:09:22Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think of the value of `instance` as the URI identifying the very `application/problem+json` document you're currently viewing. It seldom actually is in practice, but I think that's what `instance` semantically conveys. Perhaps a clarification in the spec should be provided to avoid confusion?",
              "createdAt": "2021-10-11T22:09:22Z",
              "updatedAt": "2021-10-11T22:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uTHxW",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T23:18:20Z",
          "updatedAt": "2021-10-11T23:18:21Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "+1 to a clarification, if necessary. ",
              "createdAt": "2021-10-11T23:18:20Z",
              "updatedAt": "2021-10-11T23:18:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uTH1O",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T23:19:04Z",
          "updatedAt": "2021-10-11T23:19:04Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "`instance` is an identifier for the problem's occurrence, not additional details about the problem.",
              "createdAt": "2021-10-11T23:19:04Z",
              "updatedAt": "2021-10-11T23:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uT5sQ",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T07:15:11Z",
          "updatedAt": "2021-10-12T07:15:12Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "i think we should revert back to the made-up `msg` URI.",
              "createdAt": "2021-10-12T07:15:11Z",
              "updatedAt": "2021-10-12T07:15:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uVpK7",
          "commit": {
            "abbreviatedOid": "65611d2"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T13:59:58Z",
          "updatedAt": "2021-10-12T13:59:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I agree on clarification. I thought `instance` would point to problem's occurrence in the *request payload* since the context here is `400`. If the status was something like 5xx, I would use `instance` to point to something that may not be in the request.\r\n\r\n`/amount/value/50` seems easy to explain in the context of a hypothetical payment transaction vs `/account/12345/msgs/abc` where I would not know what `msgs` and `abc` mean. Is it indicating that account `12345`  has messages (`msgs`) and `abc` identifies a message instance and that message instance has a problem `Your current balance is 30, but that costs 50.`? How does this help a client of an API emitting this response?\r\n\r\nSee where I am coming from re errors sent with 400... https://github.com/sdatspun2/error-catalog-service/blob/master/models/error_instance.json\r\n\r\n>I think of the value of instance as the URI identifying the very application/problem+json document you're currently viewing.",
              "createdAt": "2021-10-12T13:59:58Z",
              "updatedAt": "2021-10-12T14:14:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uVpZj",
          "commit": {
            "abbreviatedOid": "64fd41b"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T14:00:40Z",
          "updatedAt": "2021-10-12T14:00:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> +1 to a clarification, if necessary.\r\n\r\n#31 submitted.",
              "createdAt": "2021-10-12T14:00:40Z",
              "updatedAt": "2021-10-12T14:00:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uX3GA",
          "commit": {
            "abbreviatedOid": "66bd2b4"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T01:25:48Z",
          "updatedAt": "2021-10-13T01:25:49Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "How about now? I have used URI fragment ids in examples and clarified the usage while describing \"instance\". ",
              "createdAt": "2021-10-13T01:25:49Z",
              "updatedAt": "2021-10-13T01:25:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uZNpL",
          "commit": {
            "abbreviatedOid": "66bd2b4"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T10:04:55Z",
          "updatedAt": "2021-10-13T10:04:55Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "you seem to imply the use of JSON pointer of a similar mechanism here? but that's not the main problem. the main problem is that `instance` how it's currently defined doesn't work that way. it's not intended to point to the source of the problem, it's intended to identify the problem instance by giving it an identifier.",
              "createdAt": "2021-10-13T10:04:55Z",
              "updatedAt": "2021-10-13T10:04:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4ue93Z",
          "commit": {
            "abbreviatedOid": "dc8f20a"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T14:44:23Z",
          "updatedAt": "2021-10-14T14:44:23Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Ok, review now please.",
              "createdAt": "2021-10-14T14:44:23Z",
              "updatedAt": "2021-10-14T14:44:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4ue98g",
          "commit": {
            "abbreviatedOid": "dc8f20a"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T14:44:38Z",
          "updatedAt": "2021-10-14T14:44:38Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "reverted",
              "createdAt": "2021-10-14T14:44:38Z",
              "updatedAt": "2021-10-14T14:44:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uhsPB",
          "commit": {
            "abbreviatedOid": "1f1d790"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T08:21:52Z",
          "updatedAt": "2021-10-15T08:37:48Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Although `property_location` is just added as an example extension, having it in the specification gives it weight and authority. For something like this to be added (even if only as an extension to an example) I think it needs to be thoroughly discussed in a separate issue first.\r\n\r\nAlso, I don't agree with the naming; idiomatic JSON is `lowerCamelCase` (from JavaScript which again has it from Java), not `snake_case`. The naming of the `invalid-params` property in RFC 7807 points to `kebab-case` being the condoned  naming style, but I'm not sure that's intentional. Either way, let's discuss this in a separate issue.",
              "createdAt": "2021-10-15T08:21:53Z",
              "updatedAt": "2021-10-15T08:37:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4ukGRS",
          "commit": {
            "abbreviatedOid": "1f1d790"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T20:32:32Z",
          "updatedAt": "2021-10-15T20:32:33Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "ok, i have reverted and used an extension. pl review now.",
              "createdAt": "2021-10-15T20:32:32Z",
              "updatedAt": "2021-10-15T20:32:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4ukv4E",
          "commit": {
            "abbreviatedOid": "1d81d71"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-16T19:45:07Z",
          "updatedAt": "2021-10-16T19:45:08Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Opened issue #32. changed to camelCase. ",
              "createdAt": "2021-10-16T19:45:07Z",
              "updatedAt": "2021-10-16T19:45:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4xF1F6",
          "commit": {
            "abbreviatedOid": "3f8bfd6"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-06T07:34:08Z",
          "updatedAt": "2021-12-06T07:34:08Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "The requirement in 6901 only applies if you're using the pointer in a URI -- you're fine here.",
              "createdAt": "2021-12-06T07:34:08Z",
              "updatedAt": "2021-12-06T07:34:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4xF1hc",
          "commit": {
            "abbreviatedOid": "3f8bfd6"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-06T07:36:49Z",
          "updatedAt": "2021-12-06T07:36:49Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "I don't think it's a good idea to go into so much detail here, given that it's just an example. Perhaps just leave the first sentence (\"Similarly...\") in...",
              "createdAt": "2021-12-06T07:36:49Z",
              "updatedAt": "2021-12-06T07:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4xF1us",
          "commit": {
            "abbreviatedOid": "3f8bfd6"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-06T07:38:08Z",
          "updatedAt": "2021-12-06T07:38:08Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Also, there's a tradeoff here -- if someone wants to include all possible errors in the same message, they may need to use 207, and lose any semantic transparency. Or, they could just put a subset of the errors in -- e.g., the most urgent (unauthorised, in this case).\r\n\r\nIf you want to merge this I can make a subsequent proposal to address this.",
              "createdAt": "2021-12-06T07:38:08Z",
              "updatedAt": "2021-12-06T07:38:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4xNCDi",
          "commit": {
            "abbreviatedOid": "d151eec"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T16:15:50Z",
          "updatedAt": "2021-12-07T16:15:50Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Removed.",
              "createdAt": "2021-12-07T16:15:50Z",
              "updatedAt": "2021-12-07T16:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4xNCMK",
          "commit": {
            "abbreviatedOid": "d151eec"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T16:16:19Z",
          "updatedAt": "2021-12-07T16:16:19Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Ok, I have removed the comment. Merging...",
              "createdAt": "2021-12-07T16:16:19Z",
              "updatedAt": "2021-12-07T16:16:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOE-NsGs4tEwnJ",
      "title": "Clarify `instance` dereferenceability",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/31",
      "state": "MERGED",
      "author": "asbjornu",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/ietf-wg-httpapi/rfc7807bis/pull/30#discussion_r726632184, this PR expands on the dereferenceability of `instance` to clarify what the URI is expected to return, which hopefully also clarify the intended use of `instance`.",
      "createdAt": "2021-10-12T13:58:13Z",
      "updatedAt": "2021-10-13T23:16:21Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "f7c830de2cd2851fac24597d409e1db16f67f369",
      "headRepository": "asbjornu/rfc7807bis",
      "headRefName": "feature/instance-clarification",
      "headRefOid": "f68b92f0c066e2266d11fdb516a7200359043c24",
      "closedAt": "2021-10-13T23:15:46Z",
      "mergedAt": "2021-10-13T23:15:46Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "1ef8d97930ba89750db58bab1c5a1f5b2d24e1ce"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging, might tweak a bit further in situ. Thanks!",
          "createdAt": "2021-10-13T23:15:41Z",
          "updatedAt": "2021-10-13T23:15:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs4uVo_8",
          "commit": {
            "abbreviatedOid": "5086732"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T13:59:28Z",
          "updatedAt": "2021-10-12T13:59:49Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I don't know what the procedure around the credit of authorship for an RFC is like, so I just added myself to the author list. If that was a mistake, please let me know and I'll remove it.",
              "createdAt": "2021-10-12T13:59:28Z",
              "updatedAt": "2021-10-12T13:59:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uVydC",
          "commit": {
            "abbreviatedOid": "5086732"
          },
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T14:28:36Z",
          "updatedAt": "2021-10-12T14:28:36Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@mnot @dret Is this how it was originally intended? I always thought that one can use something like JSON pointer (if JSON-based content negotiations) in `instance` to pinpoint exactly where the problem is in the request for which response with problem details is sent with status `400`\r\n\r\nOtherwise the following assumes that one has to provide a way to retrieve historic problems.\r\n\r\n>it may return the same problem response that was returned to the client which generated the problem originally",
              "createdAt": "2021-10-12T14:28:36Z",
              "updatedAt": "2021-10-12T14:29:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uWJWe",
          "commit": {
            "abbreviatedOid": "5086732"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T15:40:20Z",
          "updatedAt": "2021-10-12T15:40:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "> Otherwise the following assumes that one has to provide a way to retrieve historic problems.\r\n\r\nThere is no mention of MUST here, it only says \"it may return\". This makes the historic problem retrieval completely optional, but still explains what the URI is supposed to mean, semantically.\r\n\r\nThe wording follows the same language used for all URIs in RFC 7807;\r\n\r\n> It may or may not yield further information if dereferenced.",
              "createdAt": "2021-10-12T15:40:20Z",
              "updatedAt": "2021-10-12T15:41:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uXykK",
          "commit": {
            "abbreviatedOid": "5086732"
          },
          "author": "mnot",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T00:36:09Z",
          "updatedAt": "2021-10-13T00:38:38Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Hey @asbjornu -- the authors/editors are assigned by the Chairs, you can't add yourself. ",
              "createdAt": "2021-10-13T00:36:09Z",
              "updatedAt": "2021-10-13T00:38:38Z"
            },
            {
              "originalPosition": 18,
              "body": "That's correct. I've suggested changing 'may' to 'can' or 'might', just to avoid confusion with requirements language.\r\n\r\n```suggestion\r\nWhen the \"instance\" URI is dereferenceable it can return the same problem response that was returned to the client which generated the problem originally. It might also return more information about the problem occurrence in other formats (e.g., using proactive content negotiation; see {{HTTP, Section 12.5.1}}).\r\n```",
              "createdAt": "2021-10-13T00:37:24Z",
              "updatedAt": "2021-10-13T00:38:38Z"
            },
            {
              "originalPosition": 20,
              "body": "Maybe\r\n\r\n```suggestion\r\nWhen the \"instance\" URI is not dereferenceable, it serves as a unique identifier for the problem occurrence that may be of significance to the server, but is opaque to the client.\r\n```",
              "createdAt": "2021-10-13T00:38:31Z",
              "updatedAt": "2021-10-13T00:38:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4uYow_",
          "commit": {
            "abbreviatedOid": "f68b92f"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T07:49:11Z",
          "updatedAt": "2021-10-13T07:49:11Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Okay, it's gone.",
              "createdAt": "2021-10-13T07:49:11Z",
              "updatedAt": "2021-10-13T07:49:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOE-NsGs407BCV",
      "title": "Multiple Problems adjustment",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/37",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed on-issue. \r\n\r\nFixes #6.",
      "createdAt": "2022-03-24T03:21:51Z",
      "updatedAt": "2022-03-24T20:47:27Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "cae5a5bb09ba3b958223047a24aaae25d9249caf",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/6",
      "headRefOid": "73b4dc91fe86ad851d4a218bff7f5774a3b5fea7",
      "closedAt": "2022-03-24T20:47:27Z",
      "mergedAt": "2022-03-24T20:47:26Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "5ec135c2960f41a645def6f22db2777df3e54dfc"
      },
      "comments": [
        {
          "author": "sdatspun2",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to merge.",
          "createdAt": "2022-03-24T15:18:27Z",
          "updatedAt": "2022-03-24T15:18:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOE-NsGs407Br3",
      "title": "Adjust registry policy",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/38",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #34.",
      "createdAt": "2022-03-24T03:27:09Z",
      "updatedAt": "2022-03-24T20:47:39Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "cae5a5bb09ba3b958223047a24aaae25d9249caf",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/34",
      "headRefOid": "7115968e7f329dcdb171b6d14ffc8d1311d003f6",
      "closedAt": "2022-03-24T20:47:38Z",
      "mergedAt": "2022-03-24T20:47:38Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "9ffe01d09d6c595e7419df5f32c0efe33bf2bb36"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "PR_kwDOE-NsGs40-wsZ",
      "title": "Rough in a Problem HTTP field",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/39",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A couple of decision points to note:\r\n\r\n* This mandates that title and detail contain ASCII strings. If\r\nfolks feel unicode support is important, that could be done by also\r\nallowing binary, or using some encoding.\r\n\r\n* This requires the problem type to define the SH type of any extensions.\r\nThey also could be inferred, I suppose - but if there's any JSON structure,\r\nthat'd get tricky.\r\n\r\nFor #35.",
      "createdAt": "2022-03-24T21:32:44Z",
      "updatedAt": "2022-05-11T01:10:27Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "80145bbe017b98eacd259562d16412bf31ee8808",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/35",
      "headRefOid": "45301c14facb1a950534d6c8ee4d57c8e4d15f82",
      "closedAt": "2022-05-11T01:10:26Z",
      "mergedAt": "2022-05-11T01:10:26Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "90b9718539f667a3490af2778e9e35f9288c9ad6"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes -  my thinking is that an API will define which it uses.",
          "createdAt": "2022-03-25T01:25:39Z",
          "updatedAt": "2022-03-25T01:25:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-03-25 02:25, Mark Nottingham wrote:\n> Yes - my thinking is that an API will define which it uses.\n\nyes, that works well from the perspective of API producers: they choose \nwhich way to go and then implement things accordingly.\n\nit's less great from the perspective of consumers who oftentimes will \nconsume more than one API to get their jobs done. now they need to jump \nback and forth and know what to expect based on which API they're \ninteracting with.\n\nin my mind, the more we can avoid consumers having to \"know the API\" and \nallow them to just work seamlessly across resources, the better. which \nis why i think even though it certainly is feasible to also represent \nproblem details in a header field, it may be the better design overall \nto avoid adding the requirement to know where to look for problem details.\n",
          "createdAt": "2022-03-25T07:40:23Z",
          "updatedAt": "2022-03-25T07:40:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs425jnJ",
          "commit": {
            "abbreviatedOid": "49851ee"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This seems like a fairly simple way to manage this.\r\n\r\nI'm most concerned about there being only one way to learn about a problem, which this directly challenges.  Including the problem report in the body of a 4xx response is unambiguous, whereas this means that you need to look in two places.",
          "createdAt": "2022-03-25T01:11:03Z",
          "updatedAt": "2022-03-25T01:13:20Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Unrelated, but...\r\n```suggestion\r\nv: 3\r\n```\r\n",
              "createdAt": "2022-03-25T01:11:04Z",
              "updatedAt": "2022-03-25T01:13:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOE-NsGs42YsCs",
      "title": "Allow future standard extensions",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/41",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "media_type"
      ],
      "body": "Fixes #36",
      "createdAt": "2022-04-18T22:28:40Z",
      "updatedAt": "2023-04-22T16:38:02Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "9ffe01d09d6c595e7419df5f32c0efe33bf2bb36",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/36",
      "headRefOid": "1cb2f4f0f012027304c40d5d6c13f8d9d9e612ab",
      "closedAt": "2022-04-27T04:04:33Z",
      "mergedAt": "2022-04-27T04:04:33Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "7613ae73ab7aa579671789e37c82b664f2c02412"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOE-NsGs44b2QP",
      "title": "Terminology review",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/45",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- preliminary terminology review",
      "createdAt": "2022-05-25T10:34:05Z",
      "updatedAt": "2022-06-20T00:32:04Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "40d3d4914c8683dc6a7cfecf93ba198b6567c300",
      "headRepository": "ioggstream/rfc7807bis",
      "headRefName": "patch-1",
      "headRefOid": "8ebf734feb3f9028ad94228ee0af51497290b774",
      "closedAt": "2022-06-20T00:32:04Z",
      "mergedAt": "2022-06-20T00:32:04Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "8801defce6d2b29af0ccdbeca45d79f7708ba49b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs46v51a",
          "commit": {
            "abbreviatedOid": "c6aad14"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Looks very good thanks! A few additional suggestions below.",
          "createdAt": "2022-05-26T01:42:54Z",
          "updatedAt": "2022-05-26T01:44:22Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nThe \"title\" string is advisory, and is included only for users who both are not aware of and cannot discover the semantics of the type URI (e.g., during offline log analysis).\r\n```",
              "createdAt": "2022-05-26T01:42:55Z",
              "updatedAt": "2022-05-26T01:44:22Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nConsumers can use the status member to determine what the original status code used by the generator was when it has been changed (e.g., by an intermediary or cache), and when a message's content is persisted without HTTP information. Generic HTTP software will still use the HTTP status code.\r\n```",
              "createdAt": "2022-05-26T01:44:05Z",
              "updatedAt": "2022-05-26T01:44:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOE-NsGs46spY4",
      "title": "Minor editorial change",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/47",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It seems that saying \r\n\r\n> Consumers MUST use the \"type\" URI (after resolution, if necessary) as the problem's primary identifier.\r\n\r\ncould be read as `type` identifying the problem instance rather than identifying the problem type. Here's a minor edit to make this more explicit:\r\n\r\n> Consumers MUST use the \"type\" URI (after resolution, if necessary) as the problem type's primary identifier.\r\n\r\nIt's not quite clear to me what other identifiers could be (patterns of extension members, maybe?), but that's a different question.",
      "createdAt": "2022-07-01T10:08:56Z",
      "updatedAt": "2022-07-04T00:27:51Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "8801defce6d2b29af0ccdbeca45d79f7708ba49b",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "dret-patch-1",
      "headRefOid": "bab559ea5b07d123138b05911ca2dedb99ea91f2",
      "closedAt": "2022-07-04T00:27:50Z",
      "mergedAt": "2022-07-04T00:27:50Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "6f563e11374b7a6a9e9dd9ace27fb7ef853b778b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOE-NsGs48Gc1T",
      "title": "Add JSON-LD Context",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/48",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #10. Awaits approval by chairs (see https://github.com/ietf-wg-httpapi/rfc7807bis/issues/46#issuecomment-1195126352).",
      "createdAt": "2022-07-26T10:14:31Z",
      "updatedAt": "2023-04-11T16:02:12Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "6f563e11374b7a6a9e9dd9ace27fb7ef853b778b",
      "headRepository": "asbjornu/rfc7807bis",
      "headRefName": "feature/json-ld-context",
      "headRefOid": "00d3439ec5d541537f24fc97b94291e75466e185",
      "closedAt": "2023-04-11T16:02:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-07-26 16:24, Asbj\u00f8rn Ulsberg wrote:\n> ***@***.**** commented on this pull request.\n> +  ***@***.***\": {\n> +    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n> +    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n> +    \"type\": { ***@***.***\": \"rdf:type\", ***@***.***\": ***@***.***\" },\n> +    \"status\": \"urn:ietf:rfc:7807:status\",\n> \n> I'm a bit unsure about |status| being mapped to the URN \n> |urn:ietf:rfc:7807:status|. First, is the colon a fine separator for \n> |:status| @dret <https://github.com/dret> @mnot \n> <https://github.com/mnot>? Also, is RFC 7807 the right RFC to reference \n> or should we reference the HTTP RFC 9110 instead?\n\nwhat in either of those standards would justify to use that URN? RFC \n9110 defines the concept of an HTTP status, RFC 7807 defines the string \n\"status\" as a JSON member of a problem report. neither of them define \nthese as URN or with that specific URN namespace.\n",
          "createdAt": "2022-07-26T15:09:48Z",
          "updatedAt": "2022-07-26T15:09:48Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> what in either of those standards would justify to use that URN? RFC 9110 defines the concept of an HTTP status, RFC 7807 defines the string \"status\" as a JSON member of a problem report.\r\n\r\n@dret, the URN will change \u2013\u00a0at least once the RFC number of rfc7807bis is minted, if we agree that we should use rfc7807bis as the namespace provider for `status`. Referencing RFC 9110 would be easier, since it has a final RFC number minted already.\r\n\r\n> neither of them define these as URN or with that specific URN namespace.\r\n\r\nIs it a requirement that an RFC defines a URN for \"itself\" in order for other specifications to reference it? If we go with rfc7807bis, we can define the URN `urn:rfc:7807bis` within the scope of the spec itself. For RFC 9110, we have no such flexibility, so if the URN needs to be predefined, we can't use it.",
          "createdAt": "2022-07-26T15:25:37Z",
          "updatedAt": "2022-07-26T15:25:37Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "On 2022-07-26 17:25, Asbj\u00f8rn Ulsberg wrote:\n> @dret <https://github.com/dret>, the URN will change \u2013\u00a0at least once the \n> RFC number of rfc7807bis is minted, if we agree that we should use \n> rfc7807bis as the namespace provider for |status|. Referencing RFC 9110 \n> would be easier, since it has a final RFC number minted already.\n\nneither of those make any claims or statements about their concepts \nbeing identified through URNs. that's quite an assumption to make, in my \nmind.\n\n> Is it a requirement that an RFC defines a URN for \"itself\" in order for \n> other specifications to reference it? If we go with rfc7807bis, we can \n> define the URN |urn:rfc:7807bis| within the scope of the spec itself. \n> For RFC 9110, we have no such flexibility, so if the URN needs to be \n> predefined, we can't use it.\n\nof course nobody can keep third parties from inventing any identifier \nthat they want (assuming they're ok with those being private identifiers \nand not claiming any authority to mint public ones). it's a bit \ndifferent when we add those to a specification itself, in my mind.\n",
          "createdAt": "2022-07-26T15:33:35Z",
          "updatedAt": "2022-07-26T15:33:35Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "I added a comment here https://github.com/ietf-wg-httpapi/rfc7807bis/issues/46#issuecomment-1195126352  This content feels like it is in the wrong place to me.",
          "createdAt": "2022-08-09T13:54:24Z",
          "updatedAt": "2022-08-09T13:54:24Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As further proof for IETF needing to figure out how to do namespacing, here's how Microsoft ASP.NET now by default responds for `404` errors in controllers decorated with `[ApiController]`:\r\n\r\n```json\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc7231#section-6.5.4\",\r\n  \"title\": \"Not Found\",\r\n  \"status\": 404,\r\n  \"traceId\": \"\u2026\"\r\n}\r\n```\r\n\r\nNotice how `type` has the value `https://tools.ietf.org/html/rfc7231#section-6.5.4`. Is this usage condoned by IETF? If so, can't we do the same in rfc7807bis itself?",
          "createdAt": "2022-09-23T12:09:30Z",
          "updatedAt": "2022-09-23T12:10:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Given that tools.ietf.org is no longer functional, no. This is a great illustration of why you shouldn't use someone else's name space without their permission...\r\n\r\nThe IETF certainly can manage name spaces -- that's what IANA is for. However, we need to agree on it and document it, both of which will require work. The best thing to do would be to write a problem statement (in an Internet-Draft or an email) and take it to [DISPATCH](https://datatracker.ietf.org/wg/dispatch/about/) for further discussion.\r\n",
          "createdAt": "2022-09-23T23:46:07Z",
          "updatedAt": "2022-09-23T23:46:07Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Given that tools.ietf.org is no longer functional, no.\r\n\r\nThat was my thought too. As someone who works within the company that has made this default implementation, what's your thoughts on this, @darrelmiller?\r\n\r\n> This is a great illustration of why you shouldn't use someone else's name space without their permission...\r\n\r\nExactly.\r\n\r\n> The IETF certainly can manage name spaces -- that's what IANA is for. However, we need to agree on it and document it, both of which will require work.\r\n\r\nI see.\r\n\r\n> The best thing to do would be to write a problem statement (in an Internet-Draft or an email) and take it to [DISPATCH](https://datatracker.ietf.org/wg/dispatch/about/) for further discussion.\r\n\r\nOkay. Sounds like something that rfc7807bis can't wait for, though.",
          "createdAt": "2022-09-26T13:32:23Z",
          "updatedAt": "2022-09-26T13:32:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "hello asbj\u00f8rn.\n\nOn Sep 23, 2022, at 05:09, Asbj\u00f8rn Ulsberg ***@***.***> wrote:\n> As further proof for IETF needing to figure out how to do namespacing, here's how Microsoft ASP.NET now by default responds for 404 errors in controllers decorated with [ApiController]:\n> \n> {\n>   \"type\": \"https://tools.ietf.org/html/rfc7231#section-6.5.4\",\n>   \"title\": \"Not Found\",\n>   \"status\": 404,\n>   \"traceId\": \"\u2026\"\n> }\n> Notice how type has the value https://tools.ietf.org/html/rfc7231#section-6.5.4. Is this usage condoned by IETF? If so, can't we do the same for status in RFC 7807?\n> \n\nit's not nentioned or encouraged and doesn't make a lot of sense because essentially \"type\" only repeats the \"status\" (at least that looks like the intent), instead of providing additional information regarding the type of problem.\n\ncheers,\n\ndret.",
          "createdAt": "2022-10-11T08:39:48Z",
          "updatedAt": "2022-10-11T08:39:48Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it's not nentioned or encouraged and doesn't make a lot of sense because essentially \"type\" only repeats the \"status\" (at least that looks like the intent), instead of providing additional information regarding the type of problem. cheers, dret.\r\n\r\nAgreed. But it does underscore the need for IETF to establish a namespace architecture for these sorts of things.",
          "createdAt": "2022-10-11T11:07:20Z",
          "updatedAt": "2022-10-11T11:07:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs4-owcz",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-26T12:12:20Z",
          "updatedAt": "2022-07-26T12:12:20Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "How does that link header help non-JSON-LD capable clients?",
              "createdAt": "2022-07-26T12:12:20Z",
              "updatedAt": "2022-07-26T12:12:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-paMm",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-26T14:02:31Z",
          "updatedAt": "2022-07-26T14:02:31Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "It helps that the JSON-LD context is not referenced in a `\"@context\"` property within the JSON body.",
              "createdAt": "2022-07-26T14:02:31Z",
              "updatedAt": "2022-07-26T14:02:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-pjXB",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-26T14:24:14Z",
          "updatedAt": "2022-07-26T14:24:14Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I'm a bit unsure about `status` being mapped to the URN `urn:ietf:rfc:7807:status`. First, is the colon a fine separator for `:status` @dret @mnot? Also, is RFC 7807 the right RFC to reference or should we reference the HTTP RFC 9110 instead?",
              "createdAt": "2022-07-26T14:24:14Z",
              "updatedAt": "2022-07-26T14:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-p-Dp",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-26T15:27:25Z",
          "updatedAt": "2022-07-26T15:27:26Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I suppose using `7807bis` is more appropriate than `7807` since it's not the existing RFC we are referencing, but the one this draft will be published as.\r\n\r\n```suggestion\r\n    \"status\": \"urn:ietf:rfc:7807bis:status\",\r\n```",
              "createdAt": "2022-07-26T15:27:25Z",
              "updatedAt": "2022-07-26T15:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-sM4A",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T01:08:50Z",
          "updatedAt": "2022-07-27T01:08:50Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What's the significance of 'non' here? To my eyes it means that 'if you don't understand/use JSON-LD, this will help your interoperability' which is counterintuitive.",
              "createdAt": "2022-07-27T01:08:50Z",
              "updatedAt": "2022-07-27T01:08:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-sNRN",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T01:12:22Z",
          "updatedAt": "2022-07-27T01:12:22Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I am far from a URN expert, but AIUI you can't just tack on a string at the end -- RFC2648 doesn't allow for it.",
              "createdAt": "2022-07-27T01:12:22Z",
              "updatedAt": "2022-07-27T01:12:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-s9hI",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T06:51:59Z",
          "updatedAt": "2022-07-27T06:51:59Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I looked up RFC2141 and the last URN's segment, the [Namespace Specific String](https://datatracker.ietf.org/doc/html/rfc2141#section-2.2) is quite permissive.\r\n\r\nIn the above case, `rfc:7807:status` is the NSS and it is valid. Colons are also allowed according to the grammar",
              "createdAt": "2022-07-27T06:51:59Z",
              "updatedAt": "2022-07-27T06:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-s-Fd",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T06:54:19Z",
          "updatedAt": "2022-07-27T06:54:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yes, but in this case 2648 controls the NSS.",
              "createdAt": "2022-07-27T06:54:19Z",
              "updatedAt": "2022-07-27T06:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-s_Ct",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T06:58:00Z",
          "updatedAt": "2022-07-27T06:58:01Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Right. It also include that `other-nss = string` rule at the end. :)",
              "createdAt": "2022-07-27T06:58:01Z",
              "updatedAt": "2022-07-27T06:58:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-tBVG",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T07:06:35Z",
          "updatedAt": "2022-07-27T07:06:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "That's not at the end, that's an alternative to RFC, FYI, STD, etc. - for future extension of the IETF namespace.",
              "createdAt": "2022-07-27T07:06:35Z",
              "updatedAt": "2022-07-27T07:06:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-tEmk",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "tpluscode",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T07:18:16Z",
          "updatedAt": "2022-07-27T07:18:16Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yes. I see the comment about future prefixes. In that case ti would appear we cannot use this kind of URN. The previous idea was to use hydra's `status` property URI but wanted to avoid introducing Hydra vocabulary here",
              "createdAt": "2022-07-27T07:18:16Z",
              "updatedAt": "2022-07-27T07:18:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4-tf8c",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-27T08:41:06Z",
          "updatedAt": "2022-07-27T08:41:07Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "So the `urn:rfc:` namespace only allows a number at the end and nothing more? How inflexible, inconvenient and unnecessary. \u2639\ufe0f This means that @dret's suggestion to use `urn:rfc:nnnn` in https://github.com/ietf-wg-httpapi/rfc7807bis/issues/10#issuecomment-851529341 was a misdirection, really. The way JSON-LD and RDF works is that every term has its own canonical URI, prefixed with the URI of the vocabulary. That means if we use `urn:rfc:7807bis` as our vocabulary URI as @dret suggested, the full URI of all terms within the vocabulary will be `urn:rfc:7807bis<term>` or `urn:rfc:7807bisstatus` for `status`, unless we map each term individually (as I've suggested).\r\n\r\nUsing the `rfc` URN seems out of the question, then. All the more reason for me to dislike them. \ud83d\ude05 So we would need an HTTP URI. As @tpluscode mentions, we could use the Hydra NS URI, but I agree with him that it feels wrong to rely on Hydra for this. However, rfc7807bis defines its own header for each member, which may be helpful:\r\n\r\nhttps://github.com/ietf-wg-httpapi/rfc7807bis/blob/6f563e11374b7a6a9e9dd9ace27fb7ef853b778b/draft-ietf-httpapi-rfc7807bis.md?plain=1#L221\r\n\r\nWith that, perhaps we can do something like `https://www.ietf.org/rfc/rfc7807bis.html#status` (where `rfc7807bis` is replaced by the real RFC number once it's minted)?",
              "createdAt": "2022-07-27T08:41:06Z",
              "updatedAt": "2022-07-27T08:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_ntKf",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-09T20:56:56Z",
          "updatedAt": "2022-08-09T20:56:57Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Hm. I'm not sure how to explain it otherwise. For clients and developers of clients that has no idea what JSON-LD is, seeing a `\"@context\"` property within an `application/problem+json` response would be confusing, as that is not a property defined by rfc7807bis.\r\n\r\nTo avoid this confusion, we can thus recommend that producers of `application/problem+json` responses that are going to be consumed as JSON-LD by some (but not all) clients, to  add a `Link` header to the response rather than a `\"@context\"` property within the JSON body.",
              "createdAt": "2022-08-09T20:56:56Z",
              "updatedAt": "2022-08-09T20:56:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_ntaO",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-09T20:57:51Z",
          "updatedAt": "2022-08-09T20:57:52Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Can you please respond to the idea of using `https://www.ietf.org/rfc/rfc7807bis.html#status` as the URI for the `status` field, @mnot?",
              "createdAt": "2022-08-09T20:57:51Z",
              "updatedAt": "2022-08-09T20:57:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_obyG",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-10T02:02:43Z",
          "updatedAt": "2022-08-10T02:02:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "That's helpful, thanks. To try to restate (tell me if I'm successful or not), you want to establish a best practice for people who want to use JSON-LD with problem types that they don't control, in a way that doesn't interfere with their consumption.\r\n\r\nIf so, that seems like a reasonable approach. However, I still don't believe it's necessary or helpful to document it in _this_ specification. More discussion in #46. ",
              "createdAt": "2022-08-10T02:02:43Z",
              "updatedAt": "2022-08-10T02:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_odO6",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-10T02:14:51Z",
          "updatedAt": "2022-08-10T02:14:51Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "There are no firm guarantees about the stability of those URIs; even RFC-editor.org lacks a URL stability policy (although I suspect they'd be unlikely to change).\r\n\r\nThe closest option right now is the [IETF registered protocol parameters IETF sub-namespace](https://www.rfc-editor.org/rfc/rfc3553), but 'status' isn't so much a protocol parameter as it is a concept in the protocol -- i.e., it's not _registered_, like that approach requires.\r\n\r\nSo I'd use a URL elsewhere that has a good stability policy -- e.g., at the W3C.",
              "createdAt": "2022-08-10T02:14:51Z",
              "updatedAt": "2022-08-10T02:14:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_zb62",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-11T22:56:10Z",
          "updatedAt": "2022-08-11T22:56:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "If we somehow registered `status` as a \"protocol parameter\", could we use something like `urn:ietf:params:problem:status`?",
              "createdAt": "2022-08-11T22:56:10Z",
              "updatedAt": "2022-08-11T22:56:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_z2XQ",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-12T03:21:34Z",
          "updatedAt": "2022-08-12T03:21:35Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "That's not a registered protocol parameter.",
              "createdAt": "2022-08-12T03:21:35Z",
              "updatedAt": "2022-08-12T03:21:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs4_4qCu",
          "commit": {
            "abbreviatedOid": "3b580d7"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-12T22:17:10Z",
          "updatedAt": "2022-08-12T22:17:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I know it isn't. Is it too much of a stretch to register it as one?",
              "createdAt": "2022-08-12T22:17:10Z",
              "updatedAt": "2022-08-12T22:17:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOE-NsGs4-alnE",
      "title": "fix typo in abstract",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/55",
      "state": "MERGED",
      "author": "luchsamapparat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-06T07:16:22Z",
      "updatedAt": "2022-09-06T07:18:57Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "6055e62662c4ff87fec96201e6f82bcc4da32030",
      "headRepository": "luchsamapparat/rfc7807bis",
      "headRefName": "patch-1",
      "headRefOid": "15783a7735a2746f2661c880ded797bbfe0e1bc7",
      "closedAt": "2022-09-06T07:18:57Z",
      "mergedAt": "2022-09-06T07:18:57Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "276dd255c32f8c1d51b7ce500f5a55375a0f0279"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2022-09-06T07:18:53Z",
          "updatedAt": "2022-09-06T07:18:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOE-NsGs5CF3Yy",
      "title": "Typos and other nits",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/58",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From IETF last-call review",
      "createdAt": "2022-11-02T21:14:13Z",
      "updatedAt": "2022-11-03T10:11:51Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "276dd255c32f8c1d51b7ce500f5a55375a0f0279",
      "headRepository": "cabo/rfc7807bis",
      "headRefName": "nits",
      "headRefOid": "15850ad7fe08f932d75d3373a55a6a73a074dab6",
      "closedAt": "2022-11-03T10:11:46Z",
      "mergedAt": "2022-11-03T10:11:46Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "2ff2f80e512474d0101d673c023d764f33ad6e98"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2022-11-03T10:11:51Z",
          "updatedAt": "2022-11-03T10:11:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOE-NsGs5CF30H",
      "title": "Add CDDL data definition for JSON form of problem object",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/59",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Did not write the text integrating this in Appendix A or making a new appendix; editor's choice.)",
      "createdAt": "2022-11-02T21:16:21Z",
      "updatedAt": "2023-04-13T04:46:06Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "276dd255c32f8c1d51b7ce500f5a55375a0f0279",
      "headRepository": "cabo/rfc7807bis",
      "headRefName": "cddl-definition",
      "headRefOid": "e79c17a979c2d37dd41de8159db4d81887d8ff4e",
      "closedAt": "2023-04-13T04:46:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding to @mnot's comment in the email thread: This seems more like advocacy for a specific tech than user needs. Personally, I've heard people asking about JSON schema but never for CDDL.",
          "createdAt": "2022-11-06T19:05:22Z",
          "updatedAt": "2022-11-06T19:05:22Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "@cabo  In a recent reading of the RFC 8610 I came across this guidance,\r\n\r\n> In no case is it intended that a CDDL tool would be \"writing code\"\r\n   for an implementation.\r\nhttps://www.rfc-editor.org/rfc/rfc8610#section-4.2\r\n\r\nA liberal interpretation of this guidance would make CDDL inappropriate for a large group of HTTP API consumers and producers.  Many developers use code generation tools for creating boilerplate code for either calling HTTP APIs or implementing HTTP APIs.  I think it would be valuable to have a better understanding of the reasoning behind this guidance before including CDDL schemas in RFCs targeted at HTTP API developers.",
          "createdAt": "2022-12-04T17:47:46Z",
          "updatedAt": "2022-12-04T17:48:10Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Darrel,\r\n\r\nthe section you cite is trying to warn about the dangers of overzealous validation.\r\nGenerating code from a data description may lead to exactly that, so this is what the last sentence is about.\r\nHowever, there are various efforts that do generate code from CDDL, so the sentence taken out of context is somewhat overtaken by events.\r\nIn any case, this PR is about complementing the English and json-schema.org descriptions by one that fits on a whiteboard, which may have value beyond being able to automatically generate code from that description.\r\n",
          "createdAt": "2022-12-04T17:59:17Z",
          "updatedAt": "2022-12-04T17:59:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 68,
      "id": "PR_kwDOE-NsGs5F64vy",
      "title": "Switch the field to an Item",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/68",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #56",
      "createdAt": "2022-12-21T01:54:37Z",
      "updatedAt": "2023-04-13T04:45:48Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "d5aa3e8fd64ad94157549ad2828ce8565db6e99c",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "mnot/56",
      "headRefOid": "bac60fc5d36125fa0b8fc99e313cdf9264031e3a",
      "closedAt": "2023-04-13T04:45:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2023-04-13T04:45:47Z",
          "updatedAt": "2023-04-13T04:45:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs5JEbSB",
          "commit": {
            "abbreviatedOid": "c842f60"
          },
          "author": "asbjornu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-21T11:07:40Z",
          "updatedAt": "2022-12-21T11:07:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOE-NsGs5JTFwQ",
          "commit": {
            "abbreviatedOid": "c842f60"
          },
          "author": "malevy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-25T12:44:24Z",
          "updatedAt": "2022-12-25T12:44:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Extra decimal point in the section reference?",
              "createdAt": "2022-12-25T12:44:24Z",
              "updatedAt": "2022-12-25T12:44:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs5JTPCl",
          "commit": {
            "abbreviatedOid": "c842f60"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-25T22:02:21Z",
          "updatedAt": "2022-12-25T22:02:21Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nThe Problem HTTP field allows a limited expression of a problem object in HTTP headers or trailers. It is an Item Structured Field whose value is a String ({{Section 3.3.3 of STRUCTURED-FIELDS}}) that conveys the type value (see {{type}}). It has the following optional Parameters:\r\n```",
              "createdAt": "2022-12-25T22:02:21Z",
              "updatedAt": "2022-12-25T22:02:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs5LYx9c",
          "commit": {
            "abbreviatedOid": "bac60fc"
          },
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-22T14:57:30Z",
          "updatedAt": "2023-01-22T14:57:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOE-NsGs5IURo5",
      "title": "add missing curly brace",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/69",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-23T11:08:25Z",
      "updatedAt": "2023-01-24T00:02:16Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "d5aa3e8fd64ad94157549ad2828ce8565db6e99c",
      "headRepository": "reschke/rfc7807bis",
      "headRefName": "patch-3",
      "headRefOid": "7183b9f8521f4a9a67e1fd363e3a08e20e69f478",
      "closedAt": "2023-01-24T00:02:10Z",
      "mergedAt": "2023-01-24T00:02:10Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e3b445536d86efdfd6a6b4d7956ae1b0a5df8ce6"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2023-01-24T00:02:16Z",
          "updatedAt": "2023-01-24T00:02:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOE-NsGs5I5hRV",
      "title": "murray's proposed change to \"example.org\"",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/70",
      "state": "OPEN",
      "author": "dret",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/httpapi/zJbv5SzdnMcViCJIMWOOq2GH5J4",
      "createdAt": "2023-01-31T10:15:31Z",
      "updatedAt": "2023-02-01T23:43:42Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "0b4e93d814e83a6a01d2a47fbd7ad3fa19441cec",
      "headRepository": "ietf-wg-httpapi/rfc7807bis",
      "headRefName": "example-org-patch",
      "headRefOid": "776afd7ec354cfa59c2ba1346e39b418db8d87ab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOE-NsGs5MLoTs",
          "commit": {
            "abbreviatedOid": "776afd7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-31T22:27:27Z",
          "updatedAt": "2023-01-31T22:27:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\ntag:example@example.org,2021-09-17:OutOfLuck\r\n```",
              "createdAt": "2023-01-31T22:27:27Z",
              "updatedAt": "2023-01-31T22:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs5MNw7t",
          "commit": {
            "abbreviatedOid": "776afd7"
          },
          "author": "dret",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T08:59:07Z",
          "updatedAt": "2023-02-01T08:59:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was debating that one. I think it's fine either way, it felt like the domain name was the main issue.",
              "createdAt": "2023-02-01T08:59:07Z",
              "updatedAt": "2023-02-01T08:59:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOE-NsGs5MTAIr",
          "commit": {
            "abbreviatedOid": "776afd7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T23:43:41Z",
          "updatedAt": "2023-02-01T23:43:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I just put it in without thinking -- example@example.org is clearest",
              "createdAt": "2023-02-01T23:43:42Z",
              "updatedAt": "2023-02-01T23:43:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOE-NsGs5KwV6G",
      "title": "7807bis: outdent \"}\" in JSON content",
      "url": "https://github.com/ietf-wg-httpapi/rfc7807bis/pull/73",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-25T11:29:54Z",
      "updatedAt": "2023-02-25T11:58:36Z",
      "baseRepository": "ietf-wg-httpapi/rfc7807bis",
      "baseRefName": "main",
      "baseRefOid": "cca9f448c640aa1f4c2edf4fbad6183833f099dd",
      "headRepository": "reschke/rfc7807bis",
      "headRefName": "patch-4",
      "headRefOid": "1cc610589dbbf6931f158ff1ec98475f9b571693",
      "closedAt": "2023-02-25T11:58:36Z",
      "mergedAt": "2023-02-25T11:58:36Z",
      "mergedBy": "dret",
      "mergeCommit": {
        "oid": "7d6c3038c450149386908a26fb2cc616f298816f"
      },
      "comments": [],
      "reviews": []
    }
  ]
}